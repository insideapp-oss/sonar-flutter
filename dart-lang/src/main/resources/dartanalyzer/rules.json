[
    {
        "key": "abi_specific_integer_invalid",
        "name": "Abi specific integer invalid",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a class that extends AbiSpecificInteger doesn't meet all of the following requirements:\n @see https://dart.dev/tools/diagnostic-messages#abi_specific_integer_invalid",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "abstract_field_initializer",
        "name": "Abstract field initializer",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a field that has the abstract modifier also has an initializer.\n @see https://dart.dev/tools/diagnostic-messages#abstract_field_initializer",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "argument_type_not_assignable_to_error_handler",
        "name": "Argument type not assignable to error handler",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an invocation of Future.catchError has an argument that is a function whose parameters aren't compatible with the arguments that will be passed to the function when it's invoked. The static type of the first argument to catchError is just Function, even though the function that is passed in is expected to have either a single parameter of type Object or two parameters of type Object and StackTrace.\n @see https://dart.dev/tools/diagnostic-messages#argument_type_not_assignable_to_error_handler",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "body_might_complete_normally",
        "name": "Body might complete normally",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a method or function has a return type that's potentially non-nullable but would implicitly return null if control reached the end of the function.\n @see https://dart.dev/tools/diagnostic-messages#body_might_complete_normally",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "conflicting_constructor_and_static_member",
        "name": "Conflicting constructor and static member",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a named constructor and either a static method or static field have the same name. Both are accessed using the name of the class, so having the same name makes the reference ambiguous.\n @see https://dart.dev/tools/diagnostic-messages#conflicting_constructor_and_static_member",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "const_map_key_not_primitive_equality",
        "name": "Const map key not primitive equality",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the class of object used as a key in a constant map literal implements either the == operator, the getter hashCode, or both. The implementation of constant maps uses both the == operator and the hashCode getter, so any implementation other than the ones inherited from Object requires executing arbitrary code at compile time, which isn't supported.\n @see https://dart.dev/tools/diagnostic-messages#const_map_key_not_primitive_equality",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "dead_null_aware_expression",
        "name": "Dead null aware expression",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic in two cases.The first is when the left operand of an ?? operator can't be null. The right operand is only evaluated if the left operand has the value null, and because the left operand can't be null, the right operand is never evaluated.The second is when the left-hand side of an assignment using the ??= operator can't be null. The right-hand side is only evaluated if the left-hand side has the value null, and because the left-hand side can't be null, the right-hand side is never evaluated.\n @see https://dart.dev/tools/diagnostic-messages#dead_null_aware_expression",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "deprecated_new_in_comment_reference",
        "name": "Deprecated new in comment reference",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a comment reference (the name of a declaration enclosed in square brackets in a documentation comment) uses the keyword new to refer to a constructor. This form is deprecated.\n @see https://dart.dev/tools/diagnostic-messages#deprecated_new_in_comment_reference",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "duplicate_constructor",
        "name": "Duplicate constructor",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a class declares more than one unnamed constructor or when it declares more than one constructor with the same name.\n @see https://dart.dev/tools/diagnostic-messages#duplicate_constructor",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "duplicate_field_name",
        "name": "Duplicate field name",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when either a record literal or a record type annotation contains a field whose name is the same as a previously declared field in the same literal or type.\n @see https://dart.dev/tools/diagnostic-messages#duplicate_field_name",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "duplicate_ignore",
        "name": "Duplicate ignore",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a diagnostic name appears in an ignore comment, but the diagnostic is already being ignored, either because it's already included in the same ignore comment or because it appears in an ignore-in-file comment.\n @see https://dart.dev/tools/diagnostic-messages#duplicate_ignore",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "duplicate_pattern_field",
        "name": "Duplicate pattern field",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a record pattern matches the same field more than once, or when an object pattern matches the same getter more than once.\n @see https://dart.dev/tools/diagnostic-messages#duplicate_pattern_field",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "external_with_initializer",
        "name": "External with initializer",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a field or variable marked with the keyword external has an initializer, or when an external field is initialized in a constructor.\n @see https://dart.dev/tools/diagnostic-messages#external_with_initializer",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "field_initializer_redirecting_constructor",
        "name": "Field initializer redirecting constructor",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a redirecting constructor initializes a field in the object. This isn't allowed because the instance that has the field hasn't been created at the point at which it should be initialized.\n @see https://dart.dev/tools/diagnostic-messages#field_initializer_redirecting_constructor",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "illegal_concrete_enum_member",
        "name": "Illegal concrete enum member",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when either an enum declaration, a class that implements Enum, or a mixin with a superclass constraint of Enum, declares or inherits a concrete instance member named either index, hashCode, or ==.\n @see https://dart.dev/tools/diagnostic-messages#illegal_concrete_enum_member",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "illegal_enum_values",
        "name": "Illegal enum values",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when either a class that implements Enum or a mixin with a superclass constraint of Enum has an instance member named values.\n @see https://dart.dev/tools/diagnostic-messages#illegal_enum_values",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "implicit_super_initializer_missing_arguments",
        "name": "Implicit super initializer missing arguments",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a constructor implicitly invokes the unnamed constructor from the superclass, the unnamed constructor of the superclass has a required parameter, and there's no super parameter corresponding to the required parameter.\n @see https://dart.dev/tools/diagnostic-messages#implicit_super_initializer_missing_arguments",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "inconsistent_pattern_variable_logical_or",
        "name": "Inconsistent pattern variable logical or",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a pattern variable that is declared on all branches of a logical-or pattern doesn't have the same type on every branch. It is also produced when the variable has a different finality on different branches. A pattern variable declared on multiple branches of a logical-or pattern is required to have the same type and finality in each branch, so that the type and finality of the variable can be known in code that's guarded by the logical-or pattern.\n @see https://dart.dev/tools/diagnostic-messages#inconsistent_pattern_variable_logical_or",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_annotation",
        "name": "Invalid annotation",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an annotation is found that is using something that is neither a variable marked as const or the invocation of a const constructor.Getters can't be used as annotations.\n @see https://dart.dev/tools/diagnostic-messages#invalid_annotation",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_extension_argument_count",
        "name": "Invalid extension argument count",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an extension override doesn't have exactly one argument. The argument is the expression used to compute the value of this within the extension method, so there must be one argument.\n @see https://dart.dev/tools/diagnostic-messages#invalid_extension_argument_count",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_field_name",
        "name": "Invalid field name",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when either a record literal or a record type annotation has a field whose name is invalid. The name is invalid if it is:\n @see https://dart.dev/tools/diagnostic-messages#invalid_field_name",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_literal_annotation",
        "name": "Invalid literal annotation",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the literal annotation is applied to anything other than a const constructor.\n @see https://dart.dev/tools/diagnostic-messages#invalid_literal_annotation",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_non_virtual_annotation",
        "name": "Invalid non virtual annotation",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the nonVirtual annotation is found on a declaration other than a member of a class, mixin, or enum, or if the member isn't a concrete instance member.\n @see https://dart.dev/tools/diagnostic-messages#invalid_non_virtual_annotation",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_null_aware_operator",
        "name": "Invalid null aware operator",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a null-aware operator (?., ?.., ?[, ?..[, or ...?) is used on a receiver that's known to be non-nullable.\n @see https://dart.dev/tools/diagnostic-messages#invalid_null_aware_operator",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_pattern_variable_in_shared_case_scope",
        "name": "Invalid pattern variable in shared case scope",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when multiple case clauses in a switch statement share a body, and at least one of them declares a variable that is referenced in the shared statements, but the variable is either not declared in all of the case clauses or it is declared in inconsistent ways.If the variable isn't declared in all of the case clauses, then it won't have a value if one of the clauses that doesn't declare the variable is the one that matches and executes the body. This includes the situation where one of the case clauses is the default clause.If the variable is declared in inconsistent ways, either being final in some cases and not final in others or having a different type in different cases, then the semantics of what the type or finality of the variable should be are not defined.\n @see https://dart.dev/tools/diagnostic-messages#invalid_pattern_variable_in_shared_case_scope",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_return_type_for_catch_error",
        "name": "Invalid return type for catch error",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an invocation of Future.catchError has an argument whose return type isn't compatible with the type returned by the instance of Future. At runtime, the method catchError attempts to return the value from the callback as the result of the future, which results in another exception being thrown.\n @see https://dart.dev/tools/diagnostic-messages#invalid_return_type_for_catch_error",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_super_formal_parameter_location",
        "name": "Invalid super formal parameter location",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a super parameter is used anywhere other than a non-redirecting generative constructor.\n @see https://dart.dev/tools/diagnostic-messages#invalid_super_formal_parameter_location",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_type_argument_in_const_literal",
        "name": "Invalid type argument in const literal",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a type parameter is used as a type argument in a list, map, or set literal that is prefixed by const. This isn't allowed because the value of the type parameter (the actual type that will be used at runtime) can't be known at compile time.\n @see https://dart.dev/tools/diagnostic-messages#invalid_type_argument_in_const_literal",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_visible_outside_template_annotation",
        "name": "Invalid visible outside template annotation",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the @visibleOutsideTemplate annotation is used incorrectly. This annotation is only meant to annotate members of a class, enum, or mixin that has the @visibleForTemplate annotation, to opt those members out of the visibility restrictions that @visibleForTemplate imposes.\n @see https://dart.dev/tools/diagnostic-messages#invalid_visible_outside_template_annotation",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "invocation_of_non_function_expression",
        "name": "Invocation of non function expression",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a function invocation is found, but the name being referenced isn't the name of a function, or when the expression computing the function doesn't compute a function.\n @see https://dart.dev/tools/diagnostic-messages#invocation_of_non_function_expression",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "missing_default_value_for_parameter",
        "name": "Missing default value for parameter",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an optional parameter, whether positional or named, has a potentially non-nullable type and doesn't specify a default value. Optional parameters that have no explicit default value have an implicit default value of null. If the type of the parameter doesn't allow the parameter to have a value of null, then the implicit default value isn't valid.\n @see https://dart.dev/tools/diagnostic-messages#missing_default_value_for_parameter",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "non_constant_map_element",
        "name": "Non constant map element",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an if element or a spread element in a constant map isn't a constant element.\n @see https://dart.dev/tools/diagnostic-messages#non_constant_map_element",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "not_assigned_potentially_non_nullable_local_variable",
        "name": "Not assigned potentially non nullable local variable",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a local variable is referenced and has all these characteristics:\n @see https://dart.dev/tools/diagnostic-messages#not_assigned_potentially_non_nullable_local_variable",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "not_initialized_non_nullable_instance_field",
        "name": "Not initialized non nullable instance field",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a field is declared and has all these characteristics:\n @see https://dart.dev/tools/diagnostic-messages#not_initialized_non_nullable_instance_field",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "not_initialized_non_nullable_variable",
        "name": "Not initialized non nullable variable",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a static field or top-level variable has a type that's non-nullable and doesn't have an initializer. Fields and variables that don't have an initializer are normally initialized to null, but the type of the field or variable doesn't allow it to be set to null, so an explicit initializer must be provided.\n @see https://dart.dev/tools/diagnostic-messages#not_initialized_non_nullable_variable",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "recursive_constructor_redirect",
        "name": "Recursive constructor redirect",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a constructor redirects to itself, either directly or indirectly, creating an infinite loop.\n @see https://dart.dev/tools/diagnostic-messages#recursive_constructor_redirect",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "redirect_to_invalid_function_type",
        "name": "Redirect to invalid function type",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a factory constructor attempts to redirect to another constructor, but the two have incompatible parameters. The parameters are compatible if all of the parameters of the redirecting constructor can be passed to the other constructor and if the other constructor doesn't require any parameters that aren't declared by the redirecting constructor.\n @see https://dart.dev/tools/diagnostic-messages#redirect_to_invalid_function_type",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "return_in_generator",
        "name": "Return in generator",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a generator function (one whose body is marked with either async* or sync*) uses either a return statement to return a value or implicitly returns a value because of using =>. In any of these cases, they should use yield instead of return.\n @see https://dart.dev/tools/diagnostic-messages#return_in_generator",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "subtype_of_disallowed_type",
        "name": "Subtype of disallowed type",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when one of the restricted classes is used in either an extends, implements, with, or on clause. The classes bool, double, FutureOr, int, Null, num, and String are all restricted in this way, to allow for more efficient implementations.\n @see https://dart.dev/tools/diagnostic-messages#subtype_of_disallowed_type",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "super_formal_parameter_without_associated_positional",
        "name": "Super formal parameter without associated positional",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when there's a positional super parameter in a constructor and the implicitly or explicitly invoked super constructor doesn't have a positional parameter at the corresponding index.Positional super parameters are associated with positional parameters in the super constructor by their index. That is, the first super parameter is associated with the first positional parameter in the super constructor, the second with the second, and so on.\n @see https://dart.dev/tools/diagnostic-messages#super_formal_parameter_without_associated_positional",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "type_check_with_null",
        "name": "Type check with null",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when there's a type check (using the as operator) where the type is Null. There's only one value whose type is Null, so the code is both more readable and more performant when it tests for null explicitly.\n @see https://dart.dev/tools/diagnostic-messages#type_check_with_null",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "type_parameter_supertype_of_its_bound",
        "name": "Type parameter supertype of its bound",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the bound of a type parameter (the type following the extends keyword) is either directly or indirectly the type parameter itself. Stating that the type parameter must be the same as itself or a subtype of itself or a subtype of itself isn't helpful because it will always be the same as itself.\n @see https://dart.dev/tools/diagnostic-messages#type_parameter_supertype_of_its_bound",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_constructor_in_initializer",
        "name": "Undefined constructor in initializer",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a superclass constructor is invoked in the initializer list of a constructor, but the superclass doesn't define the constructor being invoked.\n @see https://dart.dev/tools/diagnostic-messages#undefined_constructor_in_initializer",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_enum_constructor",
        "name": "Undefined enum constructor",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the constructor invoked to initialize an enum value doesn't exist.\n @see https://dart.dev/tools/diagnostic-messages#undefined_enum_constructor",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_extension_getter",
        "name": "Undefined extension getter",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an extension override is used to invoke a getter, but the getter isn't defined by the specified extension. The analyzer also produces this diagnostic when a static getter is referenced but isn't defined by the specified extension.\n @see https://dart.dev/tools/diagnostic-messages#undefined_extension_getter",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_extension_method",
        "name": "Undefined extension method",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an extension override is used to invoke a method, but the method isn't defined by the specified extension. The analyzer also produces this diagnostic when a static method is referenced but isn't defined by the specified extension.\n @see https://dart.dev/tools/diagnostic-messages#undefined_extension_method",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_extension_setter",
        "name": "Undefined extension setter",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an extension override is used to invoke a setter, but the setter isn't defined by the specified extension. The analyzer also produces this diagnostic when a static setter is referenced but isn't defined by the specified extension.\n @see https://dart.dev/tools/diagnostic-messages#undefined_extension_setter",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_super_member",
        "name": "Undefined super member",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an inherited member (method, getter, setter, or operator) is referenced using super, but there's no member with that name in the superclass chain.\n @see https://dart.dev/tools/diagnostic-messages#undefined_super_member",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "unnecessary_final",
        "name": "Unnecessary final",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when either a field initializing parameter or a super parameter in a constructor has the keyword final. In both cases the keyword is unnecessary because the parameter is implicitly final.\n @see https://dart.dev/tools/diagnostic-messages#unnecessary_final",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "unnecessary_null_comparison",
        "name": "Unnecessary null comparison",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when it finds an equality comparison (either == or !=) with one operand of null and the other operand can't be null. Such comparisons are always either true or false, so they serve no purpose.\n @see https://dart.dev/tools/diagnostic-messages#unnecessary_null_comparison",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "wrong_number_of_parameters_for_setter",
        "name": "Wrong number of parameters for setter",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a setter is found that doesn't declare exactly one required positional parameter.\n @see https://dart.dev/tools/diagnostic-messages#wrong_number_of_parameters_for_setter",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "wrong_number_of_type_arguments",
        "name": "Wrong number of type arguments",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a type that has type parameters is used and type arguments are provided, but the number of type arguments isn't the same as the number of type parameters.The analyzer also produces this diagnostic when a constructor is invoked and the number of type arguments doesn't match the number of type parameters declared for the class.\n @see https://dart.dev/tools/diagnostic-messages#wrong_number_of_type_arguments",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "yield_in_non_generator",
        "name": "Yield in non generator",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a yield or yield* statement appears in a function whose body isn't marked with one of the async* or sync* modifiers.\n @see https://dart.dev/tools/diagnostic-messages#yield_in_non_generator",
        "type": "BUG",
        "debt": "5min",
        "active": true
    }
]