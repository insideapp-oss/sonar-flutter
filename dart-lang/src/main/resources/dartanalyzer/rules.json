[
    {
        "key": "always_use_package_imports",
        "name": "Always use package imports",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     avoid relative imports for files in \n    <CODE>lib/</CODE>\n    .\n  </P>\n  <P>\n    When mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways. One way to avoid\nthat is to ensure you consistently use absolute imports for files within the\n\n    <CODE>lib/</CODE>\n     directory.\n  </P>\n  <P>This is the opposite of 'prefer_relative_imports'.</P>\n  <P>\n    You can also use 'avoid_relative_lib_imports' to disallow relative imports of\nfiles within \n    <CODE>lib/</CODE>\n     directory outside of it (for example \n    <CODE>test/</CODE>\n    ).\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'baz.dart';\n\nimport 'src/bag.dart'\n\nimport '../lib/baz.dart';\n\n...\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:foo/bar.dart';\n\nimport 'package:foo/baz.dart';\n\nimport 'package:foo/src/baz.dart';\n...\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"prefer_relative_imports.html\">prefer_relative_imports</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_dynamic_calls",
        "name": "Avoid dynamic calls",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     avoid method calls or accessing properties on an object that is either\nexplicitly or implicitly statically typed \"dynamic\". Dynamic calls are treated\nslightly different in every runtime environment and compiler, but most\nproduction modes (and even some development modes) have both compile size and\nruntime performance penalties associated with dynamic calls.\n  </P>\n  <P>Additionally, targets typed \"dynamic\" disables most static analysis, meaning it\nis easier to lead to a runtime \"NoSuchMethodError\" or \"NullError\" than properly\nstatically typed Dart code.</P>\n  <P>There is an exception to methods and properties that exist on \"Object?\":</P>\n  <UL>\n    <LI>a.hashCode</LI>\n    <LI>a.runtimeType</LI>\n    <LI>a.noSuchMethod(someInvocation)</LI>\n    <LI>a.toString()</LI>\n  </UL>\n  <P>\n    ... these members are dynamically dispatched in the web-based runtimes, but not\nin the VM-based ones. Additionally, they are so common that it would be very\npunishing to disallow \n    <CODE>any.toString()</CODE>\n     or \n    <CODE>any == true</CODE>\n    , for example.\n  </P>\n  <P>Note that despite \"Function\" being a type, the semantics are close to identical\nto \"dynamic\", and calls to an object that is typed \"Function\" will also trigger\nthis lint.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void explicitDynamicType(dynamic object) {\n  print(object.foo());\n}\n\nvoid implicitDynamicType(object) {\n  print(object.foo());\n}\n\nabstract class SomeWrapper {\n  T doSomething&lt;T&gt;();\n}\n\nvoid inferredDynamicType(SomeWrapper wrapper) {\n  var object = wrapper.doSomething();\n  print(object.foo());\n}\n\nvoid callDynamic(dynamic function) {\n  function();\n}\n\nvoid functionType(Function function) {\n  function();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void explicitType(Fooable object) {\n  object.foo();\n}\n\nvoid castedType(dynamic object) {\n  (object as Fooable).foo();\n}\n\nabstract class SomeWrapper {\n  T doSomething&lt;T&gt;();\n}\n\nvoid inferredType(SomeWrapper wrapper) {\n  var object = wrapper.doSomething&lt;Fooable&gt;();\n  object.foo();\n}\n\nvoid functionTypeWithParameters(Function() function) {\n  function();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_empty_else",
        "name": "Avoid empty else",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     empty else statements.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (x &gt; y)\n  print(\"1\");\nelse ;\n  print(\"2\");\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_print",
        "name": "Avoid print",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     avoid \n    <CODE>print</CODE>\n     calls in production code.\n  </P>\n  <P>\n    For production code, consider using a logging framework.\nIf you are using Flutter, you can use \n    <CODE>debugPrint</CODE>\n    or surround \n    <CODE>print</CODE>\n     calls with a check for \n    <CODE>kDebugMode</CODE>\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f(int x) {\n  print('debug: $x');\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f(int x) {\n  debugPrint('debug: $x');\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f(int x) {\n  log('log: $x');\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f(int x) {\n  if (kDebugMode) {\n      print('debug: $x');\n  }\n  ...\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_relative_lib_imports",
        "name": "Avoid relative lib imports",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     avoid relative imports for files in \n    <CODE>lib/</CODE>\n    .\n  </P>\n  <P>\n    When mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways.  An easy way to avoid\nthat is to ensure you have no relative imports that include \n    <CODE>lib/</CODE>\n     in their\npaths.\n  </P>\n  <P>\n    You can also use 'always_use_package_imports' to disallow relative imports\nbetween files within \n    <CODE>lib/</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:foo/bar.dart';\n\nimport '../lib/baz.dart';\n\n...\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:foo/bar.dart';\n\nimport 'baz.dart';\n\n...\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "avoid_slow_async_io",
        "name": "Avoid slow async io",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using the following asynchronous file I/O methods because they are\nmuch slower than their synchronous counterparts.\n  </P>\n  <UL>\n    <LI>\n      <CODE>Directory.exists</CODE>\n    </LI>\n    <LI>\n      <CODE>Directory.stat</CODE>\n    </LI>\n    <LI>\n      <CODE>File.lastModified</CODE>\n    </LI>\n    <LI>\n      <CODE>File.exists</CODE>\n    </LI>\n    <LI>\n      <CODE>File.stat</CODE>\n    </LI>\n    <LI>\n      <CODE>FileSystemEntity.isDirectory</CODE>\n    </LI>\n    <LI>\n      <CODE>FileSystemEntity.isFile</CODE>\n    </LI>\n    <LI>\n      <CODE>FileSystemEntity.isLink</CODE>\n    </LI>\n    <LI>\n      <CODE>FileSystemEntity.type</CODE>\n    </LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'dart:io';\n\nFuture&lt;Null&gt; someFunction() async {\n  var file = File('/path/to/my/file');\n  var now = DateTime.now();\n  if ((await file.lastModified()).isBefore(now)) print('before'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'dart:io';\n\nFuture&lt;Null&gt; someFunction() async {\n  var file = File('/path/to/my/file');\n  var now = DateTime.now();\n  if (file.lastModifiedSync().isBefore(now)) print('before'); // OK\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_type_to_string",
        "name": "Avoid type to string",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     avoid calls to \n    <TYPE>.toString() in production code, since it does not\ncontractually return the user-defined name of the Type (or underlying class).\nDevelopment-mode compilers where code size is not a concern use the full name,\nbut release-mode compilers often choose to minify these symbols.</TYPE>\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bar(Object other) {\n  if (other.runtimeType.toString() == 'Bar') {\n    doThing();\n  }\n}\n\nObject baz(Thing myThing) {\n  return getThingFromDatabase(key: myThing.runtimeType.toString());\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bar(Object other) {\n  if (other is Bar) {\n    doThing();\n  }\n}\n\nclass Thing {\n  String get thingTypeKey =&gt; ...\n}\n\nObject baz(Thing myThing) {\n  return getThingFromDatabase(key: myThing.thingTypeKey);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_types_as_parameter_names",
        "name": "Avoid types as parameter names",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using a parameter name that is the same as an existing type.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">m(f(int));\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">m(f(int v));\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_web_libraries_in_flutter",
        "name": "Avoid web libraries in flutter",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using web libraries, \n    <CODE>dart:html</CODE>\n    , \n    <CODE>dart:js</CODE>\n     and\n\n    <CODE>dart:js_util</CODE>\n     in Flutter packages that are not web plugins. These libraries are\nnot supported outside a web context; functionality that depends on them will\nfail at runtime in Flutter mobile, and their use is generally discouraged in\nFlutter web.\n  </P>\n  <P>\n    Web library access \n    <EM>is</EM>\n     allowed in:\n  </P>\n  <UL>\n    <LI>\n      plugin packages that declare \n      <CODE>web</CODE>\n       as a supported context\n    </LI>\n  </UL>\n  <P>\n    otherwise, imports of \n    <CODE>dart:html</CODE>\n    , \n    <CODE>dart:js</CODE>\n     and  \n    <CODE>dart:js_util</CODE>\n     are disallowed.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "cancel_subscriptions",
        "name": "Cancel subscriptions",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     invoke \n    <CODE>cancel</CODE>\n     on instances of \n    <CODE>dart.async.StreamSubscription</CODE>\n    .\n  </P>\n  <P>Cancelling instances of StreamSubscription prevents memory leaks and unexpected\nbehavior.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  StreamSubscription _subscriptionA; // LINT\n  void init(Stream stream) {\n    _subscriptionA = stream.listen((_) {});\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction() {\n  StreamSubscription _subscriptionF; // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class B {\n  StreamSubscription _subscriptionB; // OK\n  void init(Stream stream) {\n    _subscriptionB = stream.listen((_) {});\n  }\n\n  void dispose(filename) {\n    _subscriptionB.cancel();\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunctionOK() {\n  StreamSubscription _subscriptionB; // OK\n  _subscriptionB.cancel();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "close_sinks",
        "name": "Close sinks",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     invoke \n    <CODE>close</CODE>\n     on instances of \n    <CODE>dart.core.Sink</CODE>\n    .\n  </P>\n  <P>Closing instances of Sink prevents memory leaks and unexpected behavior.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  IOSink _sinkA;\n  void init(filename) {\n    _sinkA = File(filename).openWrite(); // LINT\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction() {\n  IOSink _sinkF; // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class B {\n  IOSink _sinkB;\n  void init(filename) {\n    _sinkB = File(filename).openWrite(); // OK\n  }\n\n  void dispose(filename) {\n    _sinkB.close();\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunctionOK() {\n  IOSink _sinkFOK; // OK\n  _sinkFOK.close();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "collection_methods_unrelated_type",
        "name": "Collection methods unrelated type",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     invoke certain collection method with an argument with an unrelated\ntype.\n  </P>\n  <P>\n    Doing this will invoke \n    <CODE>==</CODE>\n     on the collection's elements and most likely will\nreturn \n    <CODE>false</CODE>\n    .\n  </P>\n  <P>An argument passed to a collection method should relate to the collection type\nas follows:</P>\n  <UL>\n    <LI>\n      an argument to \n      <CODE>Iterable&lt;E&gt;.contains</CODE>\n       should be related to \n      <CODE>E</CODE>\n    </LI>\n    <LI>\n      an argument to \n      <CODE>List&lt;E&gt;.remove</CODE>\n       should be related to \n      <CODE>E</CODE>\n    </LI>\n    <LI>\n      an argument to \n      <CODE>Map&lt;K, V&gt;.containsKey</CODE>\n       should be related to \n      <CODE>K</CODE>\n    </LI>\n    <LI>\n      an argument to \n      <CODE>Map&lt;K, V&gt;.containsValue</CODE>\n       should be related to \n      <CODE>V</CODE>\n    </LI>\n    <LI>\n      an argument to \n      <CODE>Map&lt;K, V&gt;.remove</CODE>\n       should be related to \n      <CODE>K</CODE>\n    </LI>\n    <LI>\n      an argument to \n      <CODE>Map&lt;K, V&gt;.[]</CODE>\n       should be related to \n      <CODE>K</CODE>\n    </LI>\n    <LI>\n      an argument to \n      <CODE>Queue&lt;E&gt;.remove</CODE>\n       should be related to \n      <CODE>E</CODE>\n    </LI>\n    <LI>\n      an argument to \n      <CODE>Set&lt;E&gt;.lookup</CODE>\n       should be related to \n      <CODE>E</CODE>\n    </LI>\n    <LI>\n      an argument to \n      <CODE>Set&lt;E&gt;.remove</CODE>\n       should be related to \n      <CODE>E</CODE>\n    </LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction() {\n  var list = &lt;int&gt;[];\n  if (list.contains('1')) print('someFunction'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction() {\n  var set = &lt;int&gt;{};\n  set.remove('1'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction() {\n  var list = &lt;int&gt;[];\n  if (list.contains(1)) print('someFunction'); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction() {\n  var set = &lt;int&gt;{};\n  set.remove(1); // OK\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "comment_references",
        "name": "Comment references",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     reference only in scope identifiers in doc comments.\n  </P>\n  <P>\n    If you surround things like variable, method, or type names in square brackets,\nthen \n    <A href=\"https://dart.dev/tools/dart-doc\">\n      <CODE>dart doc</CODE>\n    </A>\n     will look\nup the name and link to its docs.  For this all to work, ensure that all\nidentifiers in docs wrapped in brackets are in scope.\n  </P>\n  <P>\n    For example, assuming \n    <CODE>outOfScopeId</CODE>\n     is out of scope:\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">/// Return true if [value] is larger than [outOfScopeId].\nbool isOutOfRange(int value) { ... }\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">/// Return the larger of [a] or [b].\nint max_int(int a, int b) { ... }\n</CODE>\n  </PRE>\n  <P>\n    Note that the square bracket comment format is designed to allow\ncomments to refer to declarations using a fairly natural format\nbut does not allow \n    <EM>arbitrary expressions</EM>\n    .  In particular, code\nreferences within square brackets can consist of either\n  </P>\n  <UL>\n    <LI>a single identifier where the identifier is any identifier in scope for the comment (see the spec for what is in scope in doc comments),</LI>\n    <LI>two identifiers separated by a period where the first identifier is the name of a class that is in scope and the second is the name of a member declared in the class,</LI>\n    <LI>a single identifier followed by a pair of parentheses where the identifier is the name of a class that is in scope (used to refer to the unnamed constructor for the class), or</LI>\n    <LI>two identifiers separated by a period and followed by a pair of parentheses where the first identifier is the name of a class that is in scope and the second is the name of a named constructor (not strictly necessary, but allowed for consistency).</LI>\n  </UL>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "control_flow_in_finally",
        "name": "Control flow in finally",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     control flow leaving finally blocks.\n  </P>\n  <P>Using control flow in finally blocks will inevitably cause unexpected behavior\nthat is hard to debug.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class BadReturn {\n  double nonCompliantMethod() {\n    try {\n      return 1 / 0;\n    } catch (e) {\n      print(e);\n    } finally {\n      return 1.0; // LINT\n    }\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class BadContinue {\n  double nonCompliantMethod() {\n    for (var o in [1, 2]) {\n      try {\n        print(o / 0);\n      } catch (e) {\n        print(e);\n      } finally {\n        continue; // LINT\n      }\n    }\n    return 1.0;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class BadBreak {\n  double nonCompliantMethod() {\n    for (var o in [1, 2]) {\n      try {\n        print(o / 0);\n      } catch (e) {\n        print(e);\n      } finally {\n        break; // LINT\n      }\n    }\n    return 1.0;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Ok {\n  double compliantMethod() {\n    var i = 5;\n    try {\n      i = 1 / 0;\n    } catch (e) {\n      print(e); // OK\n    }\n    return i;\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "deprecated_member_use_from_same_package",
        "name": "Deprecated member use from same package",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Elements which are annotated with \n    <CODE>@deprecated</CODE>\n     should not be referenced from\nwithin the package in which they are declared.\n  </P>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using deprecated elements.\n  </P>\n  <P>...</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// Declared in one library:\nclass Foo {\n  @Deprecated(\"Use 'm2' instead\")\n  void m1() {}\n\n  void m2({\n      @Deprecated('This is an old parameter') int? p,\n  })\n}\n\n@Deprecated('Do not use')\nint x = 0;\n\n// In the same or another library, but within the same package:\nvoid m(Foo foo) {\n  foo.m1();\n  foo.m2(p: 7);\n  x = 1;\n}\n</CODE>\n  </PRE>\n  <P>\n    Deprecated elements can be used from within \n    <EM>other</EM>\n     deprecated elements, in\norder to allow for the deprecation of a collection of APIs together as one unit.\n  </P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// Declared in one library:\nclass Foo {\n  @Deprecated(\"Use 'm2' instead\")\n  void m1() {}\n\n  void m2({\n      @Deprecated('This is an old parameter') int? p,\n  })\n}\n\n@Deprecated('Do not use')\nint x = 0;\n\n// In the same or another library, but within the same package:\n@Deprecated('Do not use')\nvoid m(Foo foo) {\n  foo.m1();\n  foo.m2(p: 7);\n  x = 1;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "diagnostic_describe_all_properties",
        "name": "Diagnostic describe all properties",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     reference all public properties in \n    <CODE>debug</CODE>\n     method implementations.\n  </P>\n  <P>\n    Implementers of \n    <CODE>Diagnosticable</CODE>\n     should reference all public properties in\na \n    <CODE>debugFillProperties(...)</CODE>\n     or \n    <CODE>debugDescribeChildren(...)</CODE>\n     method\nimplementation to improve debuggability at runtime.\n  </P>\n  <P>Public properties are defined as fields and getters that are</P>\n  <UL>\n    <LI>\n      not package-private (e.g., prefixed with \n      <CODE>_</CODE>\n      )\n    </LI>\n    <LI>\n      not \n      <CODE>static</CODE>\n       or overriding\n    </LI>\n    <LI>\n      not themselves \n      <CODE>Widget</CODE>\n      s or collections of \n      <CODE>Widget</CODE>\n      s\n    </LI>\n  </UL>\n  <P>\n    In addition, the \"debug\" prefix is treated specially for properties in Flutter.\nFor the purposes of diagnostics, a property \n    <CODE>foo</CODE>\n     and a prefixed property\n\n    <CODE>debugFoo</CODE>\n     are treated as effectively describing the same property and it is\nsufficient to refer to one or the other.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Absorber extends Widget {\n  bool get absorbing =&gt; _absorbing;\n  bool _absorbing;\n  bool get ignoringSemantics =&gt; _ignoringSemantics;\n  bool _ignoringSemantics;\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty&lt;bool&gt;('absorbing', absorbing));\n    // Missing reference to ignoringSemantics\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Absorber extends Widget {\n  bool get absorbing =&gt; _absorbing;\n  bool _absorbing;\n  bool get ignoringSemantics =&gt; _ignoringSemantics;\n  bool _ignoringSemantics;\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty&lt;bool&gt;('absorbing', absorbing));\n    properties.add(DiagnosticsProperty&lt;bool&gt;('ignoringSemantics', ignoringSemantics));\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "discarded_futures",
        "name": "Discarded futures",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    Making asynchronous calls in non-\n    <CODE>async</CODE>\n     functions is usually the sign of a\nprogramming error.  In general these functions should be marked \n    <CODE>async</CODE>\n     and such\nfutures should likely be awaited (as enforced by \n    <CODE>unawaited_futures</CODE>\n    ).\n  </P>\n  <P>\n    <STRONG>DON'T</STRONG>\n     invoke asynchronous functions in non-\n    <CODE>async</CODE>\n     blocks.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void recreateDir(String path) {\n  deleteDir(path);\n  createDir(path);\n}\n\nFuture&lt;void&gt; deleteDir(String path) async {}\n\nFuture&lt;void&gt; createDir(String path) async {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Future&lt;void&gt; recreateDir(String path) async {\n  await deleteDir(path);\n  await createDir(path);\n}\n\nFuture&lt;void&gt; deleteDir(String path) async {}\n\nFuture&lt;void&gt; createDir(String path) async {}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "empty_statements",
        "name": "Empty statements",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     empty statements.\n  </P>\n  <P>Empty statements almost always indicate a bug.</P>\n  <P>For example,</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (complicated.expression.foo());\n  bar();\n</CODE>\n  </PRE>\n  <P>\n    Formatted with \n    <CODE>dart format</CODE>\n     the bug becomes obvious:\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (complicated.expression.foo()) ;\nbar();\n\n</CODE>\n  </PRE>\n  <P>Better to avoid the empty statement altogether.</P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (complicated.expression.foo())\n  bar();\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "hash_and_equals",
        "name": "Hash and equals",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     override \n    <CODE>hashCode</CODE>\n     if overriding \n    <CODE>==</CODE>\n     and prefer overriding \n    <CODE>==</CODE>\n     if\noverriding \n    <CODE>hashCode</CODE>\n    .\n  </P>\n  <P>\n    Every object in Dart has a \n    <CODE>hashCode</CODE>\n    .  Both the \n    <CODE>==</CODE>\n     operator and the\n\n    <CODE>hashCode</CODE>\n     property of objects must be consistent in order for a common hash\nmap implementation to function properly.  Thus, when overriding \n    <CODE>==</CODE>\n    , the\n\n    <CODE>hashCode</CODE>\n     should also be overridden to maintain consistency. Similarly, if\n\n    <CODE>hashCode</CODE>\n     is overridden, \n    <CODE>==</CODE>\n     should be also.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Bad {\n  final int value;\n  Bad(this.value);\n\n  @override\n  bool operator ==(Object other) =&gt; other is Bad &amp;&amp; other.value == value;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Better {\n  final int value;\n  Better(this.value);\n\n  @override\n  bool operator ==(Object other) =&gt;\n      other is Better &amp;&amp;\n      other.runtimeType == runtimeType &amp;&amp;\n      other.value == value;\n\n  @override\n  int get hashCode =&gt; value.hashCode;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "implicit_reopen",
        "name": "Implicit reopen",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    Using an \n    <CODE>interface</CODE>\n    , \n    <CODE>base</CODE>\n    , \n    <CODE>final</CODE>\n    , or \n    <CODE>sealed</CODE>\n     modifier on a class,\nor a \n    <CODE>base</CODE>\n     modifier on a mixin,\nauthors can control whether classes and mixins allow being implemented,\nextended, and/or mixed in from outside of the library where they're defined.\nIn some cases, it's possible for an author to inadvertently relax these controls\nand implicitly \"reopen\" a class. (A similar reopening cannot occur with a mixin.)\n  </P>\n  <P>\n    This lint guards against unintentionally reopening a class by requiring such\ncases to be made explicit with the\n\n    <A href=\"https://pub.dev/documentation/meta/latest/meta/reopen-constant.html\">\n      <CODE>@reopen</CODE>\n    </A>\n    annotation in \n    <CODE>package:meta</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">interface class I {}\n\nclass C extends I {} // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">interface class I {}\n\nfinal class C extends I {}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">interface class I {}\n\nfinal class C extends I {}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:meta/meta.dart';\n\ninterface class I {}\n\n@reopen\nclass C extends I {}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "invalid_case_patterns",
        "name": "Invalid case patterns",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>Some case expressions that are valid in Dart 2.19 and below will become an error\nor have changed semantics when a library is upgraded to 3.0. This lint flags\nthose expressions in order to ease migration to Dart 3.0.</P>\n  <P>Some valid switch cases in 2.19 will become compile errors in Dart 3.0:</P>\n  <UL>\n    <LI>Set literals</LI>\n    <LI>Parenthesized expressions</LI>\n    <LI>\n      Calls to \n      <CODE>identical()</CODE>\n      .\n    </LI>\n    <LI>\n      Unary operator expressions \n      <CODE>!</CODE>\n      , \n      <CODE>-</CODE>\n      , or \n      <CODE>~</CODE>\n       (except for \n      <CODE>-</CODE>\n       before an integer\nliteral, which is a valid pattern and is fine)\n    </LI>\n    <LI>\n      Binary operator expressions \n      <CODE>!=</CODE>\n      , \n      <CODE>==</CODE>\n      , \n      <CODE>&amp;</CODE>\n      , \n      <CODE>|</CODE>\n      , \n      <CODE>^</CODE>\n      , \n      <CODE>~/</CODE>\n      , \n      <CODE>&gt;&gt;</CODE>\n      , \n      <CODE>&gt;&gt;&gt;</CODE>\n      ,\n\n      <CODE>&lt;&lt;</CODE>\n      , \n      <CODE>+</CODE>\n      , \n      <CODE>-</CODE>\n      , \n      <CODE>*</CODE>\n      , \n      <CODE>/</CODE>\n      , \n      <CODE>%</CODE>\n      , \n      <CODE>&lt;</CODE>\n      , \n      <CODE>&lt;=</CODE>\n      , \n      <CODE>&gt;</CODE>\n      , \n      <CODE>&gt;=</CODE>\n      , \n      <CODE>??</CODE>\n      .\n    </LI>\n    <LI>\n      Conditional operator \n      <CODE>?:</CODE>\n    </LI>\n    <LI>\n      <CODE>.length</CODE>\n       calls on strings\n    </LI>\n    <LI>\n      <CODE>is</CODE>\n       and \n      <CODE>is!</CODE>\n       expressions\n    </LI>\n  </UL>\n  <P>Examples of all of them:</P>\n  <PRE>\n<CODE class=\"language-dart\">switch (obj) {\n  case {1}: // Set literal.\n  case (1): // Parenthesized expression.\n  case identical(1, 2): // `identical()` call.\n  case -pi: // Unary operator.\n  case 1 + 2: // Binary operator.\n  case true ? 1 : 2: // Conditional operator.\n  case 'hi'.length: // .length call.\n  case i is int: // is expression.\n}\n</CODE>\n  </PRE>\n  <P>Some valid switch cases in 2.19 are also syntactically valid patterns, but the\npattern matching behavior may be different from the current constant equality\nbehavior. They are:</P>\n  <P>\n    <STRONG>List and map literals.</STRONG>\n     A list or map literal can appear as a constant in a\ncase:\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">switch (obj) {\n  case [1, 2]: ...\n  case {'k': 'v'}: ...\n}\n</CODE>\n  </PRE>\n  <P>Currently, the case will only match if the incoming value has the same identity\nas the constant. So:</P>\n  <PRE>\n<CODE class=\"language-dart\">test(List&lt;int&gt; list) {\n  switch (list) {\n    case [1, 2]: print('Matched'); break;\n    default: print('Did not match'); break;\n  }\n}\n\nmain() {\n  test(const [1, 2]); // Prints \"Matched\".\n  test([1, 2]); // Prints \"Did not match\".\n}\n</CODE>\n  </PRE>\n  <P>With patterns, a list or map literal becomes a list or map pattern. The pattern\ndestructures the incoming object and matches if the subpatterns all match. In\nother words, list and map pattern match using something more like deep equality.</P>\n  <P>With Dart 3.0, the above program prints \"Matched\" twice.</P>\n  <P>\n    <STRONG>Constant constructor calls.</STRONG>\n     Similar to collections, you can construct a\nconstant instance of a class in a case:\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  final int x;\n  final int y;\n  const Point({this.x, this.y});\n}\n\ntest(Point p) {\n  switch (p) {\n    case Point(x: 1, y: 2): print('Matched'); break;\n    default: print('Did not match'); break;\n  }\n}\n\nmain() {\n  test(const Point(1, 2)); // Prints \"Matched\".\n  test(Point(1, 2)); // Prints \"Did not match\".\n}\n</CODE>\n  </PRE>\n  <P>\n    Again, like collections, the case currently only matches if the incoming value\nhas the same identity. With patterns, the \n    <CODE>Point(...)</CODE>\n     syntax becomes an object\npattern that destructures the incoming point, calls the \n    <CODE>x</CODE>\n     and \n    <CODE>y</CODE>\n     getters on\nit and then matches the results of those against the corresponding subpatterns.\n  </P>\n  <P>In this example, it will print \"Matched\" twice.</P>\n  <P>Note that object patterns only support named fields. So any constant constructor\nin a case today that has positional arguments will become a compile-time error\nwhen parsed as a pattern. A constant constructor call with no arguments is a\nvalid object pattern and only does a type test:</P>\n  <PRE>\n<CODE class=\"language-dart\">class Thing {\n  const Thing();\n}\n\ntest(Thing t) {\n  switch (t) {\n    case Thing(): print('Matched'); break;\n    default: print('Did not match'); break;\n  }\n}\n\nmain() {\n  test(const Thing()); // Prints \"Matched\".\n  test(Thing()); // Prints \"Did not match\".\n}\n</CODE>\n  </PRE>\n  <P>When interpreted as a pattern, this prints \"Matched\" twice.</P>\n  <P>\n    <STRONG>Wildcards.</STRONG>\n     Today, you can have a constant named \n    <CODE>_</CODE>\n    :\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">test(int n) {\n  const _ = 3;\n  switch (n) {\n    case _: print('Matched'); break;\n    default: print('Did not match'); break;\n  }\n}\n\nmain() {\n  test(3); // Prints \"Matched\".\n  test(5); // Prints \"Did not match\".\n}\n</CODE>\n  </PRE>\n  <P>\n    With patterns, the identifier \n    <CODE>_</CODE>\n     is treated as a pattern that matches all\nvalues, so this prints \"Matched\" twice.\n  </P>\n  <P>\n    <STRONG>Logic operators.</STRONG>\n     The logic operators \n    <CODE>&amp;&amp;</CODE>\n     and \n    <CODE>||</CODE>\n     are valid constant\nexpressions and also valid patterns. As a constant expression, they simply\nevaluate the expression to a boolean and match if the incoming value is equal to\nthat boolean value. So:\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">test(bool b) {\n  switch (b) {\n    case true &amp;&amp; false: print('Matched'); break;\n    default: print('Did not match'); break;\n  }\n}\n\nmain() {\n  test(false); // Prints \"Matched\".\n  test(true); // Prints \"Did not match\".\n}\n</CODE>\n  </PRE>\n  <P>With Dart 3.0, these become patterns. The above example prints \"Did not match\"\ntwice because no boolean value can be both true and false.</P>\n  <P>Many of invalid cases can be mechanically changed to something that is valid\nboth in Dart today and valid and means the same in Dart 3.0.</P>\n  <P>\n    <STRONG>Parenthesized expressions:</STRONG>\n     Provided the inner expression is one that's not\nbroken in Dart 3.0, just discard the parentheses.\n  </P>\n  <P>\n    <STRONG>List literals, map literals, set literals, and constant constructor calls:</STRONG>\n    Put \n    <CODE>const</CODE>\n     before the literal or call. This turns it into a constant pattern\nwhich preserves the current behavior:\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">case [1, 2]:\ncase {'k': 'v'}:\ncase {1, 2}:\ncase Point(1, 2):\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">case const [1, 2]:\ncase const {'k': 'v'}:\ncase const {1, 2}:\ncase const Point(1, 2):\n</CODE>\n  </PRE>\n  <UL>\n    <LI>\n      <P>\n        <STRONG>Wildcards:</STRONG>\n         Rename the constant from \n        <CODE>_</CODE>\n         to something else. Since the name\nis private, this can be done locally in the library without affecting other\ncode.\n      </P>\n    </LI>\n    <LI>\n      <P>\n        <STRONG>Everything else:</STRONG>\n         For any other invalid expression, you have to hoist the\nexpression out into a new named constant. For example, if you have code like\nthis:\n      </P>\n    </LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">switch (n) {\n  case 1 + 2: ...\n}\n</CODE>\n  </PRE>\n  <P>It can be fixed by changing it to:</P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const three = 1 + 2;\n\nswitch (n) {\n case three: ...\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "5min",
        "active": false
    },
    {
        "key": "invariant_booleans",
        "name": "Invariant booleans",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P style=\"font-size:30px\">\n    <STRONG>Unsupported since Dart language version 3.0.0.</STRONG>\n  </P>\n  <P>\n    <STRONG>DON'T</STRONG>\n     test for conditions that can be inferred at compile time or test the\nsame condition twice.\n  </P>\n  <P>\n    Conditional statements using a condition which cannot be anything but \n    <CODE>false</CODE>\n    have the effect of making blocks of code non-functional.  If the condition\ncannot evaluate to anything but \n    <CODE>true</CODE>\n    , the conditional statement is completely\nredundant, and makes the code less readable.\nIt is quite likely that the code does not match the programmer's intent.\nEither the condition should be removed or it should be updated so that it does\nnot always evaluate to \n    <CODE>true</CODE>\n     or \n    <CODE>false</CODE>\n     and does not perform redundant tests.\nThis rule will hint to the test conflicting with the linted one.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// foo can't be both equal and not equal to bar in the same expression\nif(foo == bar &amp;&amp; something &amp;&amp; foo != bar) {...}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void compute(int foo) {\n  if (foo == 4) {\n    doSomething();\n    // we know foo is equal to 4 at this point, so the next condition is always false\n    if (foo &gt; 4) {...}\n    ...\n  }\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void compute(bool foo) {\n  if (foo) {\n    return;\n  }\n  doSomething();\n  // foo is always false here\n  if (foo){...}\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void nestedOK() {\n  if (foo == bar) {\n    foo = baz;\n    if (foo != bar) {...}\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void nestedOk2() {\n  if (foo == bar) {\n    return;\n  }\n\n  foo = baz;\n  if (foo == bar) {...} // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void nestedOk5() {\n  if (foo != null) {\n    if (bar != null) {\n      return;\n    }\n  }\n\n  if (bar != null) {...} // OK\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "iterable_contains_unrelated_type",
        "name": "Iterable contains unrelated type",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     invoke \n    <CODE>contains</CODE>\n     on \n    <CODE>Iterable</CODE>\n     with an instance of different type\nthan the parameter type.\n  </P>\n  <P>\n    Doing this will invoke \n    <CODE>==</CODE>\n     on its elements and most likely will return \n    <CODE>false</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction() {\n  var list = &lt;int&gt;[];\n  if (list.contains('1')) print('someFunction'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction3() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.contains('1')) print('someFunction3'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction8() {\n  List&lt;DerivedClass2&gt; list = &lt;DerivedClass2&gt;[];\n  DerivedClass3 instance;\n  if (list.contains(instance)) print('someFunction8'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class SomeIterable&lt;E&gt; implements Iterable&lt;E&gt; {}\n\nabstract class MyClass implements SomeIterable&lt;int&gt; {\n  bool badMethod(String thing) =&gt; this.contains(thing); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction10() {\n  var list = [];\n  if (list.contains(1)) print('someFunction10'); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction1() {\n  var list = &lt;int&gt;[];\n  if (list.contains(1)) print('someFunction1'); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction4() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.contains(1)) print('someFunction4'); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction5() {\n  List&lt;ClassBase&gt; list = &lt;ClassBase&gt;[];\n  DerivedClass1 instance;\n  if (list.contains(instance)) print('someFunction5'); // OK\n}\n\nabstract class ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction6() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass2 instance;\n  if (list.contains(instance)) print('someFunction6'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction7() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass3 instance;\n  if (list.contains(instance)) print('someFunction7'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "1min",
        "active": true
    },
    {
        "key": "list_remove_unrelated_type",
        "name": "List remove unrelated type",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     invoke \n    <CODE>remove</CODE>\n     on \n    <CODE>List</CODE>\n     with an instance of different type than\nthe parameter type.\n  </P>\n  <P>\n    Doing this will invoke \n    <CODE>==</CODE>\n     on its elements and most likely will\nreturn \n    <CODE>false</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction() {\n  var list = &lt;int&gt;[];\n  if (list.remove('1')) print('someFunction'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction3() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.remove('1')) print('someFunction3'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction8() {\n  List&lt;DerivedClass2&gt; list = &lt;DerivedClass2&gt;[];\n  DerivedClass3 instance;\n  if (list.remove(instance)) print('someFunction8'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class SomeList&lt;E&gt; implements List&lt;E&gt; {}\n\nabstract class MyClass implements SomeList&lt;int&gt; {\n  bool badMethod(String thing) =&gt; this.remove(thing); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction10() {\n  var list = [];\n  if (list.remove(1)) print('someFunction10'); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction1() {\n  var list = &lt;int&gt;[];\n  if (list.remove(1)) print('someFunction1'); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction4() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.remove(1)) print('someFunction4'); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction5() {\n  List&lt;ClassBase&gt; list = &lt;ClassBase&gt;[];\n  DerivedClass1 instance;\n  if (list.remove(instance)) print('someFunction5'); // OK\n}\n\nabstract class ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction6() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass2 instance;\n  if (list.remove(instance)) print('someFunction6'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction7() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass3 instance;\n  if (list.remove(instance)) print('someFunction7'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "1min",
        "active": true
    },
    {
        "key": "literal_only_boolean_expressions",
        "name": "Literal only boolean expressions",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     test for conditions composed only by literals, since the value can be\ninferred at compile time.\n  </P>\n  <P>\n    Conditional statements using a condition which cannot be anything but FALSE have\nthe effect of making blocks of code non-functional.  If the condition cannot\nevaluate to anything but \n    <CODE>true</CODE>\n    , the conditional statement is completely\nredundant, and makes the code less readable.\nIt is quite likely that the code does not match the programmer's intent.\nEither the condition should be removed or it should be updated so that it does\nnot always evaluate to \n    <CODE>true</CODE>\n     or \n    <CODE>false</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bad() {\n  if (true) {} // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bad() {\n  if (true &amp;&amp; 1 != 0) {} // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bad() {\n  if (1 != 0 &amp;&amp; true) {} // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bad() {\n  if (1 &lt; 0 &amp;&amp; true) {} // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bad() {\n  if (true &amp;&amp; false) {} // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bad() {\n  if (1 != 0) {} // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bad() {\n  if (true &amp;&amp; 1 != 0 || 3 &lt; 4) {} // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void bad() {\n  if (1 != 0 || 3 &lt; 4 &amp;&amp; true) {} // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>NOTE:</STRONG>\n     that an exception is made for the common \n    <CODE>while (true) { }</CODE>\n     idiom,\nwhich is often reasonably preferred to the equivalent \n    <CODE>for (;;)</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void good() {\n  while (true) {\n    // Do stuff.\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "no_adjacent_strings_in_list",
        "name": "No adjacent strings in list",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use adjacent strings in a list.\n  </P>\n  <P>This can indicate a forgotten comma.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">List&lt;String&gt; list = &lt;String&gt;[\n  'a'\n  'b',\n  'c',\n];\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">List&lt;String&gt; list = &lt;String&gt;[\n  'a' +\n  'b',\n  'c',\n];\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "no_duplicate_case_values",
        "name": "No duplicate case values",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use more than one case with same value.\n  </P>\n  <P>This is usually a typo or changed value of constant.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const int A = 1;\nswitch (v) {\n  case 1:\n  case 2:\n  case A:\n  case 2:\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const int A = 1;\nswitch (v) {\n  case A:\n  case 2:\n}\n</CODE>\n  </PRE>\n  <P>NOTE: this lint only reports duplicate cases in libraries opted in to Dart 2.19\nand below. In Dart 3.0 and after, duplicate cases are reported as dead code\nby the analyzer.</P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "no_logic_in_create_state",
        "name": "No logic in create state",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     put any logic in \n    <CODE>createState()</CODE>\n    .\n  </P>\n  <P>\n    Implementations of  \n    <CODE>createState()</CODE>\n     should return a new instance\nof a State object and do nothing more.  Since state access is preferred\nvia the \n    <CODE>widget</CODE>\n     field,  passing data to \n    <CODE>State</CODE>\n     objects using custom\nconstructor parameters should also be avoided and so further, the State\nconstructor is required to be passed no arguments.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">MyState global;\n\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() {\n    global = MyState();\n    return global;\n  } \n}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">class MyStateful extends StatefulWidget {\n  @override\n  MyState createState() =&gt; MyState()..field = 42;\n}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">class MyStateful extends StatefulWidget {\n  @override\n  MyState createState() =&gt; MyState(42);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class MyStateful extends StatefulWidget {\n  @override\n  MyState createState() {\n    return MyState();\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_relative_imports",
        "name": "Prefer relative imports",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     relative imports for files in \n    <CODE>lib/</CODE>\n    .\n  </P>\n  <P>\n    When mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways. One way to avoid\nthat is to ensure you consistently use relative imports for files within the\n\n    <CODE>lib/</CODE>\n     directory.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:my_package/bar.dart';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'bar.dart';\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"always_use_package_imports.html\">always_use_package_imports</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_void_to_null",
        "name": "Prefer void to null",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use the type Null where void would work.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Null f() {}\nFuture&lt;Null&gt; f() {}\nStream&lt;Null&gt; f() {}\nf(Null x) {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f() {}\nFuture&lt;void&gt; f() {}\nStream&lt;void&gt; f() {}\nf(void x) {}\n</CODE>\n  </PRE>\n  <P>Some exceptions include formulating special function types:</P>\n  <PRE>\n<CODE class=\"language-dart\">Null Function(Null, Null);\n</CODE>\n  </PRE>\n  <P>and for making empty literals which are safe to pass into read-only locations\nfor any type of map or list:</P>\n  <PRE>\n<CODE class=\"language-dart\">&lt;Null&gt;[];\n&lt;int, Null&gt;{};\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "test_types_in_equals",
        "name": "Test types in equals",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     test type arguments in operator ==(Object other).\n  </P>\n  <P>Not testing types might result in null pointer exceptions which will be\nunexpected for consumers of your class.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Field {\n}\n\nclass Bad {\n  final Field someField;\n\n  Bad(this.someField);\n\n  @override\n  bool operator ==(Object other) {\n    Bad otherBad = other as Bad; // LINT\n    bool areEqual = otherBad != null &amp;&amp; otherBad.someField == someField;\n    return areEqual;\n  }\n\n  @override\n  int get hashCode {\n    return someField.hashCode;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Field {\n}\n\nclass Good {\n  final Field someField;\n\n  Good(this.someField);\n\n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) {\n      return true;\n    }\n    return other is Good &amp;&amp;\n        this.someField == other.someField;\n  }\n\n  @override\n  int get hashCode {\n    return someField.hashCode;\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "throw_in_finally",
        "name": "Throw in finally",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     throwing exceptions in finally blocks.\n  </P>\n  <P>Throwing exceptions in finally blocks will inevitably cause unexpected behavior\nthat is hard to debug.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class BadThrow {\n  double nonCompliantMethod() {\n    try {\n      print('hello world! ${1 / 0}');\n    } catch (e) {\n      print(e);\n    } finally {\n      throw 'Find the hidden error :P'; // LINT\n    }\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Ok {\n  double compliantMethod() {\n    var i = 5;\n    try {\n      i = 1 / 0;\n    } catch (e) {\n      print(e); // OK\n    }\n    return i;\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "unnecessary_statements",
        "name": "Unnecessary statements",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using unnecessary statements.\n  </P>\n  <P>Statements which have no clear effect are usually unnecessary, or should be\nbroken up.</P>\n  <P>For example,</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">myvar;\nlist.clear;\n1 + 2;\nmethodOne() + methodTwo();\nfoo ? bar : baz;\n</CODE>\n  </PRE>\n  <P>Though the added methods have a clear effect, the addition itself does not\nunless there is some magical overload of the + operator.</P>\n  <P>Usually code like this indicates an incomplete thought, and is a bug.</P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">some.method();\nconst SomeClass();\nmethodOne();\nmethodTwo();\nfoo ? bar() : baz();\nreturn myvar;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unrelated_type_equality_checks",
        "name": "Unrelated type equality checks",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     Compare references of unrelated types for equality.\n  </P>\n  <P>\n    Comparing references of a type where neither is a subtype of the other most\nlikely will return \n    <CODE>false</CODE>\n     and might not reflect programmer's intent.\n  </P>\n  <P>\n    <CODE>Int64</CODE>\n     and \n    <CODE>Int32</CODE>\n     from \n    <CODE>package:fixnum</CODE>\n     allow comparing to \n    <CODE>int</CODE>\n     provided\nthe \n    <CODE>int</CODE>\n     is on the right hand side. The lint allows this as a special case.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction() {\n  var x = '1';\n  if (x == 1) print('someFunction'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction1() {\n  String x = '1';\n  if (x == 1) print('someFunction1'); // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction13(DerivedClass2 instance) {\n  var other = DerivedClass3();\n\n  if (other == instance) print('someFunction13'); // LINT\n}\n\nclass ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction2() {\n  var x = '1';\n  var y = '2';\n  if (x == y) print(someFunction2); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction3() {\n  for (var i = 0; i &lt; 10; i++) {\n    if (i == 0) print(someFunction3); // OK\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction4() {\n  var x = '1';\n  if (x == null) print(someFunction4); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction7() {\n  List someList;\n\n  if (someList.length == 0) print('someFunction7'); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction8(ClassBase instance) {\n  DerivedClass1 other;\n\n  if (other == instance) print('someFunction8'); // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction10(unknown) {\n  var what = unknown - 1;\n  for (var index = 0; index &lt; unknown; index++) {\n    if (what == index) print('someFunction10'); // OK\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void someFunction11(Mixin instance) {\n  var other = DerivedClass2();\n\n  if (other == instance) print('someFunction11'); // OK\n  if (other != instance) print('!someFunction11'); // OK\n}\n\nclass ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unsafe_html",
        "name": "Unsafe html",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n  </P>\n  <UL>\n    <LI>\n      assigning directly to the \n      <CODE>href</CODE>\n       field of an AnchorElement\n    </LI>\n    <LI>\n      assigning directly to the \n      <CODE>src</CODE>\n       field of an EmbedElement, IFrameElement, or\nScriptElement\n    </LI>\n    <LI>\n      assigning directly to the \n      <CODE>srcdoc</CODE>\n       field of an IFrameElement\n    </LI>\n    <LI>\n      calling the \n      <CODE>createFragment</CODE>\n       method of Element\n    </LI>\n    <LI>\n      calling the \n      <CODE>open</CODE>\n       method of Window\n    </LI>\n    <LI>\n      calling the \n      <CODE>setInnerHtml</CODE>\n       method of Element\n    </LI>\n    <LI>\n      calling the \n      <CODE>Element.html</CODE>\n       constructor\n    </LI>\n    <LI>\n      calling the \n      <CODE>DocumentFragment.html</CODE>\n       constructor\n    </LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var script = ScriptElement()..src = 'foo.js';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "use_build_context_synchronously",
        "name": "Use build context synchronously",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use BuildContext across asynchronous gaps.\n  </P>\n  <P>\n    Storing \n    <CODE>BuildContext</CODE>\n     for later usage can easily lead to difficult to diagnose\ncrashes. Asynchronous gaps are implicitly storing \n    <CODE>BuildContext</CODE>\n     and are some of\nthe easiest to overlook when writing code.\n  </P>\n  <P>\n    When a \n    <CODE>BuildContext</CODE>\n     is used, its \n    <CODE>mounted</CODE>\n     property must be checked after an\nasynchronous gap.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void onButtonTapped(BuildContext context) async {\n  await Future.delayed(const Duration(seconds: 1));\n  Navigator.of(context).pop();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void onButtonTapped(BuildContext context) {\n  Navigator.of(context).pop();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void onButtonTapped() async {\n  await Future.delayed(const Duration(seconds: 1));\n\n  if (!context.mounted) return;\n  Navigator.of(context).pop();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "5min",
        "active": false
    },
    {
        "key": "use_key_in_widget_constructors",
        "name": "Use key in widget constructors",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use key in widget constructors.\n  </P>\n  <P>It's a good practice to expose the ability to provide a key when creating public\nwidgets.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class MyPublicWidget extends StatelessWidget {\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class MyPublicWidget extends StatelessWidget {\n  MyPublicWidget({super.key});\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "always_declare_return_types",
        "name": "Always declare return types",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     declare method return types.\n  </P>\n  <P>\n    When declaring a method or function \n    <EM>always</EM>\n     specify a return type.\nDeclaring return types for functions helps improve your codebase by allowing the\nanalyzer to more adequately check your code for errors that could occur during\nruntime.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">main() { }\n\n_bar() =&gt; _Foo();\n\nclass _Foo {\n  _foo() =&gt; 42;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void main() { }\n\n_Foo _bar() =&gt; _Foo();\n\nclass _Foo {\n  int _foo() =&gt; 42;\n}\n\ntypedef predicate = bool Function(Object o);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "always_put_control_body_on_new_line",
        "name": "Always put control body on new line",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://flutter.dev/style-guide/\">style guide for the flutter repo</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     separate the control structure expression from its statement.\n  </P>\n  <P>\n    Don't put the statement part of an \n    <CODE>if</CODE>\n    , \n    <CODE>for</CODE>\n    , \n    <CODE>while</CODE>\n    , \n    <CODE>do</CODE>\n     on the same line\nas the expression, even if it is short.  Doing so makes it unclear that there\nis relevant code there.  This is especially important for early returns.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (notReady) return;\n\nif (notReady)\n  return;\nelse print('ok')\n\nwhile (condition) i += 1;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (notReady)\n  return;\n\nif (notReady)\n  return;\nelse\n  print('ok')\n\nwhile (condition)\n  i += 1;\n</CODE>\n  </PRE>\n  <P>\n    Note that this rule can conflict with the\n\n    <A href=\"https://dart.dev/tools/dart-format\">Dart formatter</A>\n    , and should not be enabled\nwhen the Dart formatter is used.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "always_put_required_named_parameters_first",
        "name": "Always put required named parameters first",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     specify \n    <CODE>required</CODE>\n     on named parameter before other named parameters.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">m({b, c, required a}) ;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">m({required a, b, c}) ;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">m({b, c, @required a}) ;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">m({@required a, b, c}) ;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "always_specify_types",
        "name": "Always specify types",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://flutter.dev/style-guide/\">style guide for the flutter repo</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     specify type annotations.\n  </P>\n  <P>\n    Avoid \n    <CODE>var</CODE>\n     when specifying that a type is unknown and short-hands that elide\ntype annotations.  Use \n    <CODE>dynamic</CODE>\n     if you are being explicit that the type is\nunknown.  Use \n    <CODE>Object</CODE>\n     if you are being explicit that you want an object that\nimplements \n    <CODE>==</CODE>\n     and \n    <CODE>hashCode</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var foo = 10;\nfinal bar = Bar();\nconst quux = 20;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">int foo = 10;\nfinal Bar bar = Bar();\nString baz = 'hello';\nconst int quux = 20;\n</CODE>\n  </PRE>\n  <P>\n    NOTE: Using the the \n    <CODE>@optionalTypeArgs</CODE>\n     annotation in the \n    <CODE>meta</CODE>\n     package, API\nauthors can special-case type variables whose type needs to by dynamic but whose\ndeclaration should be treated as optional.  For example, suppose you have a\n\n    <CODE>Key</CODE>\n     object whose type parameter you'd like to treat as optional.  Using the\n\n    <CODE>@optionalTypeArgs</CODE>\n     would look like this:\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:meta/meta.dart';\n\n@optionalTypeArgs\nclass Key&lt;T&gt; {\n ...\n}\n\nmain() {\n  Key s = Key(); // OK!\n}\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"avoid_types_on_closure_parameters.html\">avoid_types_on_closure_parameters</A>\n    , \n    <A href=\"omit_local_variable_types.html\">omit_local_variable_types</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "annotate_overrides",
        "name": "Annotate overrides",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     annotate overridden methods and fields.\n  </P>\n  <P>This practice improves code readability and helps protect against\nunintentionally overriding superclass members.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Cat {\n  int get lives =&gt; 9;\n}\n\nclass Lucky extends Cat {\n  final int lives = 14;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class Dog {\n  String get breed;\n  void bark() {}\n}\n\nclass Husky extends Dog {\n  @override\n  final String breed = 'Husky';\n  @override\n  void bark() {}\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_annotating_with_dynamic",
        "name": "Avoid annotating with dynamic",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     annotating with dynamic when not required.\n  </P>\n  <P>\n    As \n    <CODE>dynamic</CODE>\n     is the assumed return value of a function or method, it is usually\nnot necessary to annotate it.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">dynamic lookUpOrDefault(String name, Map map, dynamic defaultValue) {\n  var value = map[name];\n  if (value != null) return value;\n  return defaultValue;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">lookUpOrDefault(String name, Map map, defaultValue) {\n  var value = map[name];\n  if (value != null) return value;\n  return defaultValue;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_as",
        "name": "Avoid as",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P style=\"font-size:30px\">\n    <STRONG>Unsupported since Dart language version 2.12.0.</STRONG>\n  </P>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using \n    <CODE>as</CODE>\n    .\n  </P>\n  <P>\n    If you know the type is correct, use an assertion or assign to a more\nnarrowly-typed variable (this avoids the type check in release mode; \n    <CODE>as</CODE>\n     is not\ncompiled out in release mode).  If you don't know whether the type is\ncorrect, check using \n    <CODE>is</CODE>\n     (this avoids the exception that \n    <CODE>as</CODE>\n     raises).\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">(pm as Person).firstName = 'Seth';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (pm is Person)\n  pm.firstName = 'Seth';\n</CODE>\n  </PRE>\n  <P>but certainly not</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">try {\n   (pm as Person).firstName = 'Seth';\n} on CastError { }\n</CODE>\n  </PRE>\n  <P>\n    Note that an exception is made in the case of \n    <CODE>dynamic</CODE>\n     since the cast has no\nperformance impact.\n  </P>\n  <P>\n    <STRONG>OK:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">HasScrollDirection scrollable = renderObject as dynamic;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_bool_literals_in_conditional_expressions",
        "name": "Avoid bool literals in conditional expressions",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     bool literals in conditional expressions.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">condition ? true : boolExpression\ncondition ? false : boolExpression\ncondition ? boolExpression : true\ncondition ? boolExpression : false\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">condition || boolExpression\n!condition &amp;&amp; boolExpression\n!condition || boolExpression\ncondition &amp;&amp; boolExpression\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_catches_without_on_clauses",
        "name": "Avoid catches without on clauses",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     catches without on clauses.\n  </P>\n  <P>Using catch clauses without on clauses make your code prone to encountering\nunexpected errors that won't be thrown (and thus will go unnoticed).</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">try {\n somethingRisky()\n}\ncatch(e) {\n  doSomething(e);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">try {\n somethingRisky()\n}\non Exception catch(e) {\n  doSomething(e);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_catching_errors",
        "name": "Avoid catching errors",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     explicitly catch Error or types that implement it.\n  </P>\n  <P>Errors differ from Exceptions in that Errors can be analyzed and prevented prior\nto runtime.  It should almost never be necessary to catch an error at runtime.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">try {\n  somethingRisky();\n} on Error catch(e) {\n  doSomething(e);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">try {\n  somethingRisky();\n} on Exception catch(e) {\n  doSomething(e);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_classes_with_only_static_members",
        "name": "Avoid classes with only static members",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From \n    <A href=\"https://dart.dev/guides/language/effective-dart/design#avoid-defining-a-class-that-contains-only-static-members\">Effective Dart</A>\n    :\n  </P>\n  <P>\n    <STRONG>AVOID</STRONG>\n     defining a class that contains only static members.\n  </P>\n  <P>Creating classes with the sole purpose of providing utility or otherwise static\nmethods is discouraged.  Dart allows functions to exist outside of classes for\nthis very reason.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class DateUtils {\n  static DateTime mostRecent(List&lt;DateTime&gt; dates) {\n    return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);\n  }\n}\n\nclass _Favorites {\n  static const mammal = 'weasel';\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">DateTime mostRecent(List&lt;DateTime&gt; dates) {\n  return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);\n}\n\nconst _favoriteMammal = 'weasel';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_double_and_int_checks",
        "name": "Avoid double and int checks",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     to check if type is double or int.\n  </P>\n  <P>\n    When compiled to JS, integer values are represented as floats. That can lead to\nsome unexpected behavior when using either \n    <CODE>is</CODE>\n     or \n    <CODE>is!</CODE>\n     where the type is\neither \n    <CODE>int</CODE>\n     or \n    <CODE>double</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">f(num x) {\n  if (x is double) {\n    ...\n  } else if (x is int) {\n    ...\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">f(dynamic x) {\n  if (x is num) {\n    ...\n  } else {\n    ...\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_equals_and_hash_code_on_mutable_classes",
        "name": "Avoid equals and hash code on mutable classes",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     overloading operator == and hashCode on classes not marked \n    <CODE>@immutable</CODE>\n    .\n  </P>\n  <P>If a class is not immutable, overloading operator == and hashCode can lead to\nunpredictable and undesirable behavior when used in collections. See\nhttps://dart.dev/guides/language/effective-dart/design#avoid-defining-custom-equality-for-mutable-classes\nfor more information.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class B {\n  String key;\n  const B(this.key);\n  @override\n  operator ==(other) =&gt; other is B &amp;&amp; other.key == key;\n  @override\n  int get hashCode =&gt; key.hashCode;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@immutable\nclass A {\n  final String key;\n  const A(this.key);\n  @override\n  operator ==(other) =&gt; other is A &amp;&amp; other.key == key;\n  @override\n  int get hashCode =&gt; key.hashCode;\n}\n</CODE>\n  </PRE>\n  <P>\n    NOTE: The lint checks the use of the \n    <CODE>@immutable</CODE>\n     annotation, and will trigger\neven if the class is otherwise not mutable. Thus:\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class C {\n  final String key;\n  const C(this.key);\n  @override\n  operator ==(other) =&gt; other is C &amp;&amp; other.key == key;\n  @override\n  int get hashCode =&gt; key.hashCode;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_escaping_inner_quotes",
        "name": "Avoid escaping inner quotes",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Avoid escaping inner quotes by converting surrounding quotes.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s = 'It\\'s not fun';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s = \"It's not fun\";\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_field_initializers_in_const_classes",
        "name": "Avoid field initializers in const classes",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     field initializers in const classes.\n  </P>\n  <P>\n    Instead of \n    <CODE>final x = const expr;</CODE>\n    , you should write \n    <CODE>get x =&gt; const expr;</CODE>\n     and\nnot allocate a useless field. As of April 2018 this is true for the VM, but not\nfor code that will be compiled to JS.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  final a = const [];\n  const A();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  get a =&gt; const [];\n  const A();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_final_parameters",
        "name": "Avoid final parameters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     declaring parameters as final.\n  </P>\n  <P>Declaring parameters as final can lead to unnecessarily verbose code, especially\nwhen using the \"parameter_assignments\" rule.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void goodParameter(final String label) { // LINT\n  print(label);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void badParameter(String label) { // OK\n  print(label);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void goodExpression(final int value) =&gt; print(value); // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void badExpression(int value) =&gt; print(value); // OK\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">[1, 4, 6, 8].forEach((final value) =&gt; print(value + 2)); // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">[1, 4, 6, 8].forEach((value) =&gt; print(value + 2)); // OK\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"prefer_final_parameters.html\">prefer_final_parameters</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_function_literals_in_foreach_calls",
        "name": "Avoid function literals in foreach calls",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using \n    <CODE>forEach</CODE>\n     with a function literal.\n  </P>\n  <P>\n    The \n    <CODE>for</CODE>\n     loop enables a developer to be clear and explicit as to their intent.\nA return in the body of the \n    <CODE>for</CODE>\n     loop returns from the body of the function,\nwhere as a return in the body of the \n    <CODE>forEach</CODE>\n     closure only returns a value\nfor that iteration of the \n    <CODE>forEach</CODE>\n    . The body of a \n    <CODE>for</CODE>\n     loop can contain\n\n    <CODE>await</CODE>\n    s, while the closure body of a \n    <CODE>forEach</CODE>\n     cannot.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">people.forEach((person) {\n  ...\n});\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">for (var person in people) {\n  ...\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_implementing_value_types",
        "name": "Avoid implementing value types",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     implement classes that override \n    <CODE>==</CODE>\n    .\n  </P>\n  <P>\n    The \n    <CODE>==</CODE>\n     operator is contractually required to be an equivalence relation;\nthat is, symmetrically for all objects \n    <CODE>o1</CODE>\n     and \n    <CODE>o2</CODE>\n    , \n    <CODE>o1 == o2</CODE>\n     and \n    <CODE>o2 == o1</CODE>\n    must either both be true, or both be false.\n  </P>\n  <BLOCKQUOTE>\n    <P>\n      <EM>NOTE</EM>\n      : Dart does not have true \n      <EM>value types</EM>\n      , so instead we consider a class\nthat implements \n      <CODE>==</CODE>\n        as a \n      <EM>proxy</EM>\n       for identifying value types.\n    </P>\n  </BLOCKQUOTE>\n  <P>\n    When using \n    <CODE>implements</CODE>\n    , you do not inherit the method body of \n    <CODE>==</CODE>\n    , making it\nnearly impossible to follow the contract of \n    <CODE>==</CODE>\n    . Classes that override \n    <CODE>==</CODE>\n    typically are usable directly in tests \n    <EM>without</EM>\n     creating mocks or fakes as\nwell. For example, for a given class \n    <CODE>Size</CODE>\n    :\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Size {\n  final int inBytes;\n  const Size(this.inBytes);\n\n  @override\n  bool operator ==(Object other) =&gt; other is Size &amp;&amp; other.inBytes == inBytes;\n\n  @override\n  int get hashCode =&gt; inBytes.hashCode;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class CustomSize implements Size {\n  final int inBytes;\n  const CustomSize(this.inBytes);\n\n  int get inKilobytes =&gt; inBytes ~/ 1000;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:test/test.dart';\nimport 'size.dart';\n\nclass FakeSize implements Size {\n  int inBytes = 0;\n}\n\nvoid main() {\n  test('should not throw on a size &gt;1Kb', () {\n    expect(() =&gt; someFunction(FakeSize()..inBytes = 1001), returnsNormally);\n  });\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class ExtendedSize extends Size {\n  ExtendedSize(int inBytes) : super(inBytes);\n\n  int get inKilobytes =&gt; inBytes ~/ 1000;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n    :\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:test/test.dart';\nimport 'size.dart';\n\nvoid main() {\n  test('should not throw on a size &gt;1Kb', () {\n    expect(() =&gt; someFunction(Size(1001)), returnsNormally);\n  });\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_init_to_null",
        "name": "Avoid init to null",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From \n    <A href=\"https://dart.dev/guides/language/effective-dart/usage#dont-explicitly-initialize-variables-to-null\">Effective Dart</A>\n    :\n  </P>\n  <P>\n    <STRONG>DON'T</STRONG>\n     explicitly initialize variables to \n    <CODE>null</CODE>\n    .\n  </P>\n  <P>\n    If a variable has a non-nullable type or is \n    <CODE>final</CODE>\n    ,\nDart reports a compile error if you try to use it\nbefore it has been definitely initialized.\nIf the variable is nullable and not \n    <CODE>const</CODE>\n     or \n    <CODE>final</CODE>\n    ,\nthen it is implicitly initialized to \n    <CODE>null</CODE>\n     for you.\nThere's no concept of \"uninitialized memory\" in Dart\nand no need to explicitly initialize a variable to \n    <CODE>null</CODE>\n     to be \"safe\".\nAdding \n    <CODE>= null</CODE>\n     is redundant and unneeded.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Item? bestDeal(List&lt;Item&gt; cart) {\n  Item? bestItem = null;\n\n  for (final item in cart) {\n    if (bestItem == null || item.price &lt; bestItem.price) {\n      bestItem = item;\n    }\n  }\n\n  return bestItem;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Item? bestDeal(List&lt;Item&gt; cart) {\n  Item? bestItem;\n\n  for (final item in cart) {\n    if (bestItem == null || item.price &lt; bestItem.price) {\n      bestItem = item;\n    }\n  }\n\n  return bestItem;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_js_rounded_ints",
        "name": "Avoid js rounded ints",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     integer literals that cannot be represented exactly when compiled to\nJavaScript.\n  </P>\n  <P>\n    When a program is compiled to JavaScript \n    <CODE>int</CODE>\n     and \n    <CODE>double</CODE>\n     become JavaScript\nNumbers. Too large integers (\n    <CODE>value &lt; Number.MIN_SAFE_INTEGER</CODE>\n     or\n\n    <CODE>value &gt; Number.MAX_SAFE_INTEGER</CODE>\n    ) may be rounded to the closest Number value.\n  </P>\n  <P>\n    For instance \n    <CODE>1000000000000000001</CODE>\n     cannot be represented exactly as a JavaScript\nNumber, so \n    <CODE>1000000000000000000</CODE>\n     will be used instead.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">int value = 9007199254740995;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">BigInt value = BigInt.parse('9007199254740995');\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_multiple_declarations_per_line",
        "name": "Avoid multiple declarations per line",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     declare multiple variables on a single line.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">String? foo, bar, baz;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">String? foo;\nString? bar;\nString? baz;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_null_checks_in_equality_operators",
        "name": "Avoid null checks in equality operators",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     check for null in custom == operators.\n  </P>\n  <P>\n    As null is a special value, no instance of any class (other than \n    <CODE>Null</CODE>\n    ) can be\nequivalent to it.  Thus, it is redundant to check whether the other instance is\nnull.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Person {\n  final String? name;\n\n  @override\n  operator ==(Object? other) =&gt;\n      other != null &amp;&amp; other is Person &amp;&amp; name == other.name;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Person {\n  final String? name;\n\n  @override\n  operator ==(Object? other) =&gt; other is Person &amp;&amp; name == other.name;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_positional_boolean_parameters",
        "name": "Avoid positional boolean parameters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     positional boolean parameters.\n  </P>\n  <P>Positional boolean parameters are a bad practice because they are very\nambiguous.  Using named boolean parameters is much more readable because it\ninherently describes what the boolean value represents.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Task(true);\nTask(false);\nListBox(false, true, true);\nButton(false);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Task.oneShot();\nTask.repeating();\nListBox(scroll: true, showScrollbars: true);\nButton(ButtonState.enabled);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_private_typedef_functions",
        "name": "Avoid private typedef functions",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     private typedef functions used only once. Prefer inline function\nsyntax.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">typedef void _F();\nm(_F f);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">m(void Function() f);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "10min",
        "active": false
    },
    {
        "key": "avoid_redundant_argument_values",
        "name": "Avoid redundant argument values",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     pass an argument that matches the corresponding parameter's default\nvalue.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f({bool valWithDefault = true, bool? val}) {\n  ...\n}\n\nvoid main() {\n  f(valWithDefault: true);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f({bool valWithDefault = true, bool? val}) {\n  ...\n}\n\nvoid main() {\n  f(valWithDefault: false);\n  f();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_renaming_method_parameters",
        "name": "Avoid renaming method parameters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     rename parameters of overridden methods.\n  </P>\n  <P>\n    Methods that override another method, but do not have their own documentation\ncomment, will inherit the overridden method's comment when \n    <CODE>dart doc</CODE>\n     produces\ndocumentation. If the inherited method contains the name of the parameter (in\nsquare brackets), then \n    <CODE>dart doc</CODE>\n     cannot link it correctly.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class A {\n  m(a);\n}\n\nabstract class B extends A {\n  m(b);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class A {\n  m(a);\n}\n\nabstract class B extends A {\n  m(a);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_return_types_on_setters",
        "name": "Avoid return types on setters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     return types on setters.\n  </P>\n  <P>As setters do not return a value, declaring the return type of one is redundant.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void set speed(int ms);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">set speed(int ms);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_returning_null_for_void",
        "name": "Avoid returning null for void",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     returning null for void.\n  </P>\n  <P>\n    In a large variety of languages \n    <CODE>void</CODE>\n     as return type is used to indicate that\na function doesn't return anything. Dart allows returning \n    <CODE>null</CODE>\n     in functions\nwith \n    <CODE>void</CODE>\n     return type but it also allow using \n    <CODE>return;</CODE>\n     without specifying any\nvalue. To have a consistent way you should not return \n    <CODE>null</CODE>\n     and only use an\nempty return.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f1() {\n  return null;\n}\nFuture&lt;void&gt; f2() async {\n  return null;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f1() {\n  return;\n}\nFuture&lt;void&gt; f2() async {\n  return;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_returning_this",
        "name": "Avoid returning this",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     returning this from methods just to enable a fluent interface.\n  </P>\n  <P>\n    Returning \n    <CODE>this</CODE>\n     from a method is redundant; Dart has a cascade operator which\nallows method chaining universally.\n  </P>\n  <P>\n    Returning \n    <CODE>this</CODE>\n     is allowed for:\n  </P>\n  <UL>\n    <LI>operators</LI>\n    <LI>methods with a return type different of the current class</LI>\n    <LI>methods defined in parent classes / mixins or interfaces</LI>\n    <LI>methods defined in extensions</LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var buffer = StringBuffer()\n  .write('one')\n  .write('two')\n  .write('three');\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var buffer = StringBuffer()\n  ..write('one')\n  ..write('two')\n  ..write('three');\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_setters_without_getters",
        "name": "Avoid setters without getters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     define a setter without a corresponding getter.\n  </P>\n  <P>Defining a setter without defining a corresponding getter can lead to logical\ninconsistencies.  Doing this could allow you to set a property to some value,\nbut then upon observing the property's value, it could easily be different.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Bad {\n  int l, r;\n\n  set length(int newLength) {\n    r = l + newLength;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Good {\n  int l, r;\n\n  int get length =&gt; r - l;\n\n  set length(int newLength) {\n    r = l + newLength;\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_shadowing_type_parameters",
        "name": "Avoid shadowing type parameters",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     shadowing type parameters.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A&lt;T&gt; {\n  void fn&lt;T&gt;() {}\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A&lt;T&gt; {\n  void fn&lt;U&gt;() {}\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_single_cascade_in_expression_statements",
        "name": "Avoid single cascade in expression statements",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     single cascade in expression statements.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">o..m();\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">o.m();\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "avoid_types_on_closure_parameters",
        "name": "Avoid types on closure parameters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     annotating types for function expression parameters.\n  </P>\n  <P>Annotating types for function expression parameters is usually unnecessary\nbecause the parameter types can almost always be inferred from the context,\nthus making the practice redundant.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var names = people.map((Person person) =&gt; person.name);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var names = people.map((person) =&gt; person.name);\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"always_specify_types.html\">always_specify_types</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_unnecessary_containers",
        "name": "Avoid unnecessary containers",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     wrapping widgets in unnecessary containers.\n  </P>\n  <P>\n    Wrapping a widget in \n    <CODE>Container</CODE>\n     with no other parameters set has no effect\nand makes code needlessly more complex.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildRow() {\n  return Container(\n      child: Row(\n        children: &lt;Widget&gt;[\n          const MyLogo(),\n          const Expanded(\n            child: Text('...'),\n          ),\n        ],\n      )\n  );\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildRow() {\n  return Row(\n    children: &lt;Widget&gt;[\n      const MyLogo(),\n      const Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "avoid_unused_constructor_parameters",
        "name": "Avoid unused constructor parameters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     defining unused parameters in constructors.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class BadOne {\n  BadOne(int unusedParameter, [String unusedPositional]);\n}\n\nclass BadTwo {\n  int c;\n\n  BadTwo(int a, int b, int x) {\n    c = a + b;\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "avoid_void_async",
        "name": "Avoid void async",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     mark async functions as returning Future\n    <VOID>.</VOID>\n  </P>\n  <P>\n    When declaring an async method or function which does not return a value,\ndeclare that it returns \n    <CODE>Future&lt;void&gt;</CODE>\n     and not just \n    <CODE>void</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f() async {}\nvoid f2() async =&gt; null;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Future&lt;void&gt; f() async {}\nFuture&lt;void&gt; f2() async =&gt; null;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>EXCEPTION:</STRONG>\n  </P>\n  <P>\n    An exception is made for top-level \n    <CODE>main</CODE>\n     functions, where the \n    <CODE>Future</CODE>\n    annotation \n    <EM>can</EM>\n     (and generally should) be dropped in favor of \n    <CODE>void</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Future&lt;void&gt; f() async {}\n\nvoid main() async {\n  await f();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "await_only_futures",
        "name": "Await only futures",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using await on anything which is not a future.\n  </P>\n  <P>\n    Await is allowed on the types: \n    <CODE>Future&lt;X&gt;</CODE>\n    , \n    <CODE>FutureOr&lt;X&gt;</CODE>\n    , \n    <CODE>Future&lt;X&gt;?</CODE>\n    ,\n\n    <CODE>FutureOr&lt;X&gt;?</CODE>\n     and \n    <CODE>dynamic</CODE>\n    .\n  </P>\n  <P>\n    Further, using \n    <CODE>await null</CODE>\n     is specifically allowed as a way to introduce a\nmicrotask delay.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">main() async {\n  print(await 23);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">main() async {\n  await null; // If a delay is really intended.\n  print(23);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "camel_case_extensions",
        "name": "Camel case extensions",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     name extensions using \n    <CODE>UpperCamelCase</CODE>\n    .\n  </P>\n  <P>Extensions should capitalize the first letter of each word (including\nthe first word), and use no separators.</P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">extension MyFancyList&lt;T&gt; on List&lt;T&gt; { \n  // ... \n}\n\nextension SmartIterable&lt;T&gt; on Iterable&lt;T&gt; {\n  // ...\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "camel_case_types",
        "name": "Camel case types",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     name types using UpperCamelCase.\n  </P>\n  <P>Classes and typedefs should capitalize the first letter of each word (including\nthe first word), and use no separators.</P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class SliderMenu {\n  // ...\n}\n\nclass HttpRequest {\n  // ...\n}\n\ntypedef num Adder(num x, num y);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "cascade_invocations",
        "name": "Cascade invocations",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     Use the cascading style when successively invoking methods on the same\nreference.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">SomeClass someReference = SomeClass();\nsomeReference.firstMethod();\nsomeReference.secondMethod();\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">SomeClass someReference = SomeClass();\n...\nsomeReference.firstMethod();\nsomeReference.aProperty = value;\nsomeReference.secondMethod();\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">SomeClass someReference = SomeClass()\n    ..firstMethod()\n    ..aProperty = value\n    ..secondMethod();\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">SomeClass someReference = SomeClass();\n...\nsomeReference\n    ..firstMethod()\n    ..aProperty = value\n    ..secondMethod();\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "cast_nullable_to_non_nullable",
        "name": "Cast nullable to non nullable",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     cast a nullable value to a non nullable type. This hides a null check\nand most of the time it is not what is expected.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {}\nclass B extends A {}\n\nA? a;\nvar v = a as B;\nvar v = a as A;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {}\nclass B extends A {}\n\nA? a;\nvar v = a! as B;\nvar v = a!;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "5min",
        "active": false
    },
    {
        "key": "combinators_ordering",
        "name": "Combinators ordering",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     sort combinator names alphabetically.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'a.dart' show B, A hide D, C;\nexport 'a.dart' show B, A hide D, C;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'a.dart' show A, B hide C, D;\nexport 'a.dart' show A, B hide C, D;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "conditional_uri_does_not_exist",
        "name": "Conditional uri does not exist",
        "severity": "BLOCKER",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     reference files that do not exist in conditional imports.\n  </P>\n  <P>Code may fail at runtime if the condition evaluates such that the missing file\nneeds to be imported.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'file_that_does_exist.dart'\n  if (condition) 'file_that_does_not_exist.dart';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'file_that_does_exist.dart'\n  if (condition) 'file_that_also_does_exist.dart';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "5min",
        "active": false
    },
    {
        "key": "constant_identifier_names",
        "name": "Constant identifier names",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using lowerCamelCase for constant names.\n  </P>\n  <P>\n    In new code, use \n    <CODE>lowerCamelCase</CODE>\n     for constant variables, including enum values.\n  </P>\n  <P>\n    In existing code that uses \n    <CODE>ALL_CAPS_WITH_UNDERSCORES</CODE>\n     for constants, you may\ncontinue to use all caps to stay consistent.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const PI = 3.14;\nconst kDefaultTimeout = 1000;\nfinal URL_SCHEME = RegExp('^([a-z]+):');\n\nclass Dice {\n  static final NUMBER_GENERATOR = Random();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const pi = 3.14;\nconst defaultTimeout = 1000;\nfinal urlScheme = RegExp('^([a-z]+):');\n\nclass Dice {\n  static final numberGenerator = Random();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "curly_braces_in_flow_control_structures",
        "name": "Curly braces in flow control structures",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use curly braces for all flow control structures.\n  </P>\n  <P>\n    Doing so avoids the \n    <A href=\"https://en.wikipedia.org/wiki/Dangling_else\">dangling else</A>\n    problem.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (overflowChars != other.overflowChars)\n  return overflowChars &lt; other.overflowChars;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (isWeekDay) {\n  print('Bike to work!');\n} else {\n  print('Go dancing or read a book!');\n}\n</CODE>\n  </PRE>\n  <P>\n    There is one exception to this: an \n    <CODE>if</CODE>\n     statement with no \n    <CODE>else</CODE>\n     clause where\nthe entire \n    <CODE>if</CODE>\n     statement and the then body all fit in one line. In that case,\nyou may leave off the braces if you prefer:\n  </P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (arg == null) return defaultValue;\n</CODE>\n  </PRE>\n  <P>If the body wraps to the next line, though, use braces:</P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (overflowChars != other.overflowChars) {\n  return overflowChars &lt; other.overflowChars;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "dangling_library_doc_comments",
        "name": "Dangling library doc comments",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Attach library doc comments (with \n    <CODE>///</CODE>\n    ) to library directives, rather than\nleaving them dangling near the top of a library.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">/// This is a great library.\nimport 'package:math';\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">/// This is a great library.\n\nclass C {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">/// This is a great library.\nlibrary;\n\nimport 'package:math';\n\nclass C {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>NOTE:</STRONG>\n     An unnamed library, like \n    <CODE>library;</CODE>\n     above, is only supported in Dart\n2.19 and later. Code which might run in earlier versions of Dart will need to\nprovide a name in the \n    <CODE>library</CODE>\n     directive.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "deprecated_consistency",
        "name": "Deprecated consistency",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     apply \n    <CODE>@Deprecated()</CODE>\n     consistently:\n  </P>\n  <UL>\n    <LI>if a class is deprecated, its constructors should also be deprecated.</LI>\n    <LI>if a field is deprecated, the constructor parameter pointing to it should also\nbe deprecated.</LI>\n    <LI>if a constructor parameter pointing to a field is deprecated, the field should\nalso be deprecated.</LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@deprecated\nclass A {\n  A();\n}\n\nclass B {\n  B({this.field});\n  @deprecated\n  Object field;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@deprecated\nclass A {\n  @deprecated\n  A();\n}\n\nclass B {\n  B({@deprecated this.field});\n  @deprecated\n  Object field;\n}\n\nclass C extends B {\n  C({@deprecated super.field});\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "directives_ordering",
        "name": "Directives ordering",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     follow the directive ordering conventions in\n\n    <A href=\"https://dart.dev/guides/language/effective-dart/style#ordering\">Effective Dart</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     place \n    <CODE>dart:</CODE>\n     imports before other imports.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:bar/bar.dart';\nimport 'package:foo/foo.dart';\n\nimport 'dart:async';  // LINT\nimport 'dart:html';  // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'dart:html';  // OK\nimport 'package:bar/bar.dart';\n\nimport 'dart:async';  // LINT\nimport 'package:foo/foo.dart';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'dart:async';  // OK\nimport 'dart:html';  // OK\n\nimport 'package:bar/bar.dart';\nimport 'package:foo/foo.dart';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>DO</STRONG>\n     place \n    <CODE>package:</CODE>\n     imports before relative imports.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'a.dart';\nimport 'b.dart';\n\nimport 'package:bar/bar.dart';  // LINT\nimport 'package:foo/foo.dart';  // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:bar/bar.dart';  // OK\nimport 'a.dart';\n\nimport 'package:foo/foo.dart';  // LINT\nimport 'b.dart';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:bar/bar.dart';  // OK\nimport 'package:foo/foo.dart';  // OK\n\nimport 'a.dart';\nimport 'b.dart';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>DO</STRONG>\n     specify exports in a separate section after all imports.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'src/error.dart';\nexport 'src/error.dart'; // LINT\nimport 'src/string_source.dart';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'src/error.dart';\nimport 'src/string_source.dart';\n\nexport 'src/error.dart'; // OK\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>DO</STRONG>\n     sort sections alphabetically.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:foo/bar.dart'; // OK\nimport 'package:bar/bar.dart'; // LINT\n\nimport 'a/b.dart'; // OK\nimport 'a.dart'; // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:bar/bar.dart'; // OK\nimport 'package:foo/bar.dart'; // OK\n\nimport 'a.dart'; // OK\nimport 'a/b.dart'; // OK\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "do_not_use_environment",
        "name": "Do not use environment",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Using values derived from the environment at compile-time, creates\nhidden global state and makes applications hard to understand and maintain.</P>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use \n    <CODE>fromEnvironment</CODE>\n     or \n    <CODE>hasEnvironment</CODE>\n     factory constructors.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const loggingLevel =\n  bool.hasEnvironment('logging') ? String.fromEnvironment('logging') : null;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "empty_catches",
        "name": "Empty catches",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     empty catch blocks.\n  </P>\n  <P>\n    In general, empty catch blocks should be avoided.  In cases where they are\nintended, a comment should be provided to explain why exceptions are being\ncaught and suppressed.  Alternatively, the exception identifier can be named with\nunderscores (e.g., \n    <CODE>_</CODE>\n    ) to indicate that we intend to skip it.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">try {\n  ...\n} catch(exception) { }\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">try {\n  ...\n} catch(e) {\n  // ignored, really.\n}\n\n// Alternatively:\ntry {\n  ...\n} catch(_) { }\n\n// Better still:\ntry {\n  ...\n} catch(e) {\n  doSomething(e);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "empty_constructor_bodies",
        "name": "Empty constructor bodies",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     use \n    <CODE>;</CODE>\n     instead of \n    <CODE>{}</CODE>\n     for empty constructor bodies.\n  </P>\n  <P>In Dart, a constructor with an empty body can be terminated with just a\nsemicolon.  This is required for const constructors.  For consistency and\nbrevity, other constructors should also do this.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  int x, y;\n  Point(this.x, this.y) {}\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  int x, y;\n  Point(this.x, this.y);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "enable_null_safety",
        "name": "Enable null safety",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P style=\"font-size:30px\">\n    <STRONG>Unsupported since Dart language version 2.12.0.</STRONG>\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     use sound null safety, by not specifying a dart version lower than \n    <CODE>2.12</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// @dart=2.8\na() {\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">b() {\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "eol_at_end_of_file",
        "name": "Eol at end of file",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     put a single newline at the end of non-empty files.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">a {\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">b {\n}\n    &lt;-- newline\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "exhaustive_cases",
        "name": "Exhaustive cases",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>Switching on instances of enum-like classes should be exhaustive.</P>\n  <P>Enum-like classes are defined as concrete (non-abstract) classes that have:</P>\n  <UL>\n    <LI>only private non-factory constructors</LI>\n    <LI>two or more static const fields whose type is the enclosing class and</LI>\n    <LI>no subclasses of the class in the defining library</LI>\n  </UL>\n  <P>\n    <STRONG>DO</STRONG>\n     define case clauses for all constants in enum-like classes.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class EnumLike {\n  final int i;\n  const EnumLike._(this.i);\n\n  static const e = EnumLike._(1);\n  static const f = EnumLike._(2);\n  static const g = EnumLike._(3);\n}\n\nvoid bad(EnumLike e) {\n  // Missing case.\n  switch(e) { // LINT\n    case EnumLike.e :\n      print('e');\n      break;\n    case EnumLike.f :\n      print('f');\n      break;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class EnumLike {\n  final int i;\n  const EnumLike._(this.i);\n\n  static const e = EnumLike._(1);\n  static const f = EnumLike._(2);\n  static const g = EnumLike._(3);\n}\n\nvoid ok(EnumLike e) {\n  // All cases covered.\n  switch(e) { // OK\n    case EnumLike.e :\n      print('e');\n      break;\n    case EnumLike.f :\n      print('f');\n      break;\n    case EnumLike.g :\n      print('g');\n      break;\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "file_names",
        "name": "File names",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     name source files using \n    <CODE>lowercase_with_underscores</CODE>\n    .\n  </P>\n  <P>Some file systems are not case-sensitive, so many projects require filenames to\nbe all lowercase. Using a separating character allows names to still be readable\nin that form. Using underscores as the separator ensures that the name is still\na valid Dart identifier, which may be helpful if the language later supports\nsymbolic imports.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <UL>\n    <LI>\n      <CODE>SliderMenu.dart</CODE>\n    </LI>\n    <LI>\n      <CODE>filesystem.dart</CODE>\n    </LI>\n    <LI>\n      <CODE>file-system.dart</CODE>\n    </LI>\n  </UL>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <UL>\n    <LI>\n      <CODE>slider_menu.dart</CODE>\n    </LI>\n    <LI>\n      <CODE>file_system.dart</CODE>\n    </LI>\n  </UL>\n  <P>\n    Files without a strict \n    <CODE>.dart</CODE>\n     extension are ignored.  For example:\n  </P>\n  <P>\n    <STRONG>OK:</STRONG>\n  </P>\n  <UL>\n    <LI>\n      <CODE>file-system.g.dart</CODE>\n    </LI>\n    <LI>\n      <CODE>SliderMenu.css.dart</CODE>\n    </LI>\n  </UL>\n  <P>\n    The lint \n    <CODE>library_names</CODE>\n     can be used to enforce the same kind of naming on the\nlibrary.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "flutter_style_todos",
        "name": "Flutter style todos",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use Flutter TODO format.\n  </P>\n  <P>\n    From the \n    <A href=\"https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#comments\">Flutter docs</A>\n    :\n  </P>\n  <BLOCKQUOTE>\n    <P>TODOs should include the string TODO in all caps, followed by the GitHub username of the person with the best context about the problem referenced by the TODO in parenthesis. A TODO is not a commitment that the person referenced will fix the problem, it is intended to be the person with enough context to explain the problem. Thus, when you create a TODO, it is almost always your username that is given.</P>\n  </BLOCKQUOTE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// TODO(username): message.\n// TODO(username): message, https://URL-to-issue.\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "implementation_imports",
        "name": "Implementation imports",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    From the the \n    <A href=\"https://dart.dev/tools/pub/package-layout#implementation-files\">pub package layout doc</A>\n    :\n  </P>\n  <P>\n    <STRONG>DON'T</STRONG>\n     import implementation files from another package.\n  </P>\n  <P>\n    The libraries inside \n    <CODE>lib</CODE>\n     are publicly visible: other packages are free to\nimport them.  But much of a package's code is internal implementation libraries\nthat should only be imported and used by the package itself.  Those go inside a\nsubdirectory of \n    <CODE>lib</CODE>\n     called \n    <CODE>src</CODE>\n    .  You can create subdirectories in there if\nit helps you organize things.\n  </P>\n  <P>\n    You are free to import libraries that live in \n    <CODE>lib/src</CODE>\n     from within other Dart\ncode in the same package (like other libraries in \n    <CODE>lib</CODE>\n    , scripts in \n    <CODE>bin</CODE>\n    ,\nand tests) but you should never import from another package's \n    <CODE>lib/src</CODE>\n    directory.  Those files are not part of the package's public API, and they\nmight change in ways that could break your code.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// In 'road_runner'\nimport 'package:acme/src/internals.dart';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "implicit_call_tearoffs",
        "name": "Implicit call tearoffs",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n    Explicitly tear off \n    <CODE>.call</CODE>\n     methods from objects when assigning to a Function\ntype. There is less magic with an explicit tear off. Future language versions\nmay remove the implicit call tear off.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Callable {\n  void call() {}\n}\nvoid callIt(void Function() f) {\n  f();\n}\n\ncallIt(Callable());\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Callable {\n  void call() {}\n}\nvoid callIt(void Function() f) {\n  f();\n}\n\ncallIt(Callable().call);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "join_return_with_assignment",
        "name": "Join return with assignment",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     join return statement with assignment when possible.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  B _lazyInstance;\n  static B get instance {\n    _lazyInstance ??= B(); // LINT\n    return _lazyInstance;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  B _lazyInstance;\n  static B get instance =&gt; _lazyInstance ??= B();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "leading_newlines_in_multiline_strings",
        "name": "Leading newlines in multiline strings",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Multiline strings are easier to read when they start with a newline (a newline\nstarting a multiline string is ignored).</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s1 = '''{\n  \"a\": 1,\n  \"b\": 2\n}''';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s1 = '''\n{\n  \"a\": 1,\n  \"b\": 2\n}''';\n\nvar s2 = '''This one-liner multiline string is ok. It usually allows to escape both ' and \" in the string.''';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "library_annotations",
        "name": "Library annotations",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Attach library annotations to library directives, rather than\nsome other library-level element.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@TestOn('browser')\n\nimport 'package:test/test.dart';\n\nvoid main() {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@TestOn('browser')\nlibrary;\n\nimport 'package:test/test.dart';\n\nvoid main() {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>NOTE:</STRONG>\n     An unnamed library, like \n    <CODE>library;</CODE>\n     above, is only supported in Dart\n2.19 and later. Code which might run in earlier versions of Dart will need to\nprovide a name in the \n    <CODE>library</CODE>\n     directive.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "library_names",
        "name": "Library names",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     name libraries using \n    <CODE>lowercase_with_underscores</CODE>\n    .\n  </P>\n  <P>Some file systems are not case-sensitive, so many projects require filenames to\nbe all lowercase. Using a separating character allows names to still be readable\nin that form. Using underscores as the separator ensures that the name is still\na valid Dart identifier, which may be helpful if the language later supports\nsymbolic imports.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">library peg-parser;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">library peg_parser;\n</CODE>\n  </PRE>\n  <P>\n    The lint \n    <CODE>file_names</CODE>\n     can be used to enforce the same kind of naming on the\nfile.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "library_prefixes",
        "name": "Library prefixes",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use \n    <CODE>lowercase_with_underscores</CODE>\n     when specifying a library prefix.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'dart:math' as Math;\nimport 'dart:json' as JSON;\nimport 'package:js/js.dart' as JS;\nimport 'package:javascript_utils/javascript_utils.dart' as jsUtils;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'dart:math' as math;\nimport 'dart:json' as json;\nimport 'package:js/js.dart' as js;\nimport 'package:javascript_utils/javascript_utils.dart' as js_utils;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "library_private_types_in_public_api",
        "name": "Library private types in public api",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using library private types in public APIs.\n  </P>\n  <P>For the purposes of this lint, a public API is considered to be any top-level or\nmember declaration unless the declaration is library private or contained in a\ndeclaration that's library private. The following uses of types are checked:</P>\n  <UL>\n    <LI>the return type of a function or method,</LI>\n    <LI>the type of any parameter of a function or method,</LI>\n    <LI>the bound of a type parameter to any function, method, class, mixin,\nextension's extended type, or type alias,</LI>\n    <LI>the type of any top level variable or field,</LI>\n    <LI>\n      any type used in the declaration of a type alias (for example\n\n      <CODE>typedef F = _Private Function();</CODE>\n      ), or\n    </LI>\n    <LI>\n      any type used in the \n      <CODE>on</CODE>\n       clause of an extension or a mixin\n    </LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">f(_Private p) { ... }\nclass _Private {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">f(String s) { ... }\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "15min",
        "active": true
    },
    {
        "key": "lines_longer_than_80_chars",
        "name": "Lines longer than 80 chars",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     lines longer than 80 characters\n  </P>\n  <P>Readability studies show that long lines of text are harder to read because your\neye has to travel farther when moving to the beginning of the next line. This is\nwhy newspapers and magazines use multiple columns of text.</P>\n  <P>\n    If you really find yourself wanting lines longer than 80 characters, our\nexperience is that your code is likely too verbose and could be a little more\ncompact. The main offender is usually \n    <CODE>VeryLongCamelCaseClassNames</CODE>\n    . Ask\nyourself, \u201cDoes each word in that type name tell me something critical or\nprevent a name collision?\u201d If not, consider omitting it.\n  </P>\n  <P>\n    Note that \n    <CODE>dart format</CODE>\n     does 99% of this for you, but the last 1% is you. It\ndoes not split long string literals to fit in 80 columns, so you have to do\nthat manually.\n  </P>\n  <P>We make an exception for URIs and file paths. When those occur in comments or\nstrings (usually in imports and exports), they may remain on a single line even\nif they go over the line limit. This makes it easier to search source files for\na given path.</P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "matching_super_parameters",
        "name": "Matching super parameters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use super parameter names that match their corresponding super\nconstructor's parameter names.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Rectangle {\n  final int width;\n  final int height;\n  \n  Rectangle(this.width, this.height);\n}\n\nclass ColoredRectangle extends Rectangle {\n  final Color color;\n  \n  ColoredRectangle(\n    this.color,\n    super.height, // Bad, actually corresponds to the `width` parameter.\n    super.width, // Bad, actually corresponds to the `height` parameter.\n  ); \n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Rectangle {\n  final int width;\n  final int height;\n  \n  Rectangle(this.width, this.height);\n}\n\nclass ColoredRectangle extends Rectangle {\n  final Color color;\n  \n  ColoredRectangle(\n    this.color,\n    super.width,\n    super.height, \n  ); \n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "missing_whitespace_between_adjacent_strings",
        "name": "Missing whitespace between adjacent strings",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Add a trailing whitespace to prevent missing whitespace between adjacent\nstrings.</P>\n  <P>With long text split across adjacent strings it's easy to forget a whitespace\nbetween strings.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed'\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed '\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "no_default_cases",
        "name": "No default cases",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    Switches on enums and enum-like classes should not use a \n    <CODE>default</CODE>\n     clause.\n  </P>\n  <P>Enum-like classes are defined as concrete (non-abstract) classes that have:</P>\n  <UL>\n    <LI>only private non-factory constructors</LI>\n    <LI>two or more static const fields whose type is the enclosing class and</LI>\n    <LI>no subclasses of the class in the defining library</LI>\n  </UL>\n  <P>\n    <STRONG>DO</STRONG>\n     define default behavior outside switch statements.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">  switch (testEnum) {\n    case TestEnum.A:\n      return '123';\n    case TestEnum.B:\n      return 'abc';\n    default:\n      return null;\n  }\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">  switch (testEnum) {\n    case TestEnum.A:\n      return '123';\n    case TestEnum.B:\n      return 'abc';\n  }\n  // Default here.\n  return null;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "no_leading_underscores_for_library_prefixes",
        "name": "No leading underscores for library prefixes",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use a leading underscore for library prefixes.\nThere is no concept of \"private\" for library prefixes. When one of those has a\nname that starts with an underscore, it sends a confusing signal to the reader.\nTo avoid that, don't use leading underscores in those names.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'dart:core' as _core;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'dart:core' as core;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "no_leading_underscores_for_local_identifiers",
        "name": "No leading underscores for local identifiers",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use a leading underscore for identifiers that aren't private. Dart\nuses a leading underscore in an identifier to mark members and top-level\ndeclarations as private. This trains users to associate a leading underscore\nwith one of those kinds of declarations. They see \n    <CODE>_</CODE>\n     and  think \"private\".\nThere is no concept of \"private\" for local variables or parameters.  When one of\nthose has a name that starts with an underscore, it sends a confusing signal to\nthe reader. To avoid that, don't use leading underscores in those names.\n  </P>\n  <P>\n    <STRONG>EXCEPTION:</STRONG>\n    : An unused parameter can be named \n    <CODE>_</CODE>\n    , \n    <CODE>__</CODE>\n    , \n    <CODE>___</CODE>\n    , etc.  This is\ncommon practice in callbacks where you are passed a value but you don't need\nto use it. Giving it a name that consists solely of underscores is the idiomatic\nway to indicate that the value isn't used.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void print(String _name) {\n  var _size = _name.length;\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void print(String name) {\n  var size = name.length;\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>OK:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">[1,2,3].map((_) =&gt; print('Hello'));\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "no_literal_bool_comparisons",
        "name": "No literal bool comparisons",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From \n    <A href=\"https://dart.dev/guides/language/effective-dart/usage#dont-use-true-or-false-in-equality-operations\">Effective Dart</A>\n    :\n  </P>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use \n    <CODE>true</CODE>\n     or \n    <CODE>false</CODE>\n     in equality operations.\n  </P>\n  <P>\n    This lint applies only if the expression is of a non-nullable \n    <CODE>bool</CODE>\n     type.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (someBool == true) {\n}\nwhile (someBool == false) {\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (someBool) {\n}\nwhile (!someBool) {\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "no_runtimeType_toString",
        "name": "No runtimeType toString",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    Calling \n    <CODE>toString</CODE>\n     on a runtime type is a non-trivial operation that can\nnegatively impact performance. It's better to avoid it.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  String toString() =&gt; '$runtimeType()';\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  String toString() =&gt; 'A()';\n}\n</CODE>\n  </PRE>\n  <P>This lint has some exceptions where performance is not a problem or where real\ntype information is more important than performance:</P>\n  <UL>\n    <LI>in assertion</LI>\n    <LI>in throw expressions</LI>\n    <LI>in catch clauses</LI>\n    <LI>in mixin declaration</LI>\n    <LI>in abstract class</LI>\n  </UL>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "non_constant_identifier_names",
        "name": "Non constant identifier names",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     name non-constant identifiers using lowerCamelCase.\n  </P>\n  <P>Class members, top-level definitions, variables, parameters, named parameters\nand named constructors should capitalize the first letter of each word\nexcept the first word, and use no separators.</P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var item;\n\nHttpRequest httpRequest;\n\nalign(clearItems) {\n  // ...\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "noop_primitive_operations",
        "name": "Noop primitive operations",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>Some operations on primitive types are idempotent and can be removed.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">doubleValue.toDouble();\n\nintValue.toInt();\nintValue.round();\nintValue.ceil();\nintValue.floor();\nintValue.truncate();\n\nstring.toString();\nstring = 'hello\\n'\n    'world\\n'\n    ''; // useless empty string\n\n'string with ${x.toString()}';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "null_check_on_nullable_type_parameter",
        "name": "Null check on nullable type parameter",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use null check on a potentially nullable type parameter.\n  </P>\n  <P>\n    Given a generic type parameter \n    <CODE>T</CODE>\n     which has a nullable bound (e.g. the default\nbound of \n    <CODE>Object?</CODE>\n    ), it is very easy to introduce erroneous null checks when\nworking with a variable of type \n    <CODE>T?</CODE>\n    . Specifically, it is not uncommon to have\n\n    <CODE>T? x;</CODE>\n     and want to assert that \n    <CODE>x</CODE>\n     has been set to a valid value of type \n    <CODE>T</CODE>\n    .\nA common mistake is to do so using \n    <CODE>x!</CODE>\n    . This is almost always incorrect, since\nif \n    <CODE>T</CODE>\n     is a nullable type, \n    <CODE>x</CODE>\n     may validly hold \n    <CODE>null</CODE>\n     as a value of type \n    <CODE>T</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">T run&lt;T&gt;(T callback()) {\n  T? result;\n   (() { result = callback(); })();\n  return result!;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">T run&lt;T&gt;(T callback()) {\n  T? result;\n   (() { result = callback(); })();\n  return result as T;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "null_closures",
        "name": "Null closures",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     pass \n    <CODE>null</CODE>\n     as an argument where a closure is expected.\n  </P>\n  <P>\n    Often a closure that is passed to a method will only be called conditionally,\nso that tests and \"happy path\" production calls do not reveal that \n    <CODE>null</CODE>\n     will\nresult in an exception being thrown.\n  </P>\n  <P>This rule only catches null literals being passed where closures are expected\nin the following locations:</P>\n  <H4>Constructors</H4>\n  <UL>\n    <LI>\n      From \n      <CODE>dart:async</CODE>\n      <UL>\n        <LI>\n          <CODE>Future</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Future.microtask</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Future.sync</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Timer</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Timer.periodic</CODE>\n           at the 1st positional parameter\n        </LI>\n      </UL>\n    </LI>\n    <LI>\n      From \n      <CODE>dart:core</CODE>\n      <UL>\n        <LI>\n          <CODE>List.generate</CODE>\n           at the 1st positional parameter\n        </LI>\n      </UL>\n    </LI>\n  </UL>\n  <H4>Static functions</H4>\n  <UL>\n    <LI>\n      From \n      <CODE>dart:async</CODE>\n      <UL>\n        <LI>\n          <CODE>scheduleMicrotask</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Future.doWhile</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Future.forEach</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Future.wait</CODE>\n           at the named parameter \n          <CODE>cleanup</CODE>\n        </LI>\n        <LI>\n          <CODE>Timer.run</CODE>\n           at the 0th positional parameter\n        </LI>\n      </UL>\n    </LI>\n  </UL>\n  <H4>Instance methods</H4>\n  <UL>\n    <LI>\n      From \n      <CODE>dart:async</CODE>\n      <UL>\n        <LI>\n          <CODE>Future.then</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Future.complete</CODE>\n           at the 0th positional parameter\n        </LI>\n      </UL>\n    </LI>\n    <LI>\n      From \n      <CODE>dart:collection</CODE>\n      <UL>\n        <LI>\n          <CODE>Queue.removeWhere</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>`Queue.retain</LI>\n        <LI>\n          <CODE>Iterable.firstWhere</CODE>\n           at the 0th positional parameter, and the named\nparameter \n          <CODE>orElse</CODE>\n        </LI>\n        <LI>\n          <CODE>Iterable.forEach</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Iterable.fold</CODE>\n           at the 1st positional parameter\n        </LI>\n        <LI>\n          <CODE>Iterable.lastWhere</CODE>\n           at the 0th positional parameter, and the named\nparameter \n          <CODE>orElse</CODE>\n        </LI>\n        <LI>\n          <CODE>Iterable.map</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Iterable.reduce</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Iterable.singleWhere</CODE>\n           at the 0th positional parameter, and the named\nparameter \n          <CODE>orElse</CODE>\n        </LI>\n        <LI>\n          <CODE>Iterable.skipWhile</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Iterable.takeWhile</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>Iterable.where</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>List.removeWhere</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>List.retainWhere</CODE>\n           at the 0th positional parameter\n        </LI>\n        <LI>\n          <CODE>String.replaceAllMapped</CODE>\n           at the 1st positional parameter\n        </LI>\n        <LI>\n          <CODE>String.replaceFirstMapped</CODE>\n           at the 1st positional parameter\n        </LI>\n        <LI>\n          <CODE>String.splitMapJoin</CODE>\n           at the named parameters \n          <CODE>onMatch</CODE>\n           and \n          <CODE>onNonMatch</CODE>\n        </LI>\n      </UL>\n    </LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">[1, 3, 5].firstWhere((e) =&gt; e.isOdd, orElse: null);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">[1, 3, 5].firstWhere((e) =&gt; e.isOdd, orElse: () =&gt; null);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "omit_local_variable_types",
        "name": "Omit local variable types",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     redundantly type annotate initialized local variables.\n  </P>\n  <P>\n    Local variables, especially in modern code where functions tend to be small,\nhave very little scope. Omitting the type focuses the reader's attention on the\nmore important \n    <EM>name</EM>\n     of the variable and its initialized value.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">List&lt;List&lt;Ingredient&gt;&gt; possibleDesserts(Set&lt;Ingredient&gt; pantry) {\n  List&lt;List&lt;Ingredient&gt;&gt; desserts = &lt;List&lt;Ingredient&gt;&gt;[];\n  for (final List&lt;Ingredient&gt; recipe in cookbook) {\n    if (pantry.containsAll(recipe)) {\n      desserts.add(recipe);\n    }\n  }\n\n  return desserts;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">List&lt;List&lt;Ingredient&gt;&gt; possibleDesserts(Set&lt;Ingredient&gt; pantry) {\n  var desserts = &lt;List&lt;Ingredient&gt;&gt;[];\n  for (final recipe in cookbook) {\n    if (pantry.containsAll(recipe)) {\n      desserts.add(recipe);\n    }\n  }\n\n  return desserts;\n}\n</CODE>\n  </PRE>\n  <P>Sometimes the inferred type is not the type you want the variable to have. For\nexample, you may intend to assign values of other types later. In that case,\nannotate the variable with the type you want.</P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget build(BuildContext context) {\n  Widget result = Text('You won!');\n  if (applyPadding) {\n    result = Padding(padding: EdgeInsets.all(8.0), child: result);\n  }\n  return result;\n}\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"always_specify_types.html\">always_specify_types</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "one_member_abstracts",
        "name": "One member abstracts",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>AVOID</STRONG>\n     defining a one-member abstract class when a simple function will do.\n  </P>\n  <P>\n    Unlike Java, Dart has first-class functions, closures, and a nice light syntax\nfor using them.  If all you need is something like a callback, just use a\nfunction.  If you're defining a class and it only has a single abstract member\nwith a meaningless name like \n    <CODE>call</CODE>\n     or \n    <CODE>invoke</CODE>\n    , there is a good chance\nyou just want a function.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class Predicate {\n  bool test(item);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">typedef Predicate = bool Function(item);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "only_throw_errors",
        "name": "Only throw errors",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     throw only instances of classes that extend \n    <CODE>dart.core.Error</CODE>\n     or\n\n    <CODE>dart.core.Exception</CODE>\n    .\n  </P>\n  <P>\n    Throwing instances that do not extend \n    <CODE>Error</CODE>\n     or \n    <CODE>Exception</CODE>\n     is a bad practice;\ndoing this is usually a hack for something that should be implemented more\nthoroughly.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void throwString() {\n  throw 'hello world!'; // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void throwArgumentError() {\n  Error error = ArgumentError('oh!');\n  throw error; // OK\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "overridden_fields",
        "name": "Overridden fields",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     override fields.\n  </P>\n  <P>Overriding fields is almost always done unintentionally.  Regardless, it is a\nbad practice to do so.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Base {\n  Object field = 'lorem';\n\n  Object something = 'change';\n}\n\nclass Bad1 extends Base {\n  @override\n  final field = 'ipsum'; // LINT\n}\n\nclass Bad2 extends Base {\n  @override\n  Object something = 'done'; // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Base {\n  Object field = 'lorem';\n\n  Object something = 'change';\n}\n\nclass Ok extends Base {\n  Object newField; // OK\n\n  final Object newFinal = 'ignore'; // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class BaseLoggingHandler {\n  Base transformer;\n}\n\nclass LogPrintHandler implements BaseLoggingHandler {\n  @override\n  Derived transformer; // OK\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "package_api_docs",
        "name": "Package api docs",
        "severity": "INFO",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     provide doc comments for all public APIs.\n  </P>\n  <P>\n    As described in the \n    <A href=\"https://dart.dev/tools/pub/package-layout#implementation-files\">pub package layout doc</A>\n    ,\npublic APIs consist in everything in your package's \n    <CODE>lib</CODE>\n     folder, minus\nimplementation files in \n    <CODE>lib/src</CODE>\n    , adding elements explicitly exported with an\n\n    <CODE>export</CODE>\n     directive.\n  </P>\n  <P>\n    For example, given \n    <CODE>lib/foo.dart</CODE>\n    :\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">export 'src/bar.dart' show Bar;\nexport 'src/baz.dart';\n\nclass Foo { }\n\nclass _Foo { }\n</CODE>\n  </PRE>\n  <P>its API includes:</P>\n  <UL>\n    <LI>\n      <CODE>Foo</CODE>\n       (but not \n      <CODE>_Foo</CODE>\n      )\n    </LI>\n    <LI>\n      <CODE>Bar</CODE>\n       (exported) and\n    </LI>\n    <LI>\n      all \n      <EM>public</EM>\n       elements in \n      <CODE>src/baz.dart</CODE>\n    </LI>\n  </UL>\n  <P>\n    All public API members should be documented with \n    <CODE>///</CODE>\n     doc-style comments.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Bar {\n  void bar();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">/// A Foo.\nabstract class Foo {\n  /// Start foo-ing.\n  void start() =&gt; _start();\n\n  _start();\n}\n</CODE>\n  </PRE>\n  <P>\n    Advice for writing good doc comments can be found in the\n\n    <A href=\"https://dart.dev/guides/language/effective-dart/documentation\">Doc Writing Guidelines</A>\n    .\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "10min",
        "active": false
    },
    {
        "key": "package_prefixed_library_names",
        "name": "Package prefixed library names",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     prefix library names with the package name and a dot-separated path.\n  </P>\n  <P>This guideline helps avoid the warnings you get when two libraries have the same\nname.  Here are the rules we recommend:</P>\n  <UL>\n    <LI>Prefix all library names with the package name.</LI>\n    <LI>Make the entry library have the same name as the package.</LI>\n    <LI>For all other libraries in a package, after the package name add the\ndot-separated path to the library's Dart file.</LI>\n    <LI>\n      For libraries under \n      <CODE>lib</CODE>\n      , omit the top directory name.\n    </LI>\n  </UL>\n  <P>\n    For example, say the package name is \n    <CODE>my_package</CODE>\n    .  Here are the library names\nfor various files in the package:\n  </P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// In lib/my_package.dart\nlibrary my_package;\n\n// In lib/other.dart\nlibrary my_package.other;\n\n// In lib/foo/bar.dart\nlibrary my_package.foo.bar;\n\n// In example/foo/bar.dart\nlibrary my_package.example.foo.bar;\n\n// In lib/src/private.dart\nlibrary my_package.src.private;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "parameter_assignments",
        "name": "Parameter assignments",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     assign new values to parameters of methods or functions.\n  </P>\n  <P>\n    Assigning new values to parameters is generally a bad practice unless an\noperator such as \n    <CODE>??=</CODE>\n     is used.  Otherwise, arbitrarily reassigning parameters\nis usually a mistake.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void badFunction(int parameter) { // LINT\n  parameter = 4;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void badFunction(int required, {int optional: 42}) { // LINT\n  optional ??= 8;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void badFunctionPositional(int required, [int optional = 42]) { // LINT\n  optional ??= 8;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  void badMethod(int parameter) { // LINT\n    parameter = 4;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void ok(String parameter) {\n  print(parameter);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void actuallyGood(int required, {int optional}) { // OK\n  optional ??= ...;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void actuallyGoodPositional(int required, [int optional]) { // OK\n  optional ??= ...;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  void ok(String parameter) {\n    print(parameter);\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_adjacent_string_concatenation",
        "name": "Prefer adjacent string concatenation",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use adjacent strings to concatenate string literals.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">raiseAlarm(\n    'ERROR: Parts of the spaceship are on fire. Other ' +\n    'parts are overrun by martians. Unclear which are which.');\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">raiseAlarm(\n    'ERROR: Parts of the spaceship are on fire. Other '\n    'parts are overrun by martians. Unclear which are which.');\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_asserts_in_initializer_lists",
        "name": "Prefer asserts in initializer lists",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     put asserts in initializer lists.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  A(int a) {\n    assert(a != 0);\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  A(int a) : assert(a != 0);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_asserts_with_message",
        "name": "Prefer asserts with message",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    When assertions fail it's not always simple to understand why. Adding a message\nto the \n    <CODE>assert</CODE>\n     helps the developer to understand why the AssertionError occurs.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">f(a) {\n  assert(a != null);\n}\n\nclass A {\n  A(a) : assert(a != null);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">f(a) {\n  assert(a != null, 'a must not be null');\n}\n\nclass A {\n  A(a) : assert(a != null, 'a must not be null');\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_bool_in_asserts",
        "name": "Prefer bool in asserts",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P style=\"font-size:30px\">\n    <STRONG>Unsupported since Dart language version 3.0.0.</STRONG>\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     use a boolean for assert conditions.\n  </P>\n  <P>Not using booleans in assert conditions can lead to code where it isn't clear\nwhat the intention of the assert statement is.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">assert(() {\n  f();\n  return true;\n});\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">assert(() {\n  f();\n  return true;\n}());\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_collection_literals",
        "name": "Prefer collection literals",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use collection literals when possible.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var addresses = Map&lt;String, String&gt;();\nvar uniqueNames = Set&lt;String&gt;();\nvar ids = LinkedHashSet&lt;int&gt;();\nvar coordinates = LinkedHashMap&lt;int, int&gt;();\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var addresses = &lt;String, String&gt;{};\nvar uniqueNames = &lt;String&gt;{};\nvar ids = &lt;int&gt;{};\nvar coordinates = &lt;int, int&gt;{};\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>EXCEPTIONS:</STRONG>\n  </P>\n  <P>\n    There are cases with \n    <CODE>LinkedHashSet</CODE>\n     or \n    <CODE>LinkedHashMap</CODE>\n     where a literal constructor\nwill trigger a type error so those will be excluded from the lint.\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void main() {\n  LinkedHashSet&lt;int&gt; linkedHashSet =  LinkedHashSet.from([1, 2, 3]); // OK\n  LinkedHashMap linkedHashMap = LinkedHashMap(); // OK\n  \n  printSet(LinkedHashSet&lt;int&gt;()); // LINT\n  printHashSet(LinkedHashSet&lt;int&gt;()); // OK\n\n  printMap(LinkedHashMap&lt;int, int&gt;()); // LINT\n  printHashMap(LinkedHashMap&lt;int, int&gt;()); // OK\n}\n\nvoid printSet(Set&lt;int&gt; ids) =&gt; print('$ids!');\nvoid printHashSet(LinkedHashSet&lt;int&gt; ids) =&gt; printSet(ids);\nvoid printMap(Map map) =&gt; print('$map!');\nvoid printHashMap(LinkedHashMap map) =&gt; printMap(map);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_conditional_assignment",
        "name": "Prefer conditional assignment",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using \n    <CODE>??=</CODE>\n     over testing for null.\n  </P>\n  <P>\n    As Dart has the \n    <CODE>??=</CODE>\n     operator, it is advisable to use it where applicable to\nimprove the brevity of your code.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">String get fullName {\n  if (_fullName == null) {\n    _fullName = getFullUserName(this);\n  }\n  return _fullName;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">String get fullName {\n  return _fullName ??= getFullUserName(this);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_const_constructors",
        "name": "Prefer const constructors",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using \n    <CODE>const</CODE>\n     for instantiating constant constructors.\n  </P>\n  <P>If a constructor can be invoked as const to produce a canonicalized instance,\nit's preferable to do so.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  const A();\n}\n\nvoid accessA() {\n  A a = new A();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  const A();\n}\n\nvoid accessA() {\n  A a = const A();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  final int x;\n\n  const A(this.x);\n}\n\nA foo(int x) =&gt; new A(x);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_const_constructors_in_immutables",
        "name": "Prefer const constructors in immutables",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     declaring const constructors on \n    <CODE>@immutable</CODE>\n     classes.\n  </P>\n  <P>If a class is immutable, it is usually a good idea to make its constructor a\nconst constructor.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@immutable\nclass A {\n  final a;\n  A(this.a);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@immutable\nclass A {\n  final a;\n  const A(this.a);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_const_declarations",
        "name": "Prefer const declarations",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using \n    <CODE>const</CODE>\n     for const declarations.\n  </P>\n  <P>Const declarations are more hot-reload friendly and allow to use const\nconstructors if an instantiation references this declaration.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">final o = const &lt;int&gt;[];\n\nclass A {\n  static final o = const &lt;int&gt;[];\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const o = &lt;int&gt;[];\n\nclass A {\n  static const o = &lt;int&gt;[];\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_const_literals_to_create_immutables",
        "name": "Prefer const literals to create immutables",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using \n    <CODE>const</CODE>\n     for instantiating list, map and set literals used as\nparameters in immutable class instantiations.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@immutable\nclass A {\n  A(this.v);\n  final v;\n}\n\nA a1 = new A([1]);\nA a2 = new A({});\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">A a1 = new A(const [1]);\nA a2 = new A(const {});\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_constructors_over_static_methods",
        "name": "Prefer constructors over static methods",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     defining constructors instead of static methods to create instances.\n  </P>\n  <P>In most cases, it makes more sense to use a named constructor rather than a\nstatic method because it makes instantiation clearer.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  num x, y;\n  Point(this.x, this.y);\n  static Point polar(num theta, num radius) {\n    return Point(radius * math.cos(theta),\n        radius * math.sin(theta));\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  num x, y;\n  Point(this.x, this.y);\n  Point.polar(num theta, num radius)\n      : x = radius * math.cos(theta),\n        y = radius * math.sin(theta);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "prefer_contains",
        "name": "Prefer contains",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use \n    <CODE>indexOf</CODE>\n     to see if a collection contains an element.\n  </P>\n  <P>\n    Calling \n    <CODE>indexOf</CODE>\n     to see if a collection contains something is difficult to read\nand may have poor performance.\n  </P>\n  <P>\n    Instead, prefer \n    <CODE>contains</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (lunchBox.indexOf('sandwich') == -1) return 'so hungry...';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (!lunchBox.contains('sandwich')) return 'so hungry...';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_double_quotes",
        "name": "Prefer double quotes",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use double quotes where they wouldn't require additional escapes.\n  </P>\n  <P>That means strings with a double quote may use apostrophes so that the double\nquote isn't escaped (note: we don't lint the other way around, ie, a double\nquoted string with an escaped double quote is not flagged).</P>\n  <P>It's also rare, but possible, to have strings within string interpolations.  In\nthis case, its much more readable to use a single quote somewhere.  So single\nquotes are allowed either within, or containing, an interpolated string literal.\nArguably strings within string interpolations should be its own type of lint.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">useStrings(\n    'should be double quote',\n    r'should be double quote',\n    r'''should be double quotes''')\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">useStrings(\n    \"should be double quote\",\n    r\"should be double quote\",\n    r\"\"\"should be double quotes\"\"\",\n    'ok with \" inside',\n    'nested ${a ? \"strings\" : \"can\"} be wrapped by a double quote',\n    \"and nested ${a ? 'strings' : 'can be double quoted themselves'}\");\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"prefer_single_quotes.html\">prefer_single_quotes</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_equal_for_default_values",
        "name": "Prefer equal for default values",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P style=\"font-size:30px\">\n    <STRONG>Unsupported since Dart language version 3.0.0.</STRONG>\n  </P>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/usage\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     use \n    <CODE>=</CODE>\n     to separate a named parameter from its default value.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">m({a: 1})\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">m({a = 1})\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_expression_function_bodies",
        "name": "Prefer expression function bodies",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>CONSIDER</STRONG>\n     using =&gt; for short members whose body is a single return statement.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">get width {\n  return right - left;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">bool ready(num time) {\n  return minTime == null || minTime &lt;= time;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">containsValue(String value) {\n  return getValues().contains(value);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">get width =&gt; right - left;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">bool ready(num time) =&gt; minTime == null || minTime &lt;= time;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">containsValue(String value) =&gt; getValues().contains(value);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_final_fields",
        "name": "Prefer final fields",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     prefer declaring private fields as final if they are not reassigned later\nin the library.\n  </P>\n  <P>Declaring fields as final when possible is a good practice because it helps\navoid accidental reassignments and allows the compiler to do optimizations.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class BadImmutable {\n  var _label = 'hola mundo! BadImmutable'; // LINT\n  var label = 'hola mundo! BadImmutable'; // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class MultipleMutable {\n  var _label = 'hola mundo! GoodMutable', _offender = 'mumble mumble!'; // LINT\n  var _someOther; // LINT\n\n  MultipleMutable() : _someOther = 5;\n\n  MultipleMutable(this._someOther);\n\n  void changeLabel() {\n    _label= 'hello world! GoodMutable';\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class GoodImmutable {\n  final label = 'hola mundo! BadImmutable', bla = 5; // OK\n  final _label = 'hola mundo! BadImmutable', _bla = 5; // OK\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class GoodMutable {\n  var _label = 'hola mundo! GoodMutable';\n\n  void changeLabel() {\n    _label = 'hello world! GoodMutable';\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class AssignedInAllConstructors {\n  var _label; // LINT\n  AssignedInAllConstructors(this._label);\n  AssignedInAllConstructors.withDefault() : _label = 'Hello';\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class NotAssignedInAllConstructors {\n  var _label; // OK\n  NotAssignedInAllConstructors();\n  NotAssignedInAllConstructors.withDefault() : _label = 'Hello';\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_final_in_for_each",
        "name": "Prefer final in for each",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     prefer declaring for-each loop variables as final if they are not\nreassigned later in the code.\n  </P>\n  <P>Declaring for-each loop variables as final when possible is a good practice\nbecause it helps avoid accidental reassignments and allows the compiler to do\noptimizations.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">for (var element in elements) { // LINT\n  print('Element: $element');\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">for (final element in elements) {\n  print('Element: $element');\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">for (var element in elements) {\n  element = element + element;\n  print('Element: $element');\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_final_locals",
        "name": "Prefer final locals",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     prefer declaring variables as final if they are not reassigned later in\nthe code.\n  </P>\n  <P>Declaring variables as final when possible is a good practice because it helps\navoid accidental reassignments and allows the compiler to do optimizations.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void badMethod() {\n  var label = 'hola mundo! badMethod'; // LINT\n  print(label);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void goodMethod() {\n  final label = 'hola mundo! goodMethod';\n  print(label);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void mutableCase() {\n  var label = 'hola mundo! mutableCase';\n  print(label);\n  label = 'hello world';\n  print(label);\n}\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"unnecessary_final.html\">unnecessary_final</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_final_parameters",
        "name": "Prefer final parameters",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     prefer declaring parameters as final if they are not reassigned in\nthe function body.\n  </P>\n  <P>Declaring parameters as final when possible is a good practice because it helps\navoid accidental reassignments.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void badParameter(String label) { // LINT\n  print(label);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void goodParameter(final String label) { // OK\n  print(label);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void badExpression(int value) =&gt; print(value); // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void goodExpression(final int value) =&gt; print(value); // OK\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">[1, 4, 6, 8].forEach((value) =&gt; print(value + 2)); // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">[1, 4, 6, 8].forEach((final value) =&gt; print(value + 2)); // OK\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void mutableParameter(String label) { // OK\n  print(label);\n  label = 'Hello Linter!';\n  print(label);\n}\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"unnecessary_final.html\">unnecessary_final</A>\n    , \n    <A href=\"avoid_final_parameters.html\">avoid_final_parameters</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_for_elements_to_map_fromIterable",
        "name": "Prefer for elements to map fromIterable",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>When building maps from iterables, it is preferable to use 'for' elements.</P>\n  <P>Using 'for' elements brings several benefits including:</P>\n  <UL>\n    <LI>Performance</LI>\n    <LI>Flexibility</LI>\n    <LI>Readability</LI>\n    <LI>Improved type inference</LI>\n    <LI>Improved interaction with null safety</LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Map&lt;String, WidgetBuilder&gt;.fromIterable(\n  kAllGalleryDemos,\n  key: (demo) =&gt; '${demo.routeName}',\n  value: (demo) =&gt; demo.buildRoute,\n);\n\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">return {\n  for (var demo in kAllGalleryDemos)\n    '${demo.routeName}': demo.buildRoute,\n};\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// Map&lt;int, Student&gt; is not required, type is inferred automatically.\nfinal pizzaRecipients = {\n  ...studentLeaders,\n  for (var student in classG)\n    if (student.isPassing) student.id: student,\n};\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "prefer_foreach",
        "name": "Prefer foreach",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use \n    <CODE>forEach</CODE>\n     if you are only going to apply a function or a method\nto all the elements of an iterable.\n  </P>\n  <P>\n    Using \n    <CODE>forEach</CODE>\n     when you are only going to apply a function or method to all\nelements of an iterable is a good practice because it makes your code more\nterse.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">for (final key in map.keys.toList()) {\n  map.remove(key);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">map.keys.toList().forEach(map.remove);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>NOTE:</STRONG>\n     Replacing a for each statement with a forEach call may change the\nbehavior in the case where there are side-effects on the iterable itself.\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">for (final v in myList) {\n  foo().f(v); // This code invokes foo() many times.\n}\n\nmyList.forEach(foo().f); // But this one invokes foo() just once.\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_function_declarations_over_variables",
        "name": "Prefer function declarations over variables",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use a function declaration to bind a function to a name.\n  </P>\n  <P>As Dart allows local function declarations, it is a good practice to use them in\nthe place of function literals.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void main() {\n  var localFunction = () {\n    ...\n  };\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void main() {\n  localFunction() {\n    ...\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_generic_function_type_aliases",
        "name": "Prefer generic function type aliases",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     generic function type aliases.\n  </P>\n  <P>\n    With the introduction of generic functions, function type aliases\n(\n    <CODE>typedef void F()</CODE>\n    ) couldn't express all of the possible kinds of\nparameterization that users might want to express. Generic function type aliases\n(\n    <CODE>typedef F = void Function()</CODE>\n    ) fixed that issue.\n  </P>\n  <P>For consistency and readability reasons, it's better to only use one syntax and\nthus prefer generic function type aliases.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">typedef void F();\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">typedef F = void Function();\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "prefer_if_elements_to_conditional_expressions",
        "name": "Prefer if elements to conditional expressions",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    When building collections, it is preferable to use \n    <CODE>if</CODE>\n     elements rather than\nconditionals.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var list = ['a', 'b', condition ? 'c' : null].where((e) =&gt; e != null).toList();\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var list = ['a', 'b', if (condition) 'c'];\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_if_null_operators",
        "name": "Prefer if null operators",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using if null operators instead of null checks in conditional\nexpressions.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">v = a == null ? b : a;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">v = a ?? b;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_initializing_formals",
        "name": "Prefer initializing formals",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use initializing formals when possible.\n  </P>\n  <P>Using initializing formals when possible makes your code more terse.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  num x, y;\n  Point(num x, num y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  num x, y;\n  Point(this.x, this.y);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  num x, y;\n  Point({num x, num y}) {\n    this.x = x;\n    this.y = y;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  num x, y;\n  Point({this.x, this.y});\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>NOTE:</STRONG>\n    This rule will not generate a lint for named parameters unless the parameter\nname and the field name are the same. The reason for this is that resolving\nsuch a lint would require either renaming the field or renaming the parameter,\nand both of those actions would potentially be a breaking change. For example,\nthe following will not generate a lint:\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  bool isEnabled;\n  Point({bool enabled}) {\n    this.isEnabled = enabled; // OK\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>NOTE:</STRONG>\n    Also note that it is possible to enforce a type that is stricter than the\ninitialized field with an initializing formal parameter.  In the following\nexample the unnamed \n    <CODE>Bid</CODE>\n     constructor requires a non-null \n    <CODE>int</CODE>\n     despite\n\n    <CODE>amount</CODE>\n     being declared nullable (\n    <CODE>int?</CODE>\n    ).\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Bid {\n final int? amount;\n Bid(int this.amount);\n Bid.pass() : amount = null;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_inlined_adds",
        "name": "Prefer inlined adds",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Declare elements in list literals inline, rather than using \n    <CODE>add</CODE>\n     and\n\n    <CODE>addAll</CODE>\n     methods where possible.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var l = ['a']..add('b')..add('c');\nvar l2 = ['a']..addAll(['b', 'c']);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var l = ['a', 'b', 'c'];\nvar l2 = ['a', 'b', 'c'];\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_int_literals",
        "name": "Prefer int literals",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use int literals rather than the corresponding double literal.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const double myDouble = 8.0;\nfinal anotherDouble = myDouble + 7.0e2;\nmain() {\n  someMethod(6.0);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const double myDouble = 8;\nfinal anotherDouble = myDouble + 700;\nmain() {\n  someMethod(6);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_interpolation_to_compose_strings",
        "name": "Prefer interpolation to compose strings",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using interpolation to compose strings and values.\n  </P>\n  <P>Using interpolation when composing strings and values is usually easier to write\nand read than concatenation.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">'Hello, ' + person.name + ' from ' + person.city + '.';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">'Hello, ${person.name} from ${person.city}.'\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_is_empty",
        "name": "Prefer is empty",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use \n    <CODE>length</CODE>\n     to see if a collection is empty.\n  </P>\n  <P>\n    The \n    <CODE>Iterable</CODE>\n     contract does not require that a collection know its length or be\nable to provide it in constant time.  Calling \n    <CODE>length</CODE>\n     just to see if the\ncollection contains anything can be painfully slow.\n  </P>\n  <P>\n    Instead, there are faster and more readable getters: \n    <CODE>isEmpty</CODE>\n     and\n\n    <CODE>isNotEmpty</CODE>\n    .  Use the one that doesn't require you to negate the result.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (lunchBox.length == 0) return 'so hungry...';\nif (words.length != 0) return words.join(' ');\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (lunchBox.isEmpty) return 'so hungry...';\nif (words.isNotEmpty) return words.join(' ');\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_is_not_empty",
        "name": "Prefer is not empty",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n    <CODE>x.isNotEmpty</CODE>\n     to \n    <CODE>!x.isEmpty</CODE>\n     for \n    <CODE>Iterable</CODE>\n     and \n    <CODE>Map</CODE>\n     instances.\n  </P>\n  <P>\n    When testing whether an iterable or map is empty, prefer \n    <CODE>isNotEmpty</CODE>\n     over\n\n    <CODE>!isEmpty</CODE>\n     to improve code readability.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (!sources.isEmpty) {\n  process(sources);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (todo.isNotEmpty) {\n  sendResults(request, todo.isEmpty);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_is_not_operator",
        "name": "Prefer is not operator",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>When checking if an object is not of a specified type, it is preferable to use the 'is!' operator.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (!(foo is Foo)) {\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (foo is! Foo) {\n  ...\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_iterable_whereType",
        "name": "Prefer iterable whereType",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n    <CODE>iterable.whereType&lt;T&gt;()</CODE>\n     over \n    <CODE>iterable.where((e) =&gt; e is T)</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">iterable.where((e) =&gt; e is MyClass);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">iterable.whereType&lt;MyClass&gt;();\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_mixin",
        "name": "Prefer mixin",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    Dart 2.1 introduced a new syntax for mixins that provides a safe way for a mixin\nto invoke inherited members using \n    <CODE>super</CODE>\n    . The new style of mixins should always\nbe used for types that are to be mixed in. As a result, this lint will flag any\nuses of a class in a \n    <CODE>with</CODE>\n     clause.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {}\nclass B extends Object with A {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>OK:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">mixin M {}\nclass C with M {}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "prefer_null_aware_method_calls",
        "name": "Prefer null aware method calls",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Instead of checking nullability of a function/method \n    <CODE>f</CODE>\n     before calling it you\ncan use \n    <CODE>f?.call()</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (f != null) f!();\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">f?.call();\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_null_aware_operators",
        "name": "Prefer null aware operators",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using null aware operators instead of null checks in conditional\nexpressions.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">v = a == null ? null : a.b;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">v = a?.b;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_single_quotes",
        "name": "Prefer single quotes",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use single quotes where they wouldn't require additional escapes.\n  </P>\n  <P>That means strings with an apostrophe may use double quotes so that the\napostrophe isn't escaped (note: we don't lint the other way around, ie, a single\nquoted string with an escaped apostrophe is not flagged).</P>\n  <P>It's also rare, but possible, to have strings within string interpolations.  In\nthis case, its much more readable to use a double quote somewhere.  So double\nquotes are allowed either within, or containing, an interpolated string literal.\nArguably strings within string interpolations should be its own type of lint.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">useStrings(\n    \"should be single quote\",\n    r\"should be single quote\",\n    r\"\"\"should be single quotes\"\"\")\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">useStrings(\n    'should be single quote',\n    r'should be single quote',\n    r'''should be single quotes''',\n    \"here's ok\",\n    \"nested ${a ? 'strings' : 'can'} be wrapped by a double quote\",\n    'and nested ${a ? \"strings\" : \"can be double quoted themselves\"}');\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"prefer_double_quotes.html\">prefer_double_quotes</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "prefer_spread_collections",
        "name": "Prefer spread collections",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Use spread collections when possible.</P>\n  <P>Collection literals are excellent when you want to create a new collection out\nof individual items. But, when existing items are already stored in another\ncollection, spread collection syntax leads to simpler code.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget build(BuildContext context) {\n  return CupertinoPageScaffold(\n    child: ListView(\n      children: [\n        Tab2Header(),\n      ]..addAll(buildTab2Conversation()),\n    ),\n  );\n}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">var ints = [1, 2, 3];\nprint(['a']..addAll(ints.map((i) =&gt; i.toString()))..addAll(['c']));\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">var things;\nvar l = ['a']..addAll(things ?? const []);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget build(BuildContext context) {\n  return CupertinoPageScaffold(\n    child: ListView(\n      children: [\n        Tab2Header(),\n        ...buildTab2Conversation(),\n      ],\n    ),\n  );\n}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">var ints = [1, 2, 3];\nprint(['a', ...ints.map((i) =&gt; i.toString()), 'c');\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">var things;\nvar l = ['a', ...?things];\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "prefer_typing_uninitialized_variables",
        "name": "Prefer typing uninitialized variables",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     specifying a type annotation for uninitialized variables and fields.\n  </P>\n  <P>Forgoing type annotations for uninitialized variables is a bad practice because\nyou may accidentally assign them to a type that you didn't originally intend to.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class BadClass {\n  static var bar; // LINT\n  var foo; // LINT\n\n  void method() {\n    var bar; // LINT\n    bar = 5;\n    print(bar);\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void aFunction() {\n  var bar; // LINT\n  bar = 5;\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class GoodClass {\n  static var bar = 7;\n  var foo = 42;\n  int baz; // OK\n\n  void method() {\n    int baz;\n    var bar = 5;\n    ...\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "provide_deprecation_message",
        "name": "Provide deprecation message",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     specify a deprecation message (with migration instructions and/or a\nremoval schedule) in the Deprecation constructor.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@deprecated\nvoid oldFunction(arg1, arg2) {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">@Deprecated(\"\"\"\n[oldFunction] is being deprecated in favor of [newFunction] (with slightly\ndifferent parameters; see [newFunction] for more information). [oldFunction]\nwill be removed on or after the 4.0.0 release.\n\"\"\")\nvoid oldFunction(arg1, arg2) {}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "public_member_api_docs",
        "name": "Public member api docs",
        "severity": "INFO",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     document all public members.\n  </P>\n  <P>\n    All non-overriding public members should be documented with \n    <CODE>///</CODE>\n     doc-style\ncomments.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Bad {\n  void meh() { }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">/// A good thing.\nabstract class Good {\n  /// Start doing your thing.\n  void start() =&gt; _start();\n\n  _start();\n}\n</CODE>\n  </PRE>\n  <P>\n    In case a public member overrides a member it is up to the declaring member\nto provide documentation.  For example, in the following, \n    <CODE>Sub</CODE>\n     needn't\ndocument \n    <CODE>init</CODE>\n     (though it certainly may, if there's need).\n  </P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">/// Base of all things.\nabstract class Base {\n  /// Initialize the base.\n  void init();\n}\n\n/// A sub base.\nclass Sub extends Base {\n  @override\n  void init() { ... }\n}\n</CODE>\n  </PRE>\n  <P>\n    Note that consistent with \n    <CODE>dart doc</CODE>\n    , an exception to the rule is made when\ndocumented getters have corresponding undocumented setters.  In this case the\nsetters inherit the docs from the getters.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "10min",
        "active": false
    },
    {
        "key": "recursive_getters",
        "name": "Recursive getters",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     create recursive getters.\n  </P>\n  <P>Recursive getters are getters which return themselves as a value.  This is\nusually a typo.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">int get field =&gt; field; // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">int get otherField {\n  return otherField; // LINT\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">int get field =&gt; _field;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "1min",
        "active": true
    },
    {
        "key": "require_trailing_commas",
        "name": "Require trailing commas",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use trailing commas for all function calls and declarations unless the\nfunction call or definition, from the start of the function name up to the\nclosing parenthesis, fits in a single line.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void run() {\n  method('does not fit on one line',\n      'test test test test test test test test test test test');\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void run() {\n  method(\n    'does not fit on one line',\n    'test test test test test test test test test test test',\n  );\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>EXCEPTION:</STRONG>\n     If the final parameter/argument is positional (vs named) and is\neither a function literal implemented using curly braces, a literal map, a\nliteral set or a literal array. This exception only applies if the final\nparameter does not fit entirely on one line.\n  </P>\n  <P>\n    <STRONG>NOTE:</STRONG>\n     This lint rule assumes \n    <CODE>dart format</CODE>\n     has been run over the code and\nmay produce false positives until that has happened.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "sized_box_for_whitespace",
        "name": "Sized box for whitespace",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>Use SizedBox to add whitespace to a layout.</P>\n  <P>\n    A \n    <CODE>Container</CODE>\n     is a heavier Widget than a \n    <CODE>SizedBox</CODE>\n    , and as bonus, \n    <CODE>SizedBox</CODE>\n    has a \n    <CODE>const</CODE>\n     constructor.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildRow() {\n  return Row(\n    children: &lt;Widget&gt;[\n      const MyLogo(),\n      Container(width: 4),\n      const Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildRow() {\n  return Row(\n    children: const &lt;Widget&gt;[\n      MyLogo(),\n      SizedBox(width: 4),\n      Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "sized_box_shrink_expand",
        "name": "Sized box shrink expand",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Use \n    <CODE>SizedBox.shrink(...)</CODE>\n     and \n    <CODE>SizedBox.expand(...)</CODE>\n     constructors appropriately.\n  </P>\n  <P>\n    The \n    <CODE>SizedBox.shrink(...)</CODE>\n     and \n    <CODE>SizedBox.expand(...)</CODE>\n     constructors should be used\ninstead of the more general \n    <CODE>SizedBox(...)</CODE>\n     constructor when the named constructors\ncapture the intent of the code more succinctly.\n  </P>\n  <P>\n    <STRONG>Examples</STRONG>\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildLogo() {\n  return SizedBox(\n    height: 0,\n    width: 0,\n    child: const MyLogo(),\n  );\n}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildLogo() {\n  return SizedBox(\n    height: double.infinity,\n    width: double.infinity,\n    child: const MyLogo(),\n  );\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildLogo() {\n  return SizedBox.shrink(\n    child: const MyLogo(),\n  );\n}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildLogo() {\n  return SizedBox.expand(\n    child: const MyLogo(),\n  );\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "slash_for_doc_comments",
        "name": "Slash for doc comments",
        "severity": "INFO",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/style\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using \n    <CODE>///</CODE>\n     for doc comments.\n  </P>\n  <P>\n    Although Dart supports two syntaxes of doc comments (\n    <CODE>///</CODE>\n     and \n    <CODE>/**</CODE>\n    ), we\nprefer using \n    <CODE>///</CODE>\n     for doc comments.\n  </P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">/// Parses a set of option strings. For each option:\n///\n/// * If it is `null`, then it is ignored.\n/// * If it is a string, then [validate] is called on it.\n/// * If it is any other type, it is *not* validated.\nvoid parse(List options) {\n  // ...\n}\n</CODE>\n  </PRE>\n  <P>Within a doc comment, you can use markdown for formatting.</P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "sort_child_properties_last",
        "name": "Sort child properties last",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>Sort child properties last in widget instance creations.  This improves\nreadability and plays nicest with UI as Code visualization in IDEs with UI as\nCode Guides in editors (such as IntelliJ) where Properties in the correct order\nappear clearly associated with the constructor call and separated from the\nchildren.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">return Scaffold(\n  appBar: AppBar(\n    title: Text(widget.title),\n  ),\n  body: Center(\n    child: Column(\n      children: &lt;Widget&gt;[\n        Text(\n          'You have pushed the button this many times:',\n         ),\n        Text(\n          '$_counter',\n          style: Theme.of(context).textTheme.display1,\n         ),\n      ],\n      mainAxisAlignment: MainAxisAlignment.center,\n    ),\n    widthFactor: 0.5,\n  ),\n  floatingActionButton: FloatingActionButton(\n    child: Icon(Icons.add),\n    onPressed: _incrementCounter,\n    tooltip: 'Increment',\n  ),\n);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">return Scaffold(\n  appBar: AppBar(\n    title: Text(widget.title),\n  ),\n  body: Center(\n    widthFactor: 0.5,\n    child: Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: &lt;Widget&gt;[\n        Text(\n          'You have pushed the button this many times:',\n         ),\n        Text(\n          '$_counter',\n          style: Theme.of(context).textTheme.display1,\n         ),\n      ],\n    ),\n  ),\n  floatingActionButton: FloatingActionButton(\n    onPressed: _incrementCounter,\n    tooltip: 'Increment',\n    child: Icon(Icons.add),\n  ),\n);\n</CODE>\n  </PRE>\n  <P>\n    Exception: It's allowed to have parameter with a function expression after the\n\n    <CODE>child</CODE>\n     property.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "sort_constructors_first",
        "name": "Sort constructors first",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     sort constructor declarations before other members.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class Visitor {\n  double value;\n  visitSomething(Something s);\n  Visitor();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class Animation&lt;T&gt; {\n  const Animation(this.value);\n  double value;\n  void addListener(VoidCallback listener);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "sort_unnamed_constructors_first",
        "name": "Sort unnamed constructors first",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     sort unnamed constructor declarations first, before named ones.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class _PriorityItem {\n  factory _PriorityItem.forName(bool isStatic, String name, _MemberKind kind) =&gt; ...\n  _PriorityItem(this.isStatic, this.kind, this.isPrivate);\n  ...\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">abstract class CancelableFuture&lt;T&gt; implements Future&lt;T&gt;  {\n  factory CancelableFuture(computation()) =&gt; ...\n  factory CancelableFuture.delayed(Duration duration, [computation()]) =&gt; ...\n  ...\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "super_goes_last",
        "name": "Super goes last",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P style=\"font-size:30px\">\n    <STRONG>Unsupported since Dart language version 3.0.0.</STRONG>\n  </P>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     place the \n    <CODE>super</CODE>\n     call last in a constructor initialization list.\n  </P>\n  <P>\n    Field initializers are evaluated in the order that they appear in the\nconstructor initialization list.  If you place a \n    <CODE>super()</CODE>\n     call in the middle of\nan initializer list, the superclass's initializers will be evaluated right then\nbefore evaluating the rest of the subclass's initializers.\n  </P>\n  <P>\n    What it doesn't mean is that the superclass's constructor body will be executed\nthen.  That always happens after all initializers are run regardless of where\n\n    <CODE>super</CODE>\n     appears.  It's vanishingly rare that the order of initializers matters,\nso the placement of \n    <CODE>super</CODE>\n     in the list almost never matters either.\n  </P>\n  <P>Getting in the habit of placing it last improves consistency, visually\nreinforces when the superclass's constructor body is run, and may help\nperformance.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">View(Style style, List children)\n    : super(style),\n      _children = children {\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">View(Style style, List children)\n    : _children = children,\n      super(style) {\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "tighten_type_of_initializing_formals",
        "name": "Tighten type of initializing formals",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>Tighten the type of an initializing formal if a non-null assert exists. This\nallows the type system to catch problems rather than have them only be caught at\nrun-time.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  A.c1(this.p) : assert(p != null);\n  A.c2(this.p);\n  final String? p;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  A.c1(String this.p);\n  A.c2(this.p);\n  final String? p;\n}\n\nclass B {\n  String? b;\n  B(this.b);\n}\n\nclass C extends B {\n  B(String super.b);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "type_annotate_public_apis",
        "name": "Type annotate public apis",
        "severity": "INFO",
        "description": "<SECTION>\n  <P>\n    From \n    <A href=\"https://dart.dev/guides/language/effective-dart/design#do-type-annotate-fields-and-top-level-variables-if-the-type-isnt-obvious\">Effective Dart</A>\n    :\n  </P>\n  <P>\n    <STRONG>PREFER</STRONG>\n     type annotating public APIs.\n  </P>\n  <P>Type annotations are important documentation for how a library should be used.\nAnnotating the parameter and return types of public methods and functions helps\nusers understand what the API expects and what it provides.</P>\n  <P>\n    Note that if a public API accepts a range of values that Dart's type system\ncannot express, then it is acceptable to leave that untyped.  In that case, the\nimplicit \n    <CODE>dynamic</CODE>\n     is the correct type for the API.\n  </P>\n  <P>\n    For code internal to a library (either private, or things like nested functions)\nannotate where you feel it helps, but don't feel that you \n    <EM>must</EM>\n     provide them.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">install(id, destination) {\n  // ...\n}\n</CODE>\n  </PRE>\n  <P>\n    Here, it's unclear what \n    <CODE>id</CODE>\n     is.  A string? And what is \n    <CODE>destination</CODE>\n    ? A string\nor a \n    <CODE>File</CODE>\n     object? Is this method synchronous or asynchronous?\n  </P>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Future&lt;bool&gt; install(PackageId id, String destination) {\n  // ...\n}\n</CODE>\n  </PRE>\n  <P>With types, all of this is clarified.</P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "type_init_formals",
        "name": "Type init formals",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>DON'T</STRONG>\n     type annotate initializing formals.\n  </P>\n  <P>\n    If a constructor parameter is using \n    <CODE>this.x</CODE>\n     to initialize a field, then the\ntype of the parameter is understood to be the same type as the field. If a\na constructor parameter is using \n    <CODE>super.x</CODE>\n     to forward to a super constructor,\nthen the type of the parameter is understood to be the same as the super\nconstructor parameter.\n  </P>\n  <P>Type annotating an initializing formal with a different type than that of the\nfield is OK.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  int x, y;\n  Point(int this.x, int this.y);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Point {\n  int x, y;\n  Point(this.x, this.y);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  int a;\n  A(this.a);\n}\n\nclass B extends A {\n  B(int super.a);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  int a;\n  A(this.a);\n}\n\nclass B extends A {\n  B(super.a);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "type_literal_in_constant_pattern",
        "name": "Type literal in constant pattern",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    If you meant to test if the object has type \n    <CODE>Foo</CODE>\n    , instead write \n    <CODE>Foo _</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f(Object? x) {\n  if (x case num) {\n    print('int or double');\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f(Object? x) {\n  if (x case num _) {\n    print('int or double');\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    If you do mean to test that the matched value (which you expect to have the\ntype \n    <CODE>Type</CODE>\n    ) is equal to the type literal \n    <CODE>Foo</CODE>\n    , then this lint can be\nsilenced using \n    <CODE>const (Foo)</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f(Object? x) {\n  if (x case int) {\n    print('int');\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void f(Object? x) {\n  if (x case const (int)) {\n    print('int');\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unawaited_futures",
        "name": "Unawaited futures",
        "severity": "CRITICAL",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     await functions that return a \n    <CODE>Future</CODE>\n     inside of an async function body.\n  </P>\n  <P>\n    It's easy to forget await in async methods as naming conventions usually don't\ntell us if a method is sync or async (except for some in \n    <CODE>dart:io</CODE>\n    ).\n  </P>\n  <P>\n    When you really \n    <EM>do</EM>\n     want to start a fire-and-forget \n    <CODE>Future</CODE>\n    , the recommended\nway is to use \n    <CODE>unawaited</CODE>\n     from \n    <CODE>dart:async</CODE>\n    . The \n    <CODE>// ignore</CODE>\n     and\n\n    <CODE>// ignore_for_file</CODE>\n     comments also work.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void main() async {\n  doSomething(); // Likely a bug.\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Future doSomething() =&gt; ...;\n\nvoid main() async {\n  await doSomething();\n\n  unawaited(doSomething()); // Explicitly-ignored fire-and-forget.\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "BUG",
        "debt": "5min",
        "active": false
    },
    {
        "key": "unnecessary_await_in_return",
        "name": "Unnecessary await in return",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Avoid returning an awaited expression when the expression type is assignable to\nthe function's return type.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Future&lt;int&gt; future;\nFuture&lt;int&gt; f1() async =&gt; await future;\nFuture&lt;int&gt; f2() async {\n  return await future;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Future&lt;int&gt; future;\nFuture&lt;int&gt; f1() =&gt; future;\nFuture&lt;int&gt; f2() {\n  return future;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unnecessary_brace_in_string_interps",
        "name": "Unnecessary brace in string interps",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using braces in interpolation when not needed.\n  </P>\n  <P>\n    If you're just interpolating a simple identifier, and it's not immediately\nfollowed by more alphanumeric text, the \n    <CODE>{}</CODE>\n     can and should be omitted.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">print(\"Hi, ${name}!\");\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">print(\"Hi, $name!\");\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_breaks",
        "name": "Unnecessary breaks",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Only use a \n    <CODE>break</CODE>\n     in a non-empty switch case statement if you need to break\nbefore the end of the case body.  Dart does not support fallthrough execution\nfor non-empty cases, so \n    <CODE>break</CODE>\n    s at the end of non-empty switch case statements\nare unnecessary.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">switch (1) {\n  case 1:\n    print(\"one\");\n    break;\n  case 2:\n    print(\"two\");\n    break;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">switch (1) {\n  case 1:\n    print(\"one\");\n  case 2:\n    print(\"two\");\n}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">switch (1) {\n  case 1:\n  case 2:\n    print(\"one or two\");\n}\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">switch (1) {\n  case 1:\n    break;\n  case 2:\n    print(\"just two\");\n}\n</CODE>\n  </PRE>\n  <P>\n    NOTE: This lint only reports unnecessary breaks in libraries with a\n\n    <A href=\"https://dart.dev/guides/language/evolution#language-versioning\">language version</A>\n    of 3.0 or greater. Explicit breaks are still required in Dart 2.19 and below.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unnecessary_const",
        "name": "Unnecessary const",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     repeating const keyword in a const context.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A { const A(); }\nm(){\n  const a = const A();\n  final b = const [const A()];\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A { const A(); }\nm(){\n  const a = A();\n  final b = const [A()];\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_constructor_name",
        "name": "Unnecessary constructor name",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     using the default unnamed Constructor over \n    <CODE>.new</CODE>\n    .\n  </P>\n  <P>\n    Given a class \n    <CODE>C</CODE>\n    , the named unnamed constructor \n    <CODE>C.new</CODE>\n     refers to the same\nconstructor as the unnamed \n    <CODE>C</CODE>\n    . As such it adds nothing but visual noise to\ninvocations and should be avoided (unless being used to identify a constructor\ntear-off).\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  A.new(); // LINT\n}\n\nvar a = A.new(); // LINT\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  A.ok();\n}\n\nvar a = A();\nvar aa = A.ok();\nvar makeA = A.new;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_final",
        "name": "Unnecessary final",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Use \n    <CODE>var</CODE>\n    , not \n    <CODE>final</CODE>\n    , when declaring local variables.\n  </P>\n  <P>\n    Per \n    <A href=\"https://dart.dev/guides/language/effective-dart/usage#do-follow-a-consistent-rule-for-var-and-final-on-local-variables\">Effective Dart</A>\n    ,\nthere are two styles in wide use. This rule enforces the \n    <CODE>var</CODE>\n     style.\nFor the alternative style that prefers \n    <CODE>final</CODE>\n    , enable \n    <CODE>prefer_final_locals</CODE>\n    and \n    <CODE>prefer_final_in_for_each</CODE>\n     instead.\n  </P>\n  <P>\n    For fields, \n    <CODE>final</CODE>\n     is always recommended; see the rule \n    <CODE>prefer_final_fields</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void badMethod() {\n  final label = 'Final or var?';\n  for (final char in ['v', 'a', 'r']) {\n    print(char);\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">void goodMethod() {\n  var label = 'Final or var?';\n  for (var char in ['v', 'a', 'r']) {\n    print(char);\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    Incompatible with: \n    <A href=\"prefer_final_locals.html\">prefer_final_locals</A>\n    , \n    <A href=\"prefer_final_parameters.html\">prefer_final_parameters</A>\n    .\n\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "unnecessary_getters_setters",
        "name": "Unnecessary getters setters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>AVOID</STRONG>\n     wrapping fields in getters and setters just to be \"safe\".\n  </P>\n  <P>In Java and C#, it's common to hide all fields behind getters and setters (or\nproperties in C#), even if the implementation just forwards to the field.  That\nway, if you ever need to do more work in those members, you can do it without needing\nto touch the callsites.  This is because calling a getter method is different\nthan accessing a field in Java, and accessing a property isn't binary-compatible\nwith accessing a raw field in C#.</P>\n  <P>Dart doesn't have this limitation.  Fields and getters/setters are completely\nindistinguishable.  You can expose a field in a class and later wrap it in a\ngetter and setter without having to touch any code that uses that field.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Box {\n  var _contents;\n  get contents =&gt; _contents;\n  set contents(value) {\n    _contents = value;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Box {\n  var contents;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_lambdas",
        "name": "Unnecessary lambdas",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     create a lambda when a tear-off will do.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">names.forEach((name) {\n  print(name);\n});\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">names.forEach(print);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "unnecessary_late",
        "name": "Unnecessary late",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     not specify the \n    <CODE>late</CODE>\n     modifier for top-level and static variables\nwhen the declaration contains an initializer.\n  </P>\n  <P>\n    Top-level and static variables with initializers are already evaluated lazily\nas if they are marked \n    <CODE>late</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">late String badTopLevel = '';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">String goodTopLevel = '';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class BadExample {\n  static late String badStatic = '';\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class GoodExample {\n  late String goodStatic;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_library_directive",
        "name": "Unnecessary library directive",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use library directives if you want to document a library and/or annotate\na library.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">library;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">/// This library does important things\nlibrary;\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-dart\">@TestOn('js')\nlibrary;\n</CODE>\n  </PRE>\n  <P>NOTE: Due to limitations with this lint, libraries with parts will not be\nflagged for unnecessary library directives.</P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unnecessary_new",
        "name": "Unnecessary new",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     new keyword to create instances.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A { A(); }\nm(){\n  final a = new A();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A { A(); }\nm(){\n  final a = A();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_null_aware_assignments",
        "name": "Unnecessary null aware assignments",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n    <CODE>null</CODE>\n     in null-aware assignment.\n  </P>\n  <P>\n    Using \n    <CODE>null</CODE>\n     on the right-hand side of a null-aware assignment effectively makes\nthe assignment redundant.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var x;\nx ??= null;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var x;\nx ??= 1;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_null_aware_operator_on_extension_on_nullable",
        "name": "Unnecessary null aware operator on extension on nullable",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Avoid null aware operators for members defined in an extension on a nullable type.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">extension E on int? {\n  int m() =&gt; 1;\n}\nf(int? i) =&gt; i?.m();\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">extension E on int? {\n  int m() =&gt; 1;\n}\nf(int? i) =&gt; i.m();\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unnecessary_null_checks",
        "name": "Unnecessary null checks",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     apply a null check when a nullable value is accepted.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">f(int? i) {}\nm() {\n  int? j;\n  f(j!);\n}\n\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">f(int? i) {}\nm() {\n  int? j;\n  f(j);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unnecessary_null_in_if_null_operators",
        "name": "Unnecessary null in if null operators",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using \n    <CODE>null</CODE>\n     as an operand in \n    <CODE>if null</CODE>\n     operators.\n  </P>\n  <P>\n    Using \n    <CODE>null</CODE>\n     in an \n    <CODE>if null</CODE>\n     operator is redundant, regardless of which side\n\n    <CODE>null</CODE>\n     is used on.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var x = a ?? null;\nvar y = null ?? 1;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var x = a ?? 1;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_nullable_for_final_variable_declarations",
        "name": "Unnecessary nullable for final variable declarations",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Use a non-nullable type for a final variable initialized with a non-nullable\nvalue.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">final int? i = 1;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">final int i = 1;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_overrides",
        "name": "Unnecessary overrides",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     override a method to do a super method invocation with same parameters.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A extends B {\n  @override\n  void foo() {\n    super.foo();\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A extends B {\n  @override\n  void foo() {\n    doSomethingElse();\n  }\n}\n</CODE>\n  </PRE>\n  <P>It's valid to override a member in the following cases:</P>\n  <UL>\n    <LI>if a type (return type or a parameter type) is not the exactly the same as the\nsuper member,</LI>\n    <LI>\n      if the \n      <CODE>covariant</CODE>\n       keyword is added to one of the parameters,\n    </LI>\n    <LI>if documentation comments are present on the member,</LI>\n    <LI>\n      if the member has annotations other than \n      <CODE>@override</CODE>\n      ,\n    </LI>\n    <LI>\n      if the member is not annotated with \n      <CODE>@protected</CODE>\n      , and the super member is.\n    </LI>\n  </UL>\n  <P>\n    <CODE>noSuchMethod</CODE>\n     is a special method and is not checked by this rule.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "unnecessary_parenthesis",
        "name": "Unnecessary parenthesis",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>AVOID</STRONG>\n     using parentheses when not needed.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">a = (b);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">a = b;\n</CODE>\n  </PRE>\n  <P>Parentheses are considered unnecessary if they do not change the meaning of the\ncode and they do not improve the readability of the code. The goal is not to\nforce all developers to maintain the expression precedence table in their heads,\nwhich is why the second condition is included. Examples of this condition\ninclude:</P>\n  <UL>\n    <LI>\n      cascade expressions - it is sometimes not clear what the target of a cascade\nexpression is, especially with assignments, or nested cascades. For example,\nthe expression \n      <CODE>a.b = (c..d)</CODE>\n      .\n    </LI>\n    <LI>\n      expressions with whitespace between tokens - it can look very strange to see\nan expression like \n      <CODE>!await foo</CODE>\n       which is valid and equivalent to\n\n      <CODE>!(await foo)</CODE>\n      .\n    </LI>\n    <LI>\n      logical expressions - parentheses can improve the readability of the implicit\ngrouping defined by precedence. For example, the expression\n\n      <CODE>(a &amp;&amp; b) || c &amp;&amp; d</CODE>\n      .\n    </LI>\n  </UL>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unnecessary_raw_strings",
        "name": "Unnecessary raw strings",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Use raw string only when needed.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s1 = r'a';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s1 = 'a';\nvar s2 = r'$a';\nvar s3 = r'\\a';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unnecessary_string_escapes",
        "name": "Unnecessary string escapes",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Remove unnecessary backslashes in strings.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">'this string contains 2 \\\"double quotes\\\" ';\n\"this string contains 2 \\'single quotes\\' \";\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">'this string contains 2 \"double quotes\" ';\n\"this string contains 2 'single quotes' \";\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_string_interpolations",
        "name": "Unnecessary string interpolations",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use string interpolation if there's only a string expression in it.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">String message;\nString o = '$message';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">String message;\nString o = message;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_this",
        "name": "Unnecessary this",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</A>\n    :\n  </P>\n  <P>\n    <STRONG>DON'T</STRONG>\n     use \n    <CODE>this</CODE>\n     when not needed to avoid shadowing.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Box {\n  var value;\n  void update(new_value) {\n    this.value = new_value;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Box {\n  var value;\n  void update(new_value) {\n    value = new_value;\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Box {\n  var value;\n  void update(value) {\n    this.value = value;\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "unnecessary_to_list_in_spreads",
        "name": "Unnecessary to list in spreads",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Unnecessary \n    <CODE>toList()</CODE>\n     in spreads.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">children: &lt;Widget&gt;[\n  ...['foo', 'bar', 'baz'].map((String s) =&gt; Text(s)).toList(),\n]\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">children: &lt;Widget&gt;[\n  ...['foo', 'bar', 'baz'].map((String s) =&gt; Text(s)),\n]\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "unreachable_from_main",
        "name": "Unreachable from main",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    Top-level members in an executable library should be used directly inside this\nlibrary.  An executable library is a library that contains a \n    <CODE>main</CODE>\n     top-level\nfunction or that contains a top-level function annotated with\n\n    <CODE>@pragma('vm:entry-point')</CODE>\n    ).  Executable libraries are not usually imported\nand it's better to avoid defining unused members.\n  </P>\n  <P>\n    This rule assumes that an executable library isn't imported by other files\nexcept to execute its \n    <CODE>main</CODE>\n     function.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">main() {}\nvoid f() {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">main() {\n  f();\n}\nvoid f() {}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "use_colored_box",
        "name": "Use colored box",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use \n    <CODE>ColoredBox</CODE>\n     when \n    <CODE>Container</CODE>\n     has only a \n    <CODE>Color</CODE>\n    .\n  </P>\n  <P>\n    A \n    <CODE>Container</CODE>\n     is a heavier Widget than a \n    <CODE>ColoredBox</CODE>\n    , and as bonus,\n\n    <CODE>ColoredBox</CODE>\n     has a \n    <CODE>const</CODE>\n     constructor.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildArea() {\n  return Container(\n    color: Colors.blue,\n    child: const Text('hello'),\n  );\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildArea() {\n  return const ColoredBox(\n    color: Colors.blue,\n    child: Text('hello'),\n  );\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_decorated_box",
        "name": "Use decorated box",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use \n    <CODE>DecoratedBox</CODE>\n     when \n    <CODE>Container</CODE>\n     has only a \n    <CODE>Decoration</CODE>\n    .\n  </P>\n  <P>\n    A \n    <CODE>Container</CODE>\n     is a heavier Widget than a \n    <CODE>DecoratedBox</CODE>\n    , and as bonus,\n\n    <CODE>DecoratedBox</CODE>\n     has a \n    <CODE>const</CODE>\n     constructor.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildArea() {\n  return Container(\n    decoration: const BoxDecoration(\n      color: Colors.blue,\n      borderRadius: BorderRadius.all(\n        Radius.circular(5),\n      ),\n    ),\n    child: const Text('...'),\n  );\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Widget buildArea() {\n  return const DecoratedBox(\n    decoration: BoxDecoration(\n      color: Colors.blue,\n      borderRadius: BorderRadius.all(\n        Radius.circular(5),\n      ),\n    ),\n    child: Text('...'),\n  );\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_enums",
        "name": "Use enums",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    Classes that look like enumerations should be declared as \n    <CODE>enum</CODE>\n    s.\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     use enums where appropriate.\n  </P>\n  <P>Candidates for enums are classes that:</P>\n  <UL>\n    <LI>are concrete,</LI>\n    <LI>are private or have only private generative constructors,</LI>\n    <LI>have two or more static const fields with the same type as the class,</LI>\n    <LI>have generative constructors that are only invoked at the top-level of the\ninitialization expression of these static fields,</LI>\n    <LI>\n      do not define \n      <CODE>hashCode</CODE>\n      , \n      <CODE>==</CODE>\n      , \n      <CODE>values</CODE>\n       or \n      <CODE>index</CODE>\n      ,\n    </LI>\n    <LI>do not extend any class other than Object, and</LI>\n    <LI>have no subclasses declared in the defining library.</LI>\n  </UL>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class LogPriority {\n  static const error = LogPriority._(1, 'Error');\n  static const warning = LogPriority._(2, 'Warning');\n  static const log = LogPriority._unknown('Log');\n\n  final String prefix;\n  final int priority;\n  const LogPriority._(this.priority, this.prefix);\n  const LogPriority._unknown(String prefix) : this._(-1, prefix);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">enum LogPriority {\n  error(1, 'Error'),\n  warning(2, 'Warning'),\n  log.unknown('Log');\n\n  final String prefix;\n  final int priority;\n  const LogPriority(this.priority, this.prefix);\n  const LogPriority.unknown(String prefix) : this(-1, prefix);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "use_full_hex_values_for_flutter_colors",
        "name": "Use full hex values for flutter colors",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     an 8-digit hexadecimal integer(0xFFFFFFFF) to instantiate Color. Colors\nhave four 8-bit channels, which adds up to 32 bits, so Colors are described\nusing a 32 bit integer.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Color(1);\nColor(0x000001);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Color(0x00000001);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_function_type_syntax_for_parameters",
        "name": "Use function type syntax for parameters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Use generic function type syntax for parameters.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Iterable&lt;T&gt; where(bool predicate(T element)) {}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Iterable&lt;T&gt; where(bool Function(T) predicate) {}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "use_if_null_to_convert_nulls_to_bools",
        "name": "Use if null to convert nulls to bools",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From \n    <A href=\"https://dart.dev/guides/language/effective-dart/usage#prefer-using--to-convert-null-to-a-boolean-value\">Effective Dart</A>\n    :\n  </P>\n  <P>Use if-null operators to convert nulls to bools.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (nullableBool == true) {\n}\nif (nullableBool != false) {\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">if (nullableBool ?? false) {\n}\nif (nullableBool ?? true) {\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_is_even_rather_than_modulo",
        "name": "Use is even rather than modulo",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>PREFER</STRONG>\n     the use of intValue.isOdd/isEven to check for evenness.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">bool isEven = 1 % 2 == 0;\nbool isOdd = 13 % 2 == 1;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">bool isEven = 1.isEven;\nbool isOdd = 13.isOdd;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_late_for_private_fields_and_variables",
        "name": "Use late for private fields and variables",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Use \n    <CODE>late</CODE>\n     for private members with non-nullable types that are always expected\nto be non-null. Thus it's clear that the field is not expected to be \n    <CODE>null</CODE>\n    and it avoids null checks.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">int? _i;\nm() {\n  _i!.abs();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">late int _i;\nm() {\n  _i.abs();\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>OK:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">int? _i;\nm() {\n  _i?.abs();\n  _i = null;\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_named_constants",
        "name": "Use named constants",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>Where possible, use already defined const values.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">const Duration(seconds: 0);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">Duration.zero;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_raw_strings",
        "name": "Use raw strings",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>A raw string can be used to avoid escaping only backslashes and dollars.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s = 'A string with only \\\\ and \\$';\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">var s = r'A string with only \\ and $';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_rethrow_when_possible",
        "name": "Use rethrow when possible",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use rethrow to rethrow a caught exception.\n  </P>\n  <P>As Dart provides rethrow as a feature, it should be used to improve terseness\nand readability.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">try {\n  somethingRisky();\n} catch(e) {\n  if (!canHandle(e)) throw e;\n  handle(e);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">try {\n  somethingRisky();\n} catch(e) {\n  if (!canHandle(e)) rethrow;\n  handle(e);\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "use_setters_to_change_properties",
        "name": "Use setters to change properties",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use a setter for operations that conceptually change a property.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">rectangle.setWidth(3);\nbutton.setVisible(false);\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">rectangle.width = 3;\nbutton.visible = false;\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_string_buffers",
        "name": "Use string buffers",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     use string buffers to compose strings.\n  </P>\n  <P>In most cases, using a string buffer is preferred for composing strings due to\nits improved performance.</P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">String foo() {\n  final buffer = '';\n  for (int i = 0; i &lt; 10; i++) {\n    buffer += 'a'; // LINT\n  }\n  return buffer;\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">String foo() {\n  final buffer = StringBuffer();\n  for (int i = 0; i &lt; 10; i++) {\n    buffer.write('a');\n  }\n  return buffer.toString();\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "use_string_in_part_of_directives",
        "name": "Use string in part of directives",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From \n    <A href=\"https://dart.dev/guides/language/effective-dart/usage#do-use-strings-in-part-of-directives\">Effective Dart</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     use strings in \n    <CODE>part of</CODE>\n     directives.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">part of my_library;\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">part of '../../my_library.dart';\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "use_super_parameters",
        "name": "Use super parameters",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\"Forwarding constructor\"s, that do nothing except forward parameters to their\nsuperclass constructors should take advantage of super-initializer parameters\nrather than repeating the names of parameters when passing them to the\nsuperclass constructors.  This makes the code more concise and easier to read\nand maintain.</P>\n  <P>\n    <STRONG>DO</STRONG>\n     use super-initializer parameters where possible.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  A({int? x, int? y});\n}\nclass B extends A {\n  B({int? x, int? y}) : super(x: x, y: y);\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class A {\n  A({int? x, int? y});\n}\nclass B extends A {\n  B({super.x, super.y});\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "use_test_throws_matchers",
        "name": "Use test throws matchers",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    Use the \n    <CODE>throwsA</CODE>\n     matcher instead of try-catch with \n    <CODE>fail()</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// sync code\ntry {\n  someSyncFunctionThatThrows();\n  fail('expected Error');\n} on Error catch (error) {\n  expect(error.message, contains('some message'));\n}\n\n// async code\ntry {\n  await someAsyncFunctionThatThrows();\n  fail('expected Error');\n} on Error catch (error) {\n  expect(error.message, contains('some message'));\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">// sync code\nexpect(\n  () =&gt; someSyncFunctionThatThrows(),\n  throwsA(isA&lt;Error&gt;().having((Error error) =&gt; error.message, 'message', contains('some message'))),\n);\n\n// async code\nawait expectLater(\n  () =&gt; someAsyncFunctionThatThrows(),\n  throwsA(isA&lt;Error&gt;().having((Error error) =&gt; error.message, 'message', contains('some message'))),\n);\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": false
    },
    {
        "key": "use_to_and_as_if_applicable",
        "name": "Use to and as if applicable",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/guides/language/effective-dart/design\">Effective Dart</A>\n    :\n  </P>\n  <P>\n    <STRONG>PREFER</STRONG>\n     naming a method \n    <CODE>to___()</CODE>\n     if it copies the object's state to a new\nobject.\n  </P>\n  <P>\n    <STRONG>PREFER</STRONG>\n     naming a method \n    <CODE>as___()</CODE>\n     if it returns a different representation\nbacked by the original object.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Bar {\n  Foo myMethod() {\n    return Foo.from(this);\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Bar {\n  Foo toFoo() {\n    return Foo.from(this);\n  }\n}\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">class Bar {\n  Foo asFoo() {\n    return Foo.from(this);\n  }\n}\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "depend_on_referenced_packages",
        "name": "Depend on referenced packages",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     depend on referenced packages.\n  </P>\n  <P>When importing a package, add a dependency on it to your pubspec.</P>\n  <P>Depending explicitly on packages that you reference ensures they will always\nexist and allows you to put a dependency constraint on them to guard you\nagainst breaking changes.</P>\n  <P>\n    Whether this should be a regular dependency or dev_dependency depends on if it\nis referenced from a public file (one under either \n    <CODE>lib</CODE>\n     or \n    <CODE>bin</CODE>\n    ), or some\nother private file.\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:a/a.dart';\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-yaml\">dependencies:\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-dart\">import 'package:a/a.dart';\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-yaml\">dependencies:\n  a: ^1.0.0\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "package_names",
        "name": "Package names",
        "severity": "MINOR",
        "description": "<SECTION>\n  <P>\n    From the \n    <A href=\"https://dart.dev/tools/pub/pubspec\">Pubspec format description</A>\n    :\n  </P>\n  <P>\n    <STRONG>DO</STRONG>\n     use \n    <CODE>lowercase_with_underscores</CODE>\n     for package names.\n  </P>\n  <P>\n    Package names should be all lowercase, with underscores to separate words,\n\n    <CODE>just_like_this</CODE>\n    .  Use only basic Latin letters and Arabic digits: [a-z0-9_].\nAlso, make sure the name is a valid Dart identifier -- that it doesn't start\nwith digits and isn't a reserved word.\n  </P>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": true
    },
    {
        "key": "secure_pubspec_urls",
        "name": "Secure pubspec urls",
        "severity": "MAJOR",
        "description": "<SECTION>\n  <P>\n    <STRONG>DO</STRONG>\n     Use secure urls in \n    <CODE>pubspec.yaml</CODE>\n    .\n  </P>\n  <P>\n    Use \n    <CODE>https</CODE>\n     instead of \n    <CODE>http</CODE>\n     or \n    <CODE>git:</CODE>\n    .\n  </P>\n  <P>\n    <STRONG>BAD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-yaml\">repository: http://github.com/dart-lang/example\n</CODE>\n  </PRE>\n  <PRE>\n<CODE class=\"language-yaml\">git:\n  url: git://github.com/dart-lang/example/example.git\n</CODE>\n  </PRE>\n  <P>\n    <STRONG>GOOD:</STRONG>\n  </P>\n  <PRE>\n<CODE class=\"language-yaml\">repository: https://github.com/dart-lang/example\n</CODE>\n  </PRE>\n</SECTION>\n",
        "type": "CODE_SMELL",
        "debt": "1min",
        "active": false
    },
    {
        "key": "abi_specific_integer_invalid",
        "name": "Abi specific integer invalid",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a class that extends\nAbiSpecificInteger doesn\u2019t meet all of the following requirements:\n @see https://dart.dev/tools/diagnostic-messages#abi_specific_integer_invalid",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "abstract_field_initializer",
        "name": "Abstract field initializer",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a field that has the abstract\nmodifier also has an initializer.\n @see https://dart.dev/tools/diagnostic-messages#abstract_field_initializer",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "argument_type_not_assignable_to_error_handler",
        "name": "Argument type not assignable to error handler",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an invocation of\nFuture.catchError has an argument that is a function whose parameters\naren\u2019t compatible with the arguments that will be passed to the function\nwhen it\u2019s invoked. The static type of the first argument to catchError\nis just Function, even though the function that is passed in is expected\nto have either a single parameter of type Object or two parameters of\ntype Object and StackTrace.\n @see https://dart.dev/tools/diagnostic-messages#argument_type_not_assignable_to_error_handler",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "body_might_complete_normally",
        "name": "Body might complete normally",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a method or function has a\nreturn type that\u2019s potentially non-nullable but would implicitly return\nnull if control reached the end of the function.\n @see https://dart.dev/tools/diagnostic-messages#body_might_complete_normally",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "conflicting_constructor_and_static_member",
        "name": "Conflicting constructor and static member",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a named constructor and either a\nstatic method or static field have the same name. Both are accessed using\nthe name of the class, so having the same name makes the reference\nambiguous.\n @see https://dart.dev/tools/diagnostic-messages#conflicting_constructor_and_static_member",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "const_map_key_not_primitive_equality",
        "name": "Const map key not primitive equality",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the class of object used as a\nkey in a constant map literal implements either the == operator, the\ngetter hashCode, or both. The implementation of constant maps uses both\nthe == operator and the hashCode getter, so any implementation other\nthan the ones inherited from Object requires executing arbitrary code at\ncompile time, which isn\u2019t supported.\n @see https://dart.dev/tools/diagnostic-messages#const_map_key_not_primitive_equality",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "dead_null_aware_expression",
        "name": "Dead null aware expression",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic in two cases.The first is when the left operand of an ?? operator can\u2019t be null.\nThe right operand is only evaluated if the left operand has the value\nnull, and because the left operand can\u2019t be null, the right operand is\nnever evaluated.The second is when the left-hand side of an assignment using the ??=\noperator can\u2019t be null. The right-hand side is only evaluated if the\nleft-hand side has the value null, and because the left-hand side can\u2019t\nbe null, the right-hand side is never evaluated.\n @see https://dart.dev/tools/diagnostic-messages#dead_null_aware_expression",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "deprecated_new_in_comment_reference",
        "name": "Deprecated new in comment reference",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a comment reference (the name\nof a declaration enclosed in square brackets in a documentation comment)\nuses the keyword new to refer to a constructor. This form is deprecated.\n @see https://dart.dev/tools/diagnostic-messages#deprecated_new_in_comment_reference",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "duplicate_constructor",
        "name": "Duplicate constructor",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a class declares more than one\nunnamed constructor or when it declares more than one constructor with the\nsame name.\n @see https://dart.dev/tools/diagnostic-messages#duplicate_constructor",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "duplicate_field_name",
        "name": "Duplicate field name",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when either a record literal or a\nrecord type annotation contains a field whose name is the same as a\npreviously declared field in the same literal or type.\n @see https://dart.dev/tools/diagnostic-messages#duplicate_field_name",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "duplicate_ignore",
        "name": "Duplicate ignore",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a diagnostic name appears in an\nignore comment, but the diagnostic is already being ignored, either\nbecause it\u2019s already included in the same ignore comment or because it\nappears in an ignore-in-file comment.\n @see https://dart.dev/tools/diagnostic-messages#duplicate_ignore",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "duplicate_pattern_field",
        "name": "Duplicate pattern field",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a record pattern matches the\nsame field more than once, or when an object pattern matches the same\ngetter more than once.\n @see https://dart.dev/tools/diagnostic-messages#duplicate_pattern_field",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "external_with_initializer",
        "name": "External with initializer",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a field or variable marked with\nthe keyword external has an initializer, or when an external field is\ninitialized in a constructor.\n @see https://dart.dev/tools/diagnostic-messages#external_with_initializer",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "field_initializer_redirecting_constructor",
        "name": "Field initializer redirecting constructor",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a redirecting constructor\ninitializes a field in the object. This isn\u2019t allowed because the instance\nthat has the field hasn\u2019t been created at the point at which it should be\ninitialized.\n @see https://dart.dev/tools/diagnostic-messages#field_initializer_redirecting_constructor",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "illegal_concrete_enum_member",
        "name": "Illegal concrete enum member",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when either an enum declaration, a\nclass that implements Enum, or a mixin with a superclass constraint of\nEnum, declares or inherits a concrete instance member named either\nindex, hashCode, or ==.\n @see https://dart.dev/tools/diagnostic-messages#illegal_concrete_enum_member",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "illegal_enum_values",
        "name": "Illegal enum values",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when either a class that implements\nEnum or a mixin with a superclass constraint of Enum has an instance\nmember named values.\n @see https://dart.dev/tools/diagnostic-messages#illegal_enum_values",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "implicit_super_initializer_missing_arguments",
        "name": "Implicit super initializer missing arguments",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a constructor implicitly\ninvokes the unnamed constructor from the superclass, the unnamed\nconstructor of the superclass has a required parameter, and there\u2019s no\nsuper parameter corresponding to the required parameter.\n @see https://dart.dev/tools/diagnostic-messages#implicit_super_initializer_missing_arguments",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "inconsistent_pattern_variable_logical_or",
        "name": "Inconsistent pattern variable logical or",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a pattern variable that is\ndeclared on all branches of a logical-or pattern doesn\u2019t have the same\ntype on every branch. It is also produced when the variable has a\ndifferent finality on different branches. A pattern variable declared on\nmultiple branches of a logical-or pattern is required to have the same\ntype and finality in each branch, so that the type and finality of the\nvariable can be known in code that\u2019s guarded by the logical-or pattern.\n @see https://dart.dev/tools/diagnostic-messages#inconsistent_pattern_variable_logical_or",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_annotation",
        "name": "Invalid annotation",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an annotation is found that is\nusing something that is neither a variable marked as const or the\ninvocation of a const constructor.Getters can\u2019t be used as annotations.\n @see https://dart.dev/tools/diagnostic-messages#invalid_annotation",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_extension_argument_count",
        "name": "Invalid extension argument count",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an extension override doesn\u2019t\nhave exactly one argument. The argument is the expression used to compute\nthe value of this within the extension method, so there must be one\nargument.\n @see https://dart.dev/tools/diagnostic-messages#invalid_extension_argument_count",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_field_name",
        "name": "Invalid field name",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when either a record literal or a\nrecord type annotation has a field whose name is invalid. The name is\ninvalid if it is:\n @see https://dart.dev/tools/diagnostic-messages#invalid_field_name",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_literal_annotation",
        "name": "Invalid literal annotation",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the [literal][[meta-literal]]\nannotation is applied to anything other than a const constructor.\n @see https://dart.dev/tools/diagnostic-messages#invalid_literal_annotation",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_non_virtual_annotation",
        "name": "Invalid non virtual annotation",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the nonVirtual annotation is\nfound on a declaration other than a member of a class, mixin, or enum, or\nif the member isn\u2019t a concrete instance member.\n @see https://dart.dev/tools/diagnostic-messages#invalid_non_virtual_annotation",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_null_aware_operator",
        "name": "Invalid null aware operator",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a null-aware operator (?.,\n?.., ?[, ?..[, or ...?) is used on a receiver that\u2019s known to be\nnon-nullable.\n @see https://dart.dev/tools/diagnostic-messages#invalid_null_aware_operator",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_pattern_variable_in_shared_case_scope",
        "name": "Invalid pattern variable in shared case scope",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when multiple case clauses in a\nswitch statement share a body, and at least one of them declares a\nvariable that is referenced in the shared statements, but the variable is\neither not declared in all of the case clauses or it is declared in\ninconsistent ways.If the variable isn\u2019t declared in all of the case clauses, then it won\u2019t\nhave a value if one of the clauses that doesn\u2019t declare the variable is\nthe one that matches and executes the body. This includes the situation\nwhere one of the case clauses is the default clause.If the variable is declared in inconsistent ways, either being final in\nsome cases and not final in others or having a different type in\ndifferent cases, then the semantics of what the type or finality of the\nvariable should be are not defined.\n @see https://dart.dev/tools/diagnostic-messages#invalid_pattern_variable_in_shared_case_scope",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_return_type_for_catch_error",
        "name": "Invalid return type for catch error",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an invocation of\nFuture.catchError has an argument whose return type isn\u2019t compatible with\nthe type returned by the instance of Future. At runtime, the method\ncatchError attempts to return the value from the callback as the result\nof the future, which results in another exception being thrown.\n @see https://dart.dev/tools/diagnostic-messages#invalid_return_type_for_catch_error",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_super_formal_parameter_location",
        "name": "Invalid super formal parameter location",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a super parameter is used\nanywhere other than a non-redirecting generative constructor.\n @see https://dart.dev/tools/diagnostic-messages#invalid_super_formal_parameter_location",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invalid_type_argument_in_const_literal",
        "name": "Invalid type argument in const literal",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a type parameter is used as a\ntype argument in a list, map, or set literal that is prefixed by const.\nThis isn\u2019t allowed because the value of the type parameter (the actual type\nthat will be used at runtime) can\u2019t be known at compile time.\n @see https://dart.dev/tools/diagnostic-messages#invalid_type_argument_in_const_literal",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "invocation_of_non_function_expression",
        "name": "Invocation of non function expression",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a function invocation is found,\nbut the name being referenced isn\u2019t the name of a function, or when the\nexpression computing the function doesn\u2019t compute a function.\n @see https://dart.dev/tools/diagnostic-messages#invocation_of_non_function_expression",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "missing_default_value_for_parameter",
        "name": "Missing default value for parameter",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an optional parameter, whether\npositional or named, has a potentially non-nullable type and doesn\u2019t\nspecify a default value. Optional parameters that have no explicit default\nvalue have an implicit default value of null. If the type of the\nparameter doesn\u2019t allow the parameter to have a value of null, then the\nimplicit default value isn\u2019t valid.\n @see https://dart.dev/tools/diagnostic-messages#missing_default_value_for_parameter",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "non_constant_map_element",
        "name": "Non constant map element",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an if element or a spread\nelement in a constant map isn\u2019t a constant element.\n @see https://dart.dev/tools/diagnostic-messages#non_constant_map_element",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "not_assigned_potentially_non_nullable_local_variable",
        "name": "Not assigned potentially non nullable local variable",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a local variable is referenced\nand has all these characteristics:\n @see https://dart.dev/tools/diagnostic-messages#not_assigned_potentially_non_nullable_local_variable",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "not_initialized_non_nullable_instance_field",
        "name": "Not initialized non nullable instance field",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a field is declared and has all\nthese characteristics:\n @see https://dart.dev/tools/diagnostic-messages#not_initialized_non_nullable_instance_field",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "not_initialized_non_nullable_variable",
        "name": "Not initialized non nullable variable",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a static field or top-level\nvariable has a type that\u2019s non-nullable and doesn\u2019t have an initializer.\nFields and variables that don\u2019t have an initializer are normally\ninitialized to null, but the type of the field or variable doesn\u2019t allow\nit to be set to null, so an explicit initializer must be provided.\n @see https://dart.dev/tools/diagnostic-messages#not_initialized_non_nullable_variable",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "recursive_constructor_redirect",
        "name": "Recursive constructor redirect",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a constructor redirects to\nitself, either directly or indirectly, creating an infinite loop.\n @see https://dart.dev/tools/diagnostic-messages#recursive_constructor_redirect",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "redirect_to_invalid_function_type",
        "name": "Redirect to invalid function type",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a factory constructor attempts\nto redirect to another constructor, but the two have incompatible\nparameters. The parameters are compatible if all of the parameters of the\nredirecting constructor can be passed to the other constructor and if the\nother constructor doesn\u2019t require any parameters that aren\u2019t declared by\nthe redirecting constructor.\n @see https://dart.dev/tools/diagnostic-messages#redirect_to_invalid_function_type",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "return_in_generator",
        "name": "Return in generator",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a generator function (one whose\nbody is marked with either async* or sync*) uses either a return\nstatement to return a value or implicitly returns a value because of using\n=>. In any of these cases, they should use yield instead of return.\n @see https://dart.dev/tools/diagnostic-messages#return_in_generator",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "subtype_of_disallowed_type",
        "name": "Subtype of disallowed type",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when one of the restricted classes is\nused in either an extends, implements, with, or on clause. The\nclasses bool, double, FutureOr, int, Null, num, and String\nare all restricted in this way, to allow for more efficient\nimplementations.\n @see https://dart.dev/tools/diagnostic-messages#subtype_of_disallowed_type",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "super_formal_parameter_without_associated_positional",
        "name": "Super formal parameter without associated positional",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when there\u2019s a positional super\nparameter in a constructor and the implicitly or explicitly invoked super\nconstructor doesn\u2019t have a positional parameter at the corresponding\nindex.Positional super parameters are associated with positional parameters in\nthe super constructor by their index. That is, the first super parameter\nis associated with the first positional parameter in the super\nconstructor, the second with the second, and so on.\n @see https://dart.dev/tools/diagnostic-messages#super_formal_parameter_without_associated_positional",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "type_check_with_null",
        "name": "Type check with null",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when there\u2019s a type check (using the\nas operator) where the type is Null. There\u2019s only one value whose type\nis Null, so the code is both more readable and more performant when it\ntests for null explicitly.\n @see https://dart.dev/tools/diagnostic-messages#type_check_with_null",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "type_parameter_supertype_of_its_bound",
        "name": "Type parameter supertype of its bound",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the bound of a type parameter\n(the type following the extends keyword) is either directly or indirectly\nthe type parameter itself. Stating that the type parameter must be the same\nas itself or a subtype of itself or a subtype of itself isn\u2019t helpful\nbecause it will always be the same as itself.\n @see https://dart.dev/tools/diagnostic-messages#type_parameter_supertype_of_its_bound",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_constructor_in_initializer",
        "name": "Undefined constructor in initializer",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a superclass constructor is\ninvoked in the initializer list of a constructor, but the superclass\ndoesn\u2019t define the constructor being invoked.\n @see https://dart.dev/tools/diagnostic-messages#undefined_constructor_in_initializer",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_enum_constructor",
        "name": "Undefined enum constructor",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when the constructor invoked to\ninitialize an enum constant doesn\u2019t exist.\n @see https://dart.dev/tools/diagnostic-messages#undefined_enum_constructor",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_extension_getter",
        "name": "Undefined extension getter",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an extension override is used to\ninvoke a getter, but the getter isn\u2019t defined by the specified extension.\nThe analyzer also produces this diagnostic when a static getter is\nreferenced but isn\u2019t defined by the specified extension.\n @see https://dart.dev/tools/diagnostic-messages#undefined_extension_getter",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_extension_method",
        "name": "Undefined extension method",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an extension override is used to\ninvoke a method, but the method isn\u2019t defined by the specified extension.\nThe analyzer also produces this diagnostic when a static method is\nreferenced but isn\u2019t defined by the specified extension.\n @see https://dart.dev/tools/diagnostic-messages#undefined_extension_method",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_extension_setter",
        "name": "Undefined extension setter",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an extension override is used to\ninvoke a setter, but the setter isn\u2019t defined by the specified extension.\nThe analyzer also produces this diagnostic when a static setter is\nreferenced but isn\u2019t defined by the specified extension.\n @see https://dart.dev/tools/diagnostic-messages#undefined_extension_setter",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "undefined_super_member",
        "name": "Undefined super member",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when an inherited member (method,\ngetter, setter, or operator) is referenced using super, but there\u2019s no\nmember with that name in the superclass chain.\n @see https://dart.dev/tools/diagnostic-messages#undefined_super_member",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "unnecessary_null_comparison",
        "name": "Unnecessary null comparison",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when it finds an equality comparison\n(either == or !=) with one operand of null and the other operand\ncan\u2019t be null. Such comparisons are always either true or false, so\nthey serve no purpose.\n @see https://dart.dev/tools/diagnostic-messages#unnecessary_null_comparison",
        "type": "CODE_SMELL",
        "debt": "5min",
        "active": true
    },
    {
        "key": "wrong_number_of_parameters_for_setter",
        "name": "Wrong number of parameters for setter",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a setter is found that doesn\u2019t\ndeclare exactly one required positional parameter.\n @see https://dart.dev/tools/diagnostic-messages#wrong_number_of_parameters_for_setter",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "wrong_number_of_type_arguments",
        "name": "Wrong number of type arguments",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a type that has type parameters\nis used and type arguments are provided, but the number of type arguments\nisn\u2019t the same as the number of type parameters.The analyzer also produces this diagnostic when a constructor is invoked\nand the number of type arguments doesn\u2019t match the number of type\nparameters declared for the class.\n @see https://dart.dev/tools/diagnostic-messages#wrong_number_of_type_arguments",
        "type": "BUG",
        "debt": "5min",
        "active": true
    },
    {
        "key": "yield_in_non_generator",
        "name": "Yield in non generator",
        "severity": "MINOR",
        "description": "The analyzer produces this diagnostic when a yield or yield* statement\nappears in a function whose body isn\u2019t marked with one of the async* or\nsync* modifiers.\n @see https://dart.dev/tools/diagnostic-messages#yield_in_non_generator",
        "type": "BUG",
        "debt": "5min",
        "active": true
    }
]