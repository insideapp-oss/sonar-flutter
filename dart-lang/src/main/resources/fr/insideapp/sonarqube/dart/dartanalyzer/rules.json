[
    {
        "key": "abstract_field_initializer",
        "name": "Abstract field initializer",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Abstract fields can't have initializers.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a field that has the <code>abstract</code>\nmodifier also has an initializer.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>f</code> is marked as\n<code>abstract</code> and has an initializer:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class C {\nabstract int [!f!] = 0;\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>f</code> is marked as\n<code>abstract</code> and there's an initializer in the constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class C {\nabstract int f;</p>\n<p>C() : [!f!] = 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the field must be abstract, then remove the initializer:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class C {\nabstract int f;\n}\n{% endprettify %}</p>\n<p>If the field isn't required to be abstract, then remove the keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class C {\nint f = 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#abstract_field_initializer"
    },
    {
        "key": "abstract_super_member_reference",
        "name": "Abstract super member reference",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The {0} '{1}' is always abstract in the supertype.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an inherited member is\nreferenced using <code>super</code>, but there is no concrete implementation of the\nmember in the superclass chain. Abstract members can't be invoked.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>B</code> doesn't inherit a\nconcrete implementation of <code>a</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nint get a;\n}\nclass B extends A {\nint get a =&gt; super.[!a!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the invocation of the abstract member, possibly replacing it with an\ninvocation of a concrete member.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#abstract_super_member_reference"
    },
    {
        "key": "always_declare_return_types",
        "name": "Declare method return types.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> declare method return types.</p>\n<p>When declaring a method or function <em>always</em> specify a return type.\nDeclaring return types for functions helps improve your codebase by allowing the\nanalyzer to more adequately check your code for errors that could occur during\nruntime.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">main() { }\n\n_bar() =&gt; _Foo();\n\nclass _Foo {\n  _foo() =&gt; 42;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void main() { }\n\n_Foo _bar() =&gt; _Foo();\n\nclass _Foo {\n  int _foo() =&gt; 42;\n}\n\ntypedef predicate = bool Function(Object o);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/always_declare_return_types.html"
    },
    {
        "key": "always_put_control_body_on_new_line",
        "name": "Separate the control structure expression from its statement.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://flutter.dev/style-guide/\">flutter style guide</a>:</p>\n<p><strong>DO</strong> separate the control structure expression from its statement.</p>\n<p>Don't put the statement part of an <code>if</code>, <code>for</code>, <code>while</code>, <code>do</code> on the same line\nas the expression, even if it is short.  Doing so makes it unclear that there\nis relevant code there.  This is especially important for early returns.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (notReady)\n  return;\n\nif (notReady)\n  return;\nelse\n  print('ok')\n\nwhile (condition)\n  i += 1;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">if (notReady) return;\n\nif (notReady)\n  return;\nelse print('ok')\n\nwhile (condition) i += 1;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/always_put_control_body_on_new_line.html"
    },
    {
        "key": "always_put_required_named_parameters_first",
        "name": "Put required named parameters first.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> specify <code>required</code> on named parameter before other named parameters.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">m({required a, b, c}) ;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">m({b, c, required a}) ;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">m({@required a, b, c}) ;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">m({b, c, @required a}) ;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/always_put_required_named_parameters_first.html"
    },
    {
        "key": "always_require_non_null_named_parameters",
        "name": "Specify `@required` on named parameters without defaults.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> specify <code>@required</code> on named parameters without a default value on which \nan <code>assert(param != null)</code> is done.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">m1({@required a}) {\n  assert(a != null);\n}\n\nm2({a: 1}) {\n  assert(a != null);\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">m1({a}) {\n  assert(a != null);\n}\n</code></pre>\n<p>NOTE: Only asserts at the start of the bodies will be taken into account.</p>\n\n@see https://dart-lang.github.io/linter/lints/always_require_non_null_named_parameters.html"
    },
    {
        "key": "always_specify_types",
        "name": "Specify type annotations.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://flutter.dev/style-guide/\">flutter style guide</a>:</p>\n<p><strong>DO</strong> specify type annotations.</p>\n<p>Avoid <code>var</code> when specifying that a type is unknown and short-hands that elide\ntype annotations.  Use <code>dynamic</code> if you are being explicit that the type is\nunknown.  Use <code>Object</code> if you are being explicit that you want an object that\nimplements <code>==</code> and <code>hashCode</code>.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">int foo = 10;\nfinal Bar bar = Bar();\nString baz = 'hello';\nconst int quux = 20;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var foo = 10;\nfinal bar = Bar();\nconst quux = 20;\n</code></pre>\n<p>NOTE: Using the the <code>@optionalTypeArgs</code> annotation in the <code>meta</code> package, API\nauthors can special-case type variables whose type needs to by dynamic but whose\ndeclaration should be treated as optional.  For example, suppose you have a\n<code>Key</code> object whose type parameter you'd like to treat as optional.  Using the\n<code>@optionalTypeArgs</code> would look like this:</p>\n<pre><code class=\"language-dart\">import 'package:meta/meta.dart';\n\n@optionalTypeArgs\nclass Key&lt;T&gt; {\n ...\n}\n\nmain() {\n  Key s = Key(); // OK!\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/always_specify_types.html"
    },
    {
        "key": "always_use_package_imports",
        "name": "Avoid relative imports for files in `lib/`.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><em>DO</em> avoid relative imports for files in <code>lib/</code>.</p>\n<p>When mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways. One way to avoid\nthat is to ensure you consistently use absolute imports for files withing the\n<code>lib/</code> directory.</p>\n<p>This is the opposite of 'prefer_relative_imports'.\nMight be used with 'avoid_relative_lib_imports' to avoid relative imports of\nfiles within <code>lib/</code> directory outside of it. (for example <code>test/</code>)</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">import 'package:foo/bar.dart';\n\nimport 'package:foo/baz.dart';\n\nimport 'package:foo/src/baz.dart';\n...\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'baz.dart';\n\nimport 'src/bag.dart'\n\nimport '../lib/baz.dart';\n\n...\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/always_use_package_imports.html"
    },
    {
        "key": "ambiguous_export",
        "name": "Ambiguous export",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' is defined in the libraries '{1}' and '{2}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when two or more export directives\ncause the same name to be exported from multiple libraries.</p>\n<h4>Example</h4>\n<p>Given a file named <code>a.dart</code> containing</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}\n{% endprettify %}</p>\n<p>And a file named <code>b.dart</code> containing</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the name <code>C</code> is being\nexported from both <code>a.dart</code> and <code>b.dart</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nexport 'a.dart';\nexport [!'b.dart'!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If none of the names in one of the libraries needs to be exported, then\nremove the unnecessary export directives:</p>\n<p>{% prettify dart tag=pre+code %}\nexport 'a.dart';\n{% endprettify %}</p>\n<p>If all of the export directives are needed, then hide the name in all\nexcept one of the directives:</p>\n<p>{% prettify dart tag=pre+code %}\nexport 'a.dart';\nexport 'b.dart' hide C;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#ambiguous_export"
    },
    {
        "key": "ambiguous_extension_member_access",
        "name": "Ambiguous extension member access",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A member named '{0}' is defined in extensions '{1}' and '{2}' and neither is\nmore specific.</em></p>\n<h4>Description</h4>\n<p>When code refers to a member of an object (for example, <code>o.m()</code> or <code>o.m</code> or\n<code>o[i]</code>) where the static type of <code>o</code> doesn't declare the member (<code>m</code> or\n<code>[]</code>, for example), then the analyzer tries to find the member in an\nextension. For example, if the member is <code>m</code>, then the analyzer looks for\nextensions that declare a member named <code>m</code> and have an extended type that\nthe static type of <code>o</code> can be assigned to. When there's more than one such\nextension in scope, the extension whose extended type is most specific is\nselected.</p>\n<p>The analyzer produces this diagnostic when none of the extensions has an\nextended type that's more specific than the extended types of all of the\nother extensions, making the reference to the member ambiguous.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because there's no way to\nchoose between the member in <code>E1</code> and the member in <code>E2</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E1 on String {\nint get charCount =&gt; 1;\n}</p>\n<p>extension E2 on String {\nint get charCount =&gt; 2;\n}</p>\n<p>void f(String s) {\nprint(s.[!charCount!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need both extensions, then you can delete or hide one of them.</p>\n<p>If you need both, then explicitly select the one you want to use by using\nan extension override:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E1 on String {\nint get charCount =&gt; length;\n}</p>\n<p>extension E2 on String {\nint get charCount =&gt; length;\n}</p>\n<p>void f(String s) {\nprint(E2(s).charCount);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#ambiguous_extension_member_access"
    },
    {
        "key": "ambiguous_import",
        "name": "Ambiguous import",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' is defined in the libraries {1}.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a name is referenced that is\ndeclared in two or more imported libraries.</p>\n<h4>Examples</h4>\n<p>Given a library (<code>a.dart</code>) that defines a class (<code>C</code> in this example):</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}\nclass C {}\n{% endprettify %}</p>\n<p>And a library (<code>b.dart</code>) that defines a different class with the same name:</p>\n<p>{% prettify dart tag=pre+code %}\nclass B {}\nclass C {}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart';\nimport 'b.dart';</p>\n<p>void f([!C!] c1, [!C!] c2) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If any of the libraries aren't needed, then remove the import directives\nfor them:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart';</p>\n<p>void f(C c1, C c2) {}\n{% endprettify %}</p>\n<p>If the name is still defined by more than one library, then add a <code>hide</code>\nclause to the import directives for all except one library:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' hide C;\nimport 'b.dart';</p>\n<p>void f(C c1, C c2) {}\n{% endprettify %}</p>\n<p>If you must be able to reference more than one of these types, then add a\nprefix to each of the import directives, and qualify the references with\nthe appropriate prefix:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' as a;\nimport 'b.dart' as b;</p>\n<p>void f(a.C c1, b.C c2) {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#ambiguous_import"
    },
    {
        "key": "ambiguous_set_or_map_literal_both",
        "name": "Ambiguous set or map literal both",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>This literal contains both 'Map' and 'Iterable' spreads, which makes it\nimpossible to determine whether the literal is a map or a set.</em></p>\n<h4>Description</h4>\n<p>Because map and set literals use the same delimiters (<code>{</code> and <code>}</code>), the\nanalyzer looks at the type arguments and the elements to determine which\nkind of literal you meant. When there are no type arguments and all of the\nelements are spread elements (which are allowed in both kinds of literals),\nthen the analyzer uses the types of the expressions that are being spread.\nIf all of the expressions have the type <code>Iterable</code>, then it's a set\nliteral; if they all have the type <code>Map</code>, then it's a map literal.</p>\n<p>The analyzer produces this diagnostic when some of the expressions being\nspread have the type <code>Iterable</code> and others have the type <code>Map</code>, making it\nimpossible for the analyzer to determine whether you are writing a map\nliteral or a set literal.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nunion(Map&lt;String, String&gt; a, List<String> b, Map&lt;String, String&gt; c) =&gt;\n[!{...a, ...b, ...c}!];\n{% endprettify %}</p>\n<p>The list <code>b</code> can only be spread into a set, and the maps <code>a</code> and <code>c</code> can\nonly be spread into a map, and the literal can't be both.</p>\n<h4>Common fixes</h4>\n<p>There are two common ways to fix this problem. The first is to remove all\nof the spread elements of one kind or another, so that the elements are\nconsistent. In this case, that likely means removing the list and deciding\nwhat to do about the now unused parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nunion(Map&lt;String, String&gt; a, List<String> b, Map&lt;String, String&gt; c) =&gt;\n{...a, ...c};\n{% endprettify %}</p>\n<p>The second fix is to change the elements of one kind into elements that are\nconsistent with the other elements. For example, you can add the elements\nof the list as keys that map to themselves:</p>\n<p>{% prettify dart tag=pre+code %}\nunion(Map&lt;String, String&gt; a, List<String> b, Map&lt;String, String&gt; c) =&gt;\n{...a, for (String s in b) s: s, ...c};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#ambiguous_set_or_map_literal_both"
    },
    {
        "key": "ambiguous_set_or_map_literal_either",
        "name": "Ambiguous set or map literal either",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>This literal must be either a map or a set, but the elements don't have enough\ninformation for type inference to work.</em></p>\n<h4>Description</h4>\n<p>Because map and set literals use the same delimiters (<code>{</code> and <code>}</code>), the\nanalyzer looks at the type arguments and the elements to determine which\nkind of literal you meant. When there are no type arguments and all of the\nelements are spread elements (which are allowed in both kinds of literals)\nthen the analyzer uses the types of the expressions that are being spread.\nIf all of the expressions have the type <code>Iterable</code>, then it's a set\nliteral; if they all have the type <code>Map</code>, then it's a map literal.</p>\n<p>This diagnostic is produced when none of the expressions being spread have\na type that allows the analyzer to decide whether you were writing a map\nliteral or a set literal.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nunion(a, b) =&gt; [!{...a, ...b}!];\n{% endprettify %}</p>\n<p>The problem occurs because there are no type arguments, and there is no\ninformation about the type of either <code>a</code> or <code>b</code>.</p>\n<h4>Common fixes</h4>\n<p>There are three common ways to fix this problem. The first is to add type\narguments to the literal. For example, if the literal is intended to be a\nmap literal, you might write something like this:</p>\n<p>{% prettify dart tag=pre+code %}\nunion(a, b) =&gt; &lt;String, String&gt;{...a, ...b};\n{% endprettify %}</p>\n<p>The second fix is to add type information so that the expressions have\neither the type <code>Iterable</code> or the type <code>Map</code>. You can add an explicit cast\nor, in this case, add types to the declarations of the two parameters:</p>\n<p>{% prettify dart tag=pre+code %}\nunion(List<int> a, List<int> b) =&gt; {...a, ...b};\n{% endprettify %}</p>\n<p>The third fix is to add context information. In this case, that means\nadding a return type to the function:</p>\n<p>{% prettify dart tag=pre+code %}\nSet<String> union(a, b) =&gt; {...a, ...b};\n{% endprettify %}</p>\n<p>In other cases, you might add a type somewhere else. For example, say the\noriginal code looks like this:</p>\n<p>{% prettify dart tag=pre+code %}\nunion(a, b) {\nvar x = [!{...a, ...b}!];\nreturn x;\n}\n{% endprettify %}</p>\n<p>You might add a type annotation on <code>x</code>, like this:</p>\n<p>{% prettify dart tag=pre+code %}\nunion(a, b) {\nMap&lt;String, String&gt; x = {...a, ...b};\nreturn x;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#ambiguous_set_or_map_literal_either"
    },
    {
        "key": "annotate_overrides",
        "name": "Annotate overridden members.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> annotate overridden methods and fields.</p>\n<p>This practice improves code readability and helps protect against\nunintentionally overriding superclass members.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">abstract class Dog {\n  String get breed;\n  void bark() {}\n}\n\nclass Husky extends Dog {\n  @override\n  final String breed = 'Husky';\n  @override\n  void bark() {}\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Cat {\n  int get lives =&gt; 9;\n}\n\nclass Lucky extends Cat {\n  final int lives = 14;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/annotate_overrides.html"
    },
    {
        "key": "argument_type_not_assignable",
        "name": "Argument type not assignable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The argument type '{0}' can't be assigned to the parameter type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the static type of an argument\ncan't be assigned to the static type of the corresponding parameter.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because a <code>num</code> can't be\nassigned to a <code>String</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nString f(String x) =&gt; x;\nString g(num y) =&gt; f([!y!]);\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If possible, rewrite the code so that the static type is assignable. In the\nexample above you might be able to change the type of the parameter <code>y</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nString f(String x) =&gt; x;\nString g(String y) =&gt; f(y);\n{% endprettify %}</p>\n<p>If that fix isn't possible, then add code to handle the case where the\nargument value isn't the required type. One approach is to coerce other\ntypes to the required type:</p>\n<p>{% prettify dart tag=pre+code %}\nString f(String x) =&gt; x;\nString g(num y) =&gt; f(y.toString());\n{% endprettify %}</p>\n<p>Another approach is to add explicit type tests and fallback code:</p>\n<p>{% prettify dart tag=pre+code %}\nString f(String x) =&gt; x;\nString g(num y) =&gt; f(y is String ? y : '');\n{% endprettify %}</p>\n<p>If you believe that the runtime type of the argument will always be the\nsame as the static type of the parameter, and you're willing to risk having\nan exception thrown at runtime if you're wrong, then add an explicit cast:</p>\n<p>{% prettify dart tag=pre+code %}\nString f(String x) =&gt; x;\nString g(num y) =&gt; f(y as String);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#argument_type_not_assignable"
    },
    {
        "key": "argument_type_not_assignable_to_error_handler",
        "name": "Argument type not assignable to error handler",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The argument type '{0}' can't be assigned to the parameter type '{1}\nFunction(Object)' or '{1} Function(Object, StackTrace)'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an invocation of\n<code>Future.catchError</code> has an argument that is a function whose parameters\naren't compatible with the arguments that will be passed to the function\nwhen it's invoked. The static type of the first argument to <code>catchError</code>\nis just <code>Function</code>, even though the function that is passed in is expected\nto have either a single parameter of type <code>Object</code> or two parameters of\ntype <code>Object</code> and <code>StackTrace</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the closure being\npassed to <code>catchError</code> doesn't take any parameters, but the function is\nrequired to take at least one parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Future<int> f) {\nf.catchError([!() =&gt; 0!]);\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the closure being\npassed to <code>catchError</code> takes three parameters, but it can't have more than\ntwo required parameters:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Future<int> f) {\nf.catchError([!(one, two, three) =&gt; 0!]);\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because even though the closure\nbeing passed to <code>catchError</code> takes one parameter, the closure doesn't have\na type that is compatible with <code>Object</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Future<int> f) {\nf.catchError([!(String error) =&gt; 0!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the function being passed to <code>catchError</code> so that it has either one\nor two required parameters, and the parameters have the required types:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Future<int> f) {\nf.catchError((Object error) =&gt; 0);\n}\n{% endprettify %}</p>"
    },
    {
        "key": "assert_in_redirecting_constructor",
        "name": "Assert in redirecting constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A redirecting constructor can't have an 'assert' initializer.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a redirecting constructor (a\nconstructor that redirects to another constructor in the same class) has an\nassert in the initializer list.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the unnamed constructor\nis a redirecting constructor and also has an assert in the initializer\nlist:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC(int x) : [!assert(x &gt; 0)!], this.name();\nC.name() {}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the assert isn't needed, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC(int x) : this.name();\nC.name() {}\n}\n{% endprettify %}</p>\n<p>If the assert is needed, then convert the constructor into a factory\nconstructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfactory C(int x) {\nassert(x &gt; 0);\nreturn C.name();\n}\nC.name() {}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#assert_in_redirecting_constructor"
    },
    {
        "key": "assignment_of_do_not_store",
        "name": "Assignment of do not store",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "'{0}' is marked 'doNotStore' and shouldn't be assigned to a field or top-level variable.\n\nTry removing the assignment."
    },
    {
        "key": "assignment_to_const",
        "name": "Assignment to const",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Constant variables can't be assigned a value.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds an assignment to a\ntop-level variable, a static field, or a local variable that has the\n<code>const</code> modifier. The value of a compile-time constant can't be changed at\nruntime.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>c</code> is being assigned a\nvalue even though it has the <code>const</code> modifier:</p>\n<p>{% prettify dart tag=pre+code %}\nconst c = 0;</p>\n<p>void f() {\n[!c!] = 1;\nprint(c);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the variable must be assignable, then remove the <code>const</code> modifier:</p>\n<p>{% prettify dart tag=pre+code %}\nvar c = 0;</p>\n<p>void f() {\nc = 1;\nprint(c);\n}\n{% endprettify %}</p>\n<p>If the constant shouldn't be changed, then either remove the assignment or\nuse a local variable in place of references to the constant:</p>\n<p>{% prettify dart tag=pre+code %}\nconst c = 0;</p>\n<p>void f() {\nvar v = 1;\nprint(v);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#assignment_to_const"
    },
    {
        "key": "assignment_to_final",
        "name": "Assignment to final",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{0}' can't be used as a setter because it's final.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds an invocation of a\nsetter, but there's no setter because the field with the same name was\ndeclared to be <code>final</code> or <code>const</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>v</code> is final:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal v = 0;\n}</p>\n<p>f(C c) {\nc.[!v!] = 1;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to be able to set the value of the field, then remove the\nmodifier <code>final</code> from the field:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint v = 0;\n}</p>\n<p>f(C c) {\nc.v = 1;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#assignment_to_final"
    },
    {
        "key": "assignment_to_final_local",
        "name": "Assignment to final local",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The final variable '{0}' can only be set once.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a local variable that was\ndeclared to be final is assigned after it was initialized.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> is final, so it\ncan't have a value assigned to it after it was initialized:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nfinal x = 0;\n[!x!] = 3;\nprint(x);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the keyword <code>final</code>, and replace it with <code>var</code> if there's no type\nannotation:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nvar x = 0;\nx = 3;\nprint(x);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#assignment_to_final_local"
    },
    {
        "key": "assignment_to_final_no_setter",
        "name": "Assignment to final no setter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>There isnâ€™t a setter named '{0}' in class '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a reference to a setter is\nfound; there is no setter defined for the type; but there is a getter\ndefined with the same name.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because there is no setter\nnamed <code>x</code> in <code>C</code>, but there is a getter named <code>x</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint get x =&gt; 0;\nset y(int p) {}\n}</p>\n<p>void f(C c) {\nc.[!x!] = 1;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you want to invoke an existing setter, then correct the name:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint get x =&gt; 0;\nset y(int p) {}\n}</p>\n<p>void f(C c) {\nc.y = 1;\n}\n{% endprettify %}</p>\n<p>If you want to invoke the setter but it just doesn't exist yet, then\ndeclare it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint get x =&gt; 0;\nset x(int p) {}\nset y(int p) {}\n}</p>\n<p>void f(C c) {\nc.x = 1;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#assignment_to_final_no_setter"
    },
    {
        "key": "assignment_to_function",
        "name": "Assignment to function",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Functions can't be assigned a value.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the name of a function appears\non the left-hand side of an assignment expression.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the assignment to the\nfunction <code>f</code> is invalid:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {}</p>\n<p>void g() {\n[!f!] = () {};\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the right-hand side should be assigned to something else, such as a\nlocal variable, then change the left-hand side:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {}</p>\n<p>void g() {\nvar x = () {};\nprint(x);\n}\n{% endprettify %}</p>\n<p>If the intent is to change the implementation of the function, then define\na function-valued variable instead of a function:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid Function() f = () {};</p>\n<p>void g() {\nf = () {};\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#assignment_to_function"
    },
    {
        "key": "assignment_to_method",
        "name": "Assignment to method",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Methods can't be assigned a value.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the target of an assignment is a\nmethod.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> can't be assigned a\nvalue because it's a method:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nvoid f() {}</p>\n<p>void g() {\n[!f!] = null;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Rewrite the code so that there isn't an assignment to a method.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#assignment_to_method"
    },
    {
        "key": "assignment_to_type",
        "name": "Assignment to type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Types can't be assigned a value.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the name of a type name appears\non the left-hand side of an assignment expression.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the assignment to the\nclass <code>C</code> is invalid:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}</p>\n<p>void f() {\n[!C!] = null;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the right-hand side should be assigned to something else, such as a\nlocal variable, then change the left-hand side:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {}</p>\n<p>void g() {\nvar c = null;\nprint(c);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#assignment_to_type"
    },
    {
        "key": "async_for_in_wrong_context",
        "name": "Async for in wrong context",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The async for-in loop can only be used in an async function.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an async for-in loop is found in\na function or method whose body isn't marked as being either <code>async</code> or\n<code>async*</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the body of <code>f</code> isn't\nmarked as being either <code>async</code> or <code>async*</code>, but <code>f</code> contains an async\nfor-in loop:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(list) {\nawait for (var e [!in!] list) {\nprint(e);\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the function should return a <code>Future</code>, then mark the body with <code>async</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nFuture<void> f(list) async {\nawait for (var e in list) {\nprint(e);\n}\n}\n{% endprettify %}</p>\n<p>If the function should return a <code>Stream</code> of values, then mark the body with\n<code>async*</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nStream<void> f(list) async* {\nawait for (var e in list) {\nprint(e);\n}\n}\n{% endprettify %}</p>\n<p>If the function should be synchronous, then remove the <code>await</code> before the\nloop:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(list) {\nfor (var e in list) {\nprint(e);\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#async_for_in_wrong_context"
    },
    {
        "key": "avoid_annotating_with_dynamic",
        "name": "Avoid annotating with dynamic when not required.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> annotating with dynamic when not required.</p>\n<p>As <code>dynamic</code> is the assumed return value of a function or method, it is usually\nnot necessary to annotate it.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">dynamic lookUpOrDefault(String name, Map map, dynamic defaultValue) {\n  var value = map[name];\n  if (value != null) return value;\n  return defaultValue;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">lookUpOrDefault(String name, Map map, defaultValue) {\n  var value = map[name];\n  if (value != null) return value;\n  return defaultValue;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_annotating_with_dynamic.html"
    },
    {
        "key": "avoid_as",
        "name": "Avoid using `as`.",
        "type": "CODE_SMELL",
        "status": "DEPRECATED",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> using <code>as</code>.</p>\n<p>If you know the type is correct, use an assertion or assign to a more\nnarrowly-typed variable (this avoids the type check in release mode; <code>as</code> is not\ncompiled out in release mode).  If you don't know whether the type is\ncorrect, check using <code>is</code> (this avoids the exception that <code>as</code> raises).</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">(pm as Person).firstName = 'Seth';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (pm is Person)\n  pm.firstName = 'Seth';\n</code></pre>\n<p>but certainly not</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">try {\n   (pm as Person).firstName = 'Seth';\n} on CastError { }\n</code></pre>\n<p>Note that an exception is made in the case of <code>dynamic</code> since the cast has no\nperformance impact.</p>\n<p><strong>OK:</strong></p>\n<pre><code class=\"language-dart\">HasScrollDirection scrollable = renderObject as dynamic;\n</code></pre>\n<p><strong>DEPRECATED:</strong> This advice is no longer recommended.</p>\n<p>The rule will be removed in a future Linter release.</p>\n\n@see https://dart-lang.github.io/linter/lints/avoid_as.html"
    },
    {
        "key": "avoid_bool_literals_in_conditional_expressions",
        "name": "Avoid bool literals in conditional expressions.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> bool literals in conditional expressions.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">condition ? true : boolExpression\ncondition ? false : boolExpression\ncondition ? boolExpression : true\ncondition ? boolExpression : false\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">condition || boolExpression\n!condition &amp;&amp; boolExpression\n!condition || boolExpression\ncondition &amp;&amp; boolExpression\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_bool_literals_in_conditional_expressions.html"
    },
    {
        "key": "avoid_catches_without_on_clauses",
        "name": "Avoid catches without on clauses.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> catches without on clauses.</p>\n<p>Using catch clauses without on clauses make your code prone to encountering\nunexpected errors that won't be thrown (and thus will go unnoticed).</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">try {\n somethingRisky()\n}\ncatch(e) {\n  doSomething(e);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">try {\n somethingRisky()\n}\non Exception catch(e) {\n  doSomething(e);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_catches_without_on_clauses.html"
    },
    {
        "key": "avoid_catching_errors",
        "name": "Don't explicitly catch Error or types that implement it.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> explicitly catch Error or types that implement it.</p>\n<p>Errors differ from Exceptions in that Errors can be analyzed and prevented prior\nto runtime.  It should almost never be necessary to catch an error at runtime.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">try {\n  somethingRisky();\n} on Error catch(e) {\n  doSomething(e);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">try {\n  somethingRisky();\n} on Exception catch(e) {\n  doSomething(e);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_catching_errors.html"
    },
    {
        "key": "avoid_classes_with_only_static_members",
        "name": "Avoid defining a class that contains only static members.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> defining a class that contains only static members.</p>\n<p>Creating classes with the sole purpose of providing utility or otherwise static\nmethods is discouraged.  Dart allows functions to exist outside of classes for\nthis very reason.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class DateUtils {\n  static DateTime mostRecent(List&lt;DateTime&gt; dates) {\n    return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);\n  }\n}\n\nclass _Favorites {\n  static const mammal = 'weasel';\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">DateTime mostRecent(List&lt;DateTime&gt; dates) {\n  return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);\n}\n\nconst _favoriteMammal = 'weasel';\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_classes_with_only_static_members.html"
    },
    {
        "key": "avoid_double_and_int_checks",
        "name": "Avoid double and int checks.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> to check if type is double or int.</p>\n<p>When compiled to JS, integer values are represented as floats. That can lead to\nsome unexpected behavior when using either <code>is</code> or <code>is!</code> where the type is\neither <code>int</code> or <code>double</code>.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">f(num x) {\n  if (x is double) {\n    ...\n  } else if (x is int) {\n    ...\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">f(dynamic x) {\n  if (x is num) {\n    ...\n  } else {\n    ...\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_double_and_int_checks.html"
    },
    {
        "key": "avoid_dynamic_calls",
        "name": "Avoid method calls or property accesses on a \"dynamic\" target.",
        "type": "BUG",
        "status": "BETA",
        "severity": "MAJOR",
        "description": "<p><strong>DO</strong> avoid method calls or accessing properties on an object that is either\nexplicitly or implicitly statically typed \"dynamic\". Dynamic calls are treated\nslightly different in every runtime environment and compiler, but most\nproduction modes (and even some development modes) have both compile size and\nruntime performance penalties associated with dynamic calls.</p>\n<p>Additionally, targets typed \"dynamic\" disables most static analysis, meaning it\nis easier to lead to a runtime \"NoSuchMethodError\" or \"NullError\" than properly\nstatically typed Dart code.</p>\n<p>There is an exception to methods and properties that exist on \"Object?\":</p>\n<ul>\n<li>a.hashCode</li>\n<li>a.runtimeType</li>\n<li>a.noSuchMethod(someInvocation)</li>\n<li>a.toString()</li>\n</ul>\n<p>... these members are dynamically dispatched in the web-based runtimes, but not\nin the VM-based ones. Additionally, they are so common that it would be very\npunishing to disallow <code>any.toString()</code> or <code>any == true</code>, for example.</p>\n<p>Note that despite \"Function\" being a type, the semantics are close to identical\nto \"dynamic\", and calls to an object that is typed \"Function\" will also trigger\nthis lint.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void explicitDynamicType(dynamic object) {\n  print(object.foo());\n}\n\nvoid implicitDynamicType(object) {\n  print(object.foo());\n}\n\nabstract class SomeWrapper {\n  T doSomething&lt;T&gt;();\n}\n\nvoid inferredDynamicType(SomeWrapper wrapper) {\n  var object = wrapper.doSomething();\n  print(object.foo());\n}\n\nvoid callDynamic(dynamic function) {\n  function();\n}\n\nvoid functionType(Function function) {\n  function();\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void explicitType(Fooable object) {\n  object.foo();\n}\n\nvoid castedType(dynamic object) {\n  (object as Fooable).foo();\n}\n\nabstract class SomeWrapper {\n  T doSomething&lt;T&gt;();\n}\n\nvoid inferredType(SomeWrapper wrapper) {\n  var object = wrapper.doSomething&lt;Fooable&gt;();\n  object.foo();\n}\n\nvoid functionTypeWithParameters(Function() function) {\n  function();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_dynamic_calls.html"
    },
    {
        "key": "avoid_empty_else",
        "name": "Avoid empty else statements.",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><strong>AVOID</strong> empty else statements.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">if (x &gt; y)\n  print(\"1\");\nelse ;\n  print(\"2\");\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_empty_else.html"
    },
    {
        "key": "avoid_equals_and_hash_code_on_mutable_classes",
        "name": "Avoid overloading operator == and hashCode on classes not marked `@immutable`.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> overloading operator == and hashCode on classes not marked <code>@immutable</code>.</p>\n<p>If a class is not immutable, overloading operator == and hashCode can lead to\nunpredictable and undesirable behavior when used in collections. See\nhttps://dart.dev/guides/language/effective-dart/design#avoid-defining-custom-equality-for-mutable-classes\nfor more information.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">@immutable\nclass A {\n  final String key;\n  const A(this.key);\n  @override\n  operator ==(other) =&gt; other is A &amp;&amp; other.key == key;\n  @override\n  int hashCode() =&gt; key.hashCode;\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class B {\n  String key;\n  const B(this.key);\n  @override\n  operator ==(other) =&gt; other is B &amp;&amp; other.key == key;\n  @override\n  int hashCode() =&gt; key.hashCode;\n}\n</code></pre>\n<p>NOTE: The lint checks the use of the @immutable annotation, and will trigger\neven if the class is otherwise not mutable. Thus:</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class C {\n  final String key;\n  const C(this.key);\n  @override\n  operator ==(other) =&gt; other is B &amp;&amp; other.key == key;\n  @override\n  int hashCode() =&gt; key.hashCode;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_equals_and_hash_code_on_mutable_classes.html"
    },
    {
        "key": "avoid_escaping_inner_quotes",
        "name": "Avoid escaping inner quotes by converting surrounding quotes.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Avoid escaping inner quotes by converting surrounding quotes.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var s = 'It\\'s not fun';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var s = \"It's not fun\";\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_escaping_inner_quotes.html"
    },
    {
        "key": "avoid_field_initializers_in_const_classes",
        "name": "Avoid field initializers in const classes.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> field initializers in const classes.</p>\n<p>Instead of <code>final x = const expr;</code>, you should write <code>get x =&gt; const expr;</code> and\nnot allocate a useless field. As of April 2018 this is true for the VM, but not\nfor code that will be compiled to JS.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  final a = const [];\n  const A();\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  get a =&gt; const [];\n  const A();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_field_initializers_in_const_classes.html"
    },
    {
        "key": "avoid_function_literals_in_foreach_calls",
        "name": "Avoid using `forEach` with a function literal.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> using <code>forEach</code> with a function literal.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">people.forEach((person) {\n  ...\n});\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">for (var person in people) {\n  ...\n}\n\npeople.forEach(print);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_function_literals_in_foreach_calls.html"
    },
    {
        "key": "avoid_implementing_value_types",
        "name": "Don't implement classes that override `==`.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> implement classes that override <code>==</code>.</p>\n<p>The <code>==</code> operator is contractually required to be an equivalence relation;\nthat is, symmetrically for all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code>\nmust either both be true, or both be false.</p>\n<blockquote>\n<p><em>NOTE</em>: Dart does not have true <em>value types</em>, so instead we consider a class\nthat implements <code>==</code>  as a <em>proxy</em> for identifying value types.</p>\n</blockquote>\n<p>When using <code>implements</code>, you do not inherit the method body of <code>==</code>, making it\nnearly impossible to follow the contract of <code>==</code>. Classes that override <code>==</code>\ntypically are usable directly in tests <em>without</em> creating mocks or fakes as\nwell. For example, for a given class <code>Size</code>:</p>\n<pre><code class=\"language-dart\">class Size {\n  final int inBytes;\n  const Size(this.inBytes);\n\n  @override\n  bool operator ==(Object other) =&gt; other is Size &amp;&amp; other.inBytes == inBytes;\n\n  @override\n  int get hashCode =&gt; inBytes.hashCode;\n}\n</code></pre>\n<p><strong>BAD</strong>:</p>\n<pre><code class=\"language-dart\">class CustomSize implements Size {\n  final int inBytes;\n  const CustomSize(this.inBytes);\n\n  int get inKilobytes =&gt; inBytes ~/ 1000;\n}\n</code></pre>\n<p><strong>BAD</strong>:</p>\n<pre><code class=\"language-dart\">import 'package:test/test.dart';\nimport 'size.dart';\n\nclass FakeSize implements Size {\n  int inBytes = 0;\n}\n\nvoid main() {\n  test('should not throw on a size &gt;1Kb', () {\n    expect(() =&gt; someFunction(FakeSize()..inBytes = 1001), returnsNormally);\n  });\n}\n</code></pre>\n<p><strong>GOOD</strong>:</p>\n<pre><code class=\"language-dart\">class ExtendedSize extends Size {\n  ExtendedSize(int inBytes) : super(inBytes);\n\n  int get inKilobytes =&gt; inBytes ~/ 1000;\n}\n</code></pre>\n<p><strong>GOOD</strong>:</p>\n<pre><code class=\"language-dart\">import 'package:test/test.dart';\nimport 'size.dart';\n\nvoid main() {\n  test('should not throw on a size &gt;1Kb', () {\n    expect(() =&gt; someFunction(Size(1001)), returnsNormally);\n  });\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_implementing_value_types.html"
    },
    {
        "key": "avoid_init_to_null",
        "name": "Don't explicitly initialize variables to null.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From <a href=\"https://dart.dev/guides/language/effective-dart/usage#dont-explicitly-initialize-variables-to-null\">effective dart</a>:</p>\n<p><strong>DON'T</strong> explicitly initialize variables to null.</p>\n<p>In Dart, a variable or field that is not explicitly initialized automatically\ngets initialized to null.  This is reliably specified by the language.  There's\nno concept of \"uninitialized memory\" in Dart.  Adding <code>= null</code> is redundant and\nunneeded.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">int _nextId;\n\nclass LazyId {\n  int _id;\n\n  int get id {\n    if (_nextId == null) _nextId = 0;\n    if (_id == null) _id = _nextId++;\n\n    return _id;\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">int _nextId = null;\n\nclass LazyId {\n  int _id = null;\n\n  int get id {\n    if (_nextId == null) _nextId = 0;\n    if (_id == null) _id = _nextId++;\n\n    return _id;\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_init_to_null.html"
    },
    {
        "key": "avoid_js_rounded_ints",
        "name": "Avoid JavaScript rounded ints.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> integer literals that cannot be represented exactly when compiled to\nJavaScript.</p>\n<p>When a program is compiled to JavaScript <code>int</code> and <code>double</code> become JavaScript\nNumbers. Too large integers (<code>value &lt; Number.MIN_SAFE_INTEGER</code> or\n<code>value &gt; Number.MAX_SAFE_INTEGER</code>) may be rounded to the closest Number value.</p>\n<p>For instance <code>1000000000000000001</code> cannot be represented exactly as a JavaScript\nNumber, so <code>1000000000000000000</code> will be used instead.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">int value = 9007199254740995;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">BigInt value = BigInt.parse('9007199254740995');\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_js_rounded_ints.html"
    },
    {
        "key": "avoid_multiple_declarations_per_line",
        "name": "Don't declare multiple variables on a single line.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> declare multiple variables on a single line.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">String? foo, bar, baz;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">String? foo;\nString? bar;\nString? baz;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_multiple_declarations_per_line.html"
    },
    {
        "key": "avoid_null_checks_in_equality_operators",
        "name": "Don't check for null in custom == operators.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> check for null in custom == operators.</p>\n<p>As null is a special type, no class can be equivalent to it.  Thus, it is\nredundant to check whether the other instance is null.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Person {\n  final String name;\n\n  @override\n  operator ==(other) =&gt;\n      other != null &amp;&amp; other is Person &amp;&amp; name == other.name;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Person {\n  final String name;\n\n  @override\n  operator ==(other) =&gt; other is Person &amp;&amp; name == other.name;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_null_checks_in_equality_operators.html"
    },
    {
        "key": "avoid_positional_boolean_parameters",
        "name": "Avoid positional boolean parameters.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> positional boolean parameters.</p>\n<p>Positional boolean parameters are a bad practice because they are very\nambiguous.  Using named boolean parameters is much more readable because it\ninherently describes what the boolean value represents.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Task(true);\nTask(false);\nListBox(false, true, true);\nButton(false);\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Task.oneShot();\nTask.repeating();\nListBox(scroll: true, showScrollbars: true);\nButton(ButtonState.enabled);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_positional_boolean_parameters.html"
    },
    {
        "key": "avoid_print",
        "name": "Avoid `print` calls in production code.",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><strong>DO</strong> avoid <code>print</code> calls in production code.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void f(int x) {\n  print('debug: $x');\n  ...\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_print.html"
    },
    {
        "key": "avoid_private_typedef_functions",
        "name": "Avoid private typedef functions.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> private typedef functions used only once. Prefer inline function\nsyntax.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">typedef void _F();\nm(_F f);\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">m(void Function() f);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_private_typedef_functions.html"
    },
    {
        "key": "avoid_redundant_argument_values",
        "name": "Avoid redundant argument values.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Avoid redundant argument values.</p>\n<p><strong>DON'T</strong> declare arguments with values that match the defaults for the\ncorresponding parameter.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void f({bool valWithDefault = true, bool val}) {\n  ...\n}\n\nvoid main() {\n  f(valWithDefault: true);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void f({bool valWithDefault = true, bool val}) {\n  ...\n}\n\nvoid main() {\n  f(valWithDefault: false);\n  f();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_redundant_argument_values.html"
    },
    {
        "key": "avoid_relative_lib_imports",
        "name": "Avoid relative imports for files in `lib/`.",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>DO</em> avoid relative imports for files in <code>lib/</code>.</p>\n<p>When mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways.  An easy way to avoid\nthat is to ensure you have no relative imports that include <code>lib/</code> in their\npaths.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">import 'package:foo/bar.dart';\n\nimport 'baz.dart';\n\n...\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'package:foo/bar.dart';\n\nimport '../lib/baz.dart';\n\n...\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_relative_lib_imports.html"
    },
    {
        "key": "avoid_renaming_method_parameters",
        "name": "Don't rename parameters of overridden methods.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> rename parameters of overridden methods.</p>\n<p>Methods that override another method, but do not have their own documentation\ncomment, will inherit the overridden method's comment when dartdoc produces\ndocumentation. If the inherited method contains the name of the parameter (in\nsquare brackets), then dartdoc cannot link it correctly.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">abstract class A {\n  m(a);\n}\n\nabstract class B extends A {\n  m(b);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">abstract class A {\n  m(a);\n}\n\nabstract class B extends A {\n  m(a);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_renaming_method_parameters.html"
    },
    {
        "key": "avoid_return_types_on_setters",
        "name": "Avoid return types on setters.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> return types on setters.</p>\n<p>As setters do not return a value, declaring the return type of one is redundant.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">set speed(int ms);\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void set speed(int ms);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_return_types_on_setters.html"
    },
    {
        "key": "avoid_returning_null",
        "name": "Avoid returning null from members whose return type is bool, double, int, or num.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> returning null from members whose return type is bool, double, int,\nor num.</p>\n<p>Functions that return primitive types such as bool, double, int, and num are\ngenerally expected to return non-nullable values.  Thus, returning null where a\nprimitive type was expected can lead to runtime exceptions.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">bool getBool() =&gt; null;\nnum getNum() =&gt; null;\nint getInt() =&gt; null;\ndouble getDouble() =&gt; null;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">bool getBool() =&gt; false;\nnum getNum() =&gt; -1;\nint getInt() =&gt; -1;\ndouble getDouble() =&gt; -1.0;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_returning_null.html"
    },
    {
        "key": "avoid_returning_null_for_future",
        "name": "Avoid returning null for Future.",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><strong>AVOID</strong> returning null for Future.</p>\n<p>It is almost always wrong to return <code>null</code> for a <code>Future</code>.  Most of the time the\ndeveloper simply forgot to put an <code>async</code> keyword on the function.</p>\n\n@see https://dart-lang.github.io/linter/lints/avoid_returning_null_for_future.html"
    },
    {
        "key": "avoid_returning_null_for_void",
        "name": "Avoid returning null for void.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> returning null for void.</p>\n<p>In a large variety of languages <code>void</code> as return type is used to indicate that\na function doesn't return anything. Dart allows returning <code>null</code> in functions\nwith <code>void</code> return type but it also allow using <code>return;</code> without specifying any\nvalue. To have a consistent way you should not return <code>null</code> and only use an\nempty return.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void f1() {\n  return null;\n}\nFuture&lt;void&gt; f2() async {\n  return null;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void f1() {\n  return;\n}\nFuture&lt;void&gt; f2() async {\n  return;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_returning_null_for_void.html"
    },
    {
        "key": "avoid_returning_this",
        "name": "Avoid returning this from methods just to enable a fluent interface.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> returning this from methods just to enable a fluent interface.</p>\n<p>Returning <code>this</code> from a method is redundant; Dart has a cascade operator which\nallows method chaining universally.</p>\n<p>Returning <code>this</code> is allowed for:</p>\n<ul>\n<li>operators</li>\n<li>methods with a return type different of the current class</li>\n<li>methods defined in parent classes / mixins or interfaces</li>\n<li>methods defined in extensions</li>\n</ul>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var buffer = StringBuffer()\n  .write('one')\n  .write('two')\n  .write('three');\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var buffer = StringBuffer()\n  ..write('one')\n  ..write('two')\n  ..write('three');\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_returning_this.html"
    },
    {
        "key": "avoid_setters_without_getters",
        "name": "Avoid setters without getters.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> define a setter without a corresponding getter.</p>\n<p>Defining a setter without defining a corresponding getter can lead to logical\ninconsistencies.  Doing this could allow you to set a property to some value,\nbut then upon observing the property's value, it could easily be different.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Bad {\n  int l, r;\n\n  set length(int newLength) {\n    r = l + newLength;\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Good {\n  int l, r;\n\n  int get length =&gt; r - l;\n\n  set length(int newLength) {\n    r = l + newLength;\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_setters_without_getters.html"
    },
    {
        "key": "avoid_shadowing_type_parameters",
        "name": "Avoid shadowing type parameters.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> shadowing type parameters.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A&lt;T&gt; {\n  void fn&lt;T&gt;() {}\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A&lt;T&gt; {\n  void fn&lt;U&gt;() {}\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_shadowing_type_parameters.html"
    },
    {
        "key": "avoid_single_cascade_in_expression_statements",
        "name": "Avoid single cascade in expression statements.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> single cascade in expression statements.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">o..m();\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">o.m();\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_single_cascade_in_expression_statements.html"
    },
    {
        "key": "avoid_slow_async_io",
        "name": "Avoid slow async `dart:io` methods.",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><strong>AVOID</strong> using the following asynchronous file I/O methods because they are\nmuch slower than their synchronous counterparts.</p>\n<ul>\n<li><code>Directory.exists</code></li>\n<li><code>Directory.stat</code></li>\n<li><code>File.lastModified</code></li>\n<li><code>File.exists</code></li>\n<li><code>File.stat</code></li>\n<li><code>FileSystemEntity.isDirectory</code></li>\n<li><code>FileSystemEntity.isFile</code></li>\n<li><code>FileSystemEntity.isLink</code></li>\n<li><code>FileSystemEntity.type</code></li>\n</ul>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'dart:io';\n\nFuture&lt;Null&gt; someFunction() async {\n  var file = File('/path/to/my/file');\n  var now = DateTime.now();\n  if ((await file.lastModified()).isBefore(now)) print('before'); // LINT\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">import 'dart:io';\n\nFuture&lt;Null&gt; someFunction() async {\n  var file = File('/path/to/my/file');\n  var now = DateTime.now();\n  if (file.lastModifiedSync().isBefore(now)) print('before'); // OK\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_slow_async_io.html"
    },
    {
        "key": "avoid_type_to_string",
        "name": "Avoid <Type>.toString() in production code since results may be minified.",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><strong>DO</strong> avoid calls to <Type>.toString() in production code, since it does not\ncontractually return the user-defined name of the Type (or underlying class).\nDevelopment-mode compilers where code size is not a concern use the full name,\nbut release-mode compilers often choose to minify these symbols.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void bar(Object other) {\n  if (other.runtimeType.toString() == 'Bar') {\n    doThing();\n  }\n}\n\nObject baz(Thing myThing) {\n  return getThingFromDatabase(key: myThing.runtimeType.toString());\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void bar(Object other) {\n  if (other is Bar) {\n    doThing();\n  }\n}\n\nclass Thing {\n  String get thingTypeKey =&gt; ...\n}\n\nObject baz(Thing myThing) {\n  return getThingFromDatabase(key: myThing.thingTypeKey);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_type_to_string.html"
    },
    {
        "key": "avoid_types_as_parameter_names",
        "name": "Avoid types as parameter names.",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><strong>AVOID</strong> using a parameter name that is the same as an existing type.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">m(f(int));\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">m(f(int v));\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_types_as_parameter_names.html"
    },
    {
        "key": "avoid_types_on_closure_parameters",
        "name": "Avoid annotating types for function expression parameters.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> annotating types for function expression parameters.</p>\n<p>Annotating types for function expression parameters is usually unnecessary\nbecause the parameter types can almost always be inferred from the context,\nthus making the practice redundant.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var names = people.map((Person person) =&gt; person.name);\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var names = people.map((person) =&gt; person.name);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_types_on_closure_parameters.html"
    },
    {
        "key": "avoid_unnecessary_containers",
        "name": "Avoid unnecessary containers.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Avoid wrapping widgets in unnecessary containers.</p>\n<p>Wrapping a widget in <code>Container</code> with no other parameters set has no effect \nand makes code needlessly more complex.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Widget buildRow() {\n  return Container(\n      child: Row(\n        children: &lt;Widget&gt;[\n          const MyLogo(),\n          const Expanded(\n            child: Text('...'),\n          ),\n        ],\n      )\n  );\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Widget buildRow() {\n  return Row(\n    children: &lt;Widget&gt;[\n      const MyLogo(),\n      const Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_unnecessary_containers.html"
    },
    {
        "key": "avoid_unused_constructor_parameters",
        "name": "Avoid defining unused parameters in constructors.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> defining unused parameters in constructors.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class BadOne {\n  BadOne(int unusedParameter, [String unusedPositional]);\n}\n\nclass BadTwo {\n  int c;\n\n  BadTwo(int a, int b, int x) {\n    c = a + b;\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_unused_constructor_parameters.html"
    },
    {
        "key": "avoid_void_async",
        "name": "Avoid async functions that return void.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> mark async functions to return Future<void>.</p>\n<p>When declaring an async method or function which does not return a value,\ndeclare that it returns Future<void> and not just void.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void f() async {}\nvoid f2() async =&gt; null;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Future&lt;void&gt; f() async {}\nFuture&lt;void&gt; f2() async =&gt; null;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/avoid_void_async.html"
    },
    {
        "key": "avoid_web_libraries_in_flutter",
        "name": "Avoid using web-only libraries outside Flutter web plugin packages.",
        "type": "BUG",
        "status": "BETA",
        "severity": "MAJOR",
        "description": "<p>Avoid using web libraries, <code>dart:html</code>, <code>dart:js</code> and \n<code>dart:js_util</code> in Flutter packages that are not web plugins. These libraries are \nnot supported outside a web context; functionality that depends on them will\nfail at runtime in Flutter mobile, and their use is generally discouraged in\nFlutter web.</p>\n<p>Web library access <em>is</em> allowed in:</p>\n<ul>\n<li>plugin packages that declare <code>web</code> as a supported context</li>\n</ul>\n<p>otherwise, imports of <code>dart:html</code>, <code>dart:js</code> and  <code>dart:js_util</code> are disallowed.</p>\n\n@see https://dart-lang.github.io/linter/lints/avoid_web_libraries_in_flutter.html"
    },
    {
        "key": "await_in_late_local_variable_initializer",
        "name": "Await in late local variable initializer",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The 'await' expression can't be used in a 'late' local variable's initializer.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a local variable that has the\n<code>late</code> modifier uses an <code>await</code> expression in the initializer.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because an <code>await</code> expression\nis used in the initializer for <code>v</code>, a local variable that is marked <code>late</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nFuture<int> f() async {\nlate var v = [!await!] 42;\nreturn v;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the initializer can be rewritten to not use <code>await</code>, then rewrite it:</p>\n<p>{% prettify dart tag=pre+code %}\nFuture<int> f() async {\nlate var v = 42;\nreturn v;\n}\n{% endprettify %}</p>\n<p>If the initializer can't be rewritten, then remove the <code>late</code> modifier:</p>\n<p>{% prettify dart tag=pre+code %}\nFuture<int> f() async {\nvar v = await 42;\nreturn v;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#await_in_late_local_variable_initializer"
    },
    {
        "key": "await_in_wrong_context",
        "name": "Await in wrong context",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The await expression can only be used in an async function.\n\nTry marking the function body with either 'async' or 'async*'."
    },
    {
        "key": "await_only_futures",
        "name": "Await only futures.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> using await on anything other than a future.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">main() async {\n  print(await 23);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">main() async {\n  print(await Future.value(23));\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/await_only_futures.html"
    },
    {
        "key": "body_might_complete_normally",
        "name": "Body might complete normally",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The body might complete normally, causing 'null' to be returned, but the return\ntype is a potentially non-nullable type.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a method or function has a\nreturn type that's <a href=\"https://dart.dev/tools/diagnostic-messages#potentially-non-nullable\">potentially non-nullable</a> but would implicitly return\n<code>null</code> if control reached the end of the function.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the method <code>m</code> has an\nimplicit return of <code>null</code> inserted at the end of the method, but the method\nis declared to not return <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint [!m!](int t) {\nprint(t);\n}\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the method <code>m</code> has an\nimplicit return of <code>null</code> inserted at the end of the method, but because\nthe class <code>C</code> can be instantiated with a non-nullable type argument, the\nmethod is effectively declared to not return <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nT [!m!](T t) {\nprint(t);\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If there's a reasonable value that can be returned, then add a <code>return</code>\nstatement at the end of the method:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nT m(T t) {\nprint(t);\nreturn t;\n}\n}\n{% endprettify %}</p>\n<p>If the method won't reach the implicit return, then add a <code>throw</code> at the\nend of the method:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nT m(T t) {\nprint(t);\nthrow '';\n}\n}\n{% endprettify %}</p>\n<p>If the method intentionally returns <code>null</code> at the end, then change the\nreturn type so that it's valid to return <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nT? m(T t) {\nprint(t);\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#body_might_complete_normally"
    },
    {
        "key": "break_label_on_switch_member",
        "name": "Break label on switch member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A break label resolves to the 'case' or 'default' statement.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a break in a case clause inside\na switch statement has a label that is associated with another case clause.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the label <code>l</code> is\nassociated with the case clause for <code>0</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int i) {\nswitch (i) {\nl: case 0:\nbreak;\ncase 1:\nbreak [!l!];\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the intent is to transfer control to the statement after the switch,\nthen remove the label from the break statement:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int i) {\nswitch (i) {\ncase 0:\nbreak;\ncase 1:\nbreak;\n}\n}\n{% endprettify %}</p>\n<p>If the intent is to transfer control to a different case block, then use\n<code>continue</code> rather than <code>break</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int i) {\nswitch (i) {\nl: case 0:\nbreak;\ncase 1:\ncontinue l;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#break_label_on_switch_member"
    },
    {
        "key": "built_in_identifier_as_extension_name",
        "name": "Built in identifier as extension name",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The built-in identifier '{0}' can't be used as an extension name.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the name of an extension is a\nbuilt-in identifier. Built-in identifiers canâ€™t be used as extension names.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>mixin</code> is a built-in\nidentifier:</p>\n<p>{% prettify dart tag=pre+code %}\nextension [!mixin!] on int {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Choose a different name for the extension.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#built_in_identifier_as_extension_name"
    },
    {
        "key": "built_in_identifier_as_prefix_name",
        "name": "Built in identifier as prefix name",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The built-in identifier '{0}' can't be used as a prefix name.\n\nTry choosing a different name for the prefix."
    },
    {
        "key": "built_in_identifier_as_type",
        "name": "Built in identifier as type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The built-in identifier '{0}' can't be used as a type.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a built-in identifier is used\nwhere a type name is expected.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>import</code> can't be used\nas a type because it's a built-in identifier:</p>\n<p>{% prettify dart tag=pre+code %}\n[!import!]<int> x;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the built-in identifier with the name of a valid type:</p>\n<p>{% prettify dart tag=pre+code %}\nList<int> x;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#built_in_identifier_as_type"
    },
    {
        "key": "built_in_identifier_as_type_name",
        "name": "Built in identifier as type name",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The built-in identifier '{0}' can't be used as a type name.\n\nTry choosing a different name for the type."
    },
    {
        "key": "built_in_identifier_as_type_parameter_name",
        "name": "Built in identifier as type parameter name",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The built-in identifier '{0}' can't be used as a type parameter name.\n\nTry choosing a different name for the type parameter."
    },
    {
        "key": "built_in_identifier_as_typedef_name",
        "name": "Built in identifier as typedef name",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The built-in identifier '{0}' can't be used as a typedef name.\n\nTry choosing a different name for the typedef."
    },
    {
        "key": "camel_case_extensions",
        "name": "Name extensions using UpperCamelCase.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</a>:</p>\n<p><strong>DO</strong> name extensions using <code>UpperCamelCase</code>.</p>\n<p>Extensions should capitalize the first letter of each word (including\nthe first word), and use no separators.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">extension MyFancyList&lt;T&gt; on List&lt;T&gt; { \n  // ... \n}\n\nextension SmartIterable&lt;T&gt; on Iterable&lt;T&gt; {\n  // ...\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/camel_case_extensions.html"
    },
    {
        "key": "camel_case_types",
        "name": "Name types using UpperCamelCase.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</a>:</p>\n<p><strong>DO</strong> name types using UpperCamelCase.</p>\n<p>Classes and typedefs should capitalize the first letter of each word (including\nthe first word), and use no separators.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class SliderMenu {\n  // ...\n}\n\nclass HttpRequest {\n  // ...\n}\n\ntypedef num Adder(num x, num y);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/camel_case_types.html"
    },
    {
        "key": "can_be_null_after_null_aware",
        "name": "Can be null after null aware",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The receiver uses '?.', so its value can be null.\n\nReplace the '.' with a '?.' in the invocation."
    },
    {
        "key": "cancel_subscriptions",
        "name": "Cancel instances of dart.async.StreamSubscription.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DO</strong> invoke <code>cancel</code> on instances of <code>dart.async.StreamSubscription</code>.</p>\n<p>Cancelling instances of StreamSubscription prevents memory leaks and unexpected\nbehavior.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  StreamSubscription _subscriptionA; // LINT\n  void init(Stream stream) {\n    _subscriptionA = stream.listen((_) {});\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction() {\n  StreamSubscription _subscriptionF; // LINT\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class B {\n  StreamSubscription _subscriptionB; // OK\n  void init(Stream stream) {\n    _subscriptionB = stream.listen((_) {});\n  }\n\n  void dispose(filename) {\n    _subscriptionB.cancel();\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunctionOK() {\n  StreamSubscription _subscriptionB; // OK\n  _subscriptionB.cancel();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/cancel_subscriptions.html"
    },
    {
        "key": "cascade_invocations",
        "name": "Cascade consecutive method invocations on the same reference.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> Use the cascading style when succesively invoking methods on the same\nreference.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">SomeClass someReference = SomeClass();\nsomeReference.firstMethod();\nsomeReference.secondMethod();\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">SomeClass someReference = SomeClass();\n...\nsomeReference.firstMethod();\nsomeReference.aProperty = value;\nsomeReference.secondMethod();\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">SomeClass someReference = SomeClass()\n    ..firstMethod()\n    ..aProperty = value\n    ..secondMethod();\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">SomeClass someReference = SomeClass();\n...\nsomeReference\n    ..firstMethod()\n    ..aProperty = value\n    ..secondMethod();\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/cascade_invocations.html"
    },
    {
        "key": "case_block_not_terminated",
        "name": "Case block not terminated",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The last statement of the 'case' should be 'break', 'continue', 'rethrow',\n'return', or 'throw'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the last statement in a <code>case</code>\nblock isn't one of the required terminators: <code>break</code>, <code>continue</code>,\n<code>rethrow</code>, <code>return</code>, or <code>throw</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the <code>case</code> block ends\nwith an assignment:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int x) {\nswitch (x) {\n[!case!] 0:\nx += 2;\ndefault:\nx += 1;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add one of the required terminators:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int x) {\nswitch (x) {\ncase 0:\nx += 2;\nbreak;\ndefault:\nx += 1;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#case_block_not_terminated"
    },
    {
        "key": "case_expression_type_implements_equals",
        "name": "Case expression type implements equals",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The switch case expression type '{0}' can't override the '==' operator.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the type of the expression\nfollowing the keyword <code>case</code> has an implementation of the <code>==</code> operator\nother than the one in <code>Object</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the expression\nfollowing the keyword <code>case</code> (<code>C(0)</code>) has the type <code>C</code>, and the class <code>C</code>\noverrides the <code>==</code> operator:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int value;</p>\n<p>const C(this.value);</p>\n<p>bool operator ==(Object other) {\nreturn false;\n}\n}</p>\n<p>void f(C c) {\nswitch (c) {\ncase [!C(0)!]:\nbreak;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If there isn't a strong reason not to do so, then rewrite the code to use\nan if-else structure:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int value;</p>\n<p>const C(this.value);</p>\n<p>bool operator ==(Object other) {\nreturn false;\n}\n}</p>\n<p>void f(C c) {\nif (c == C(0)) {\n// ...\n}\n}\n{% endprettify %}</p>\n<p>If you can't rewrite the switch statement and the implementation of <code>==</code>\nisn't necessary, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int value;</p>\n<p>const C(this.value);\n}</p>\n<p>void f(C c) {\nswitch (c) {\ncase C(0):\nbreak;\n}\n}\n{% endprettify %}</p>\n<p>If you can't rewrite the switch statement and you can't remove the\ndefinition of <code>==</code>, then find some other value that can be used to control\nthe switch:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int value;</p>\n<p>const C(this.value);</p>\n<p>bool operator ==(Object other) {\nreturn false;\n}\n}</p>\n<p>void f(C c) {\nswitch (c.value) {\ncase 0:\nbreak;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#case_expression_type_implements_equals"
    },
    {
        "key": "case_expression_type_is_not_switch_expression_subtype",
        "name": "Case expression type is not switch expression subtype",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The switch case expression type '{0}' must be a subtype of the switch\nexpression type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the expression following <code>case</code>\nin a <code>switch</code> statement has a static type that isn't a subtype of the\nstatic type of the expression following <code>switch</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>1</code> is an <code>int</code>, which\nisn't a subtype of <code>String</code> (the type of <code>s</code>):</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String s) {\nswitch (s) {\ncase [!1!]:\nbreak;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the value of the <code>case</code> expression is wrong, then change the <code>case</code>\nexpression so that it has the required type:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String s) {\nswitch (s) {\ncase '1':\nbreak;\n}\n}\n{% endprettify %}</p>\n<p>If the value of the <code>case</code> expression is correct, then change the <code>switch</code>\nexpression to have the required type:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int s) {\nswitch (s) {\ncase 1:\nbreak;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#case_expression_type_is_not_switch_expression_subtype"
    },
    {
        "key": "cast_nullable_to_non_nullable",
        "name": "Don't cast a nullable value to a non nullable type.",
        "type": "CODE_SMELL",
        "status": "BETA",
        "severity": "MINOR",
        "description": "<p>Don't cast a nullable value to a non nullable type. This hides a null check\nand most of the time it is not what is expected.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {}\nclass B extends A {}\n\nA? a;\nvar v = a as B;\nvar v = a as A;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A {}\nclass B extends A {}\n\nA? a;\nvar v = a! as B;\nvar v = a!;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/cast_nullable_to_non_nullable.html"
    },
    {
        "key": "cast_to_non_type",
        "name": "Cast to non type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' isn't a type, so it can't be used in an 'as' expression.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the name following the <code>as</code> in a\ncast expression is defined to be something other than a type.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> is a variable, not\na type:</p>\n<p>{% prettify dart tag=pre+code %}\nnum x = 0;\nint y = x as [!x!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the name with the name of a type:</p>\n<p>{% prettify dart tag=pre+code %}\nnum x = 0;\nint y = x as int;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#cast_to_non_type"
    },
    {
        "key": "close_sinks",
        "name": "Close instances of `dart.core.Sink`.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DO</strong> invoke <code>close</code> on instances of <code>dart.core.Sink</code>.</p>\n<p>Closing instances of Sink prevents memory leaks and unexpected behavior.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  IOSink _sinkA;\n  void init(filename) {\n    _sinkA = File(filename).openWrite(); // LINT\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction() {\n  IOSink _sinkF; // LINT\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class B {\n  IOSink _sinkB;\n  void init(filename) {\n    _sinkB = File(filename).openWrite(); // OK\n  }\n\n  void dispose(filename) {\n    _sinkB.close();\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunctionOK() {\n  IOSink _sinkFOK; // OK\n  _sinkFOK.close();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/close_sinks.html"
    },
    {
        "key": "collection_element_from_deferred_library",
        "name": "Collection element from deferred library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Constant values from a deferred library can't be used as keys in a 'const' map\nliteral.</em></p>\n<p><em>Constant values from a deferred library can't be used as values in a 'const'\nlist literal.</em></p>\n<p><em>Constant values from a deferred library can't be used as values in a 'const'\nmap literal.</em></p>\n<p><em>Constant values from a deferred library can't be used as values in a 'const'\nset literal.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a collection literal that is\neither explicitly (because it's prefixed by the <code>const</code> keyword) or\nimplicitly (because it appears in a <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a>) a constant\ncontains a value that is declared in a library that is imported using a\ndeferred import. Constants are evaluated at compile time, and values from\ndeferred libraries aren't available at compile time.</p>\n<p>For more information, see the language tour's coverage of\n<a href=\"https://dart.dev/guides/language/language-tour#lazily-loading-a-library\">deferred loading</a>.</p>\n<h4>Example</h4>\n<p>Given a file (<code>a.dart</code>) that defines the constant <code>zero</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nconst zero = 0;\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the constant list\nliteral contains <code>a.zero</code>, which is imported using a <code>deferred</code> import:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' deferred as a;</p>\n<p>var l = const [[!a.zero!]];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the collection literal isn't required to be constant, then remove the\n<code>const</code> keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' deferred as a;</p>\n<p>var l = [a.zero];\n{% endprettify %}</p>\n<p>If the collection is required to be constant and the imported constant must\nbe referenced, then remove the keyword <code>deferred</code> from the import:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' as a;</p>\n<p>var l = const [a.zero];\n{% endprettify %}</p>\n<p>If you don't need to reference the constant, then replace it with a\nsuitable value:</p>\n<p>{% prettify dart tag=pre+code %}\nvar l = const [0];\n{% endprettify %}</p>"
    },
    {
        "key": "comment_references",
        "name": "Only reference in scope identifiers in doc comments.",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><strong>DO</strong> reference only in scope identifiers in doc comments.</p>\n<p>If you surround things like variable, method, or type names in square brackets,\nthen <a href=\"https://dart.dev/guides/language/effective-dart/documentation\">dartdoc</a> will look\nup the name and link to its docs.  For this all to work, ensure that all\nidentifiers in docs wrapped in brackets are in scope.</p>\n<p>For example,</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">/// Return the larger of [a] or [b].\nint max_int(int a, int b) { ... }\n</code></pre>\n<p>On the other hand, assuming <code>outOfScopeId</code> is out of scope:</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">/// Return true if [value] is larger than [outOfScopeId].\nbool isOutOfRange(int value) { ... }\n</code></pre>\n<p>Note that the square bracket comment format is designed to allow \ncomments to refer to declarations using a fairly natural format \nbut does not allow <em>arbitrary expressions</em>.  In particular, code \nreferences within square brackets can consist of either</p>\n<ul>\n<li>a single identifier where the identifier is any identifier in scope for the comment (see the spec for what is in scope in doc comments),</li>\n<li>two identifiers separated by a period where the first identifier is the name of a class that is in scope and the second is the name of a member declared in the class,</li>\n<li>a single identifier followed by a pair of parentheses where the identifier is the name of a class that is in scope (used to refer to the unnamed constructor for the class), or</li>\n<li>two identifiers separated by a period and followed by a pair of parentheses where the first identifier is the name of a class that is in scope and the second is the name of a named constructor (not strictly necessary, but allowed for consistency).</li>\n</ul>\n\n@see https://dart-lang.github.io/linter/lints/comment_references.html"
    },
    {
        "key": "concrete_class_with_abstract_member",
        "name": "Concrete class with abstract member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{0}' must have a method body because '{1}' isn't abstract.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a member of a concrete class is\nfound that doesn't have a concrete implementation. Concrete classes aren't\nallowed to contain abstract members.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>m</code> is an abstract\nmethod but <code>C</code> isn't an abstract class:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\n[!void m();!]\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If it's valid to create instances of the class, provide an implementation\nfor the member:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nvoid m() {}\n}\n{% endprettify %}</p>\n<p>If it isn't valid to create instances of the class, mark the class as being\nabstract:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class C {\nvoid m();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#concrete_class_with_abstract_member"
    },
    {
        "key": "conflicting_constructor_and_static_field",
        "name": "Conflicting constructor and static field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't be used to name both a constructor and a static field in this class.\n\nTry renaming either the constructor or the field."
    },
    {
        "key": "conflicting_constructor_and_static_method",
        "name": "Conflicting constructor and static method",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't be used to name both a constructor and a static method in this class.\n\nTry renaming either the constructor or the method."
    },
    {
        "key": "conflicting_field_and_method",
        "name": "Conflicting field and method",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Class '{0}' can't define field '{1}' and have method '{2}.{1}' with the same name.\n\nTry converting the getter to a method, or renaming the field to a name that doesn't conflict."
    },
    {
        "key": "conflicting_generic_interfaces",
        "name": "Conflicting generic interfaces",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The class '{0}' can't implement both '{1}' and '{2}' because the type arguments\nare different.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class attempts to implement a\ngeneric interface multiple times, and the values of the type arguments\naren't the same.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>C</code> is defined to\nimplement both <code>I&lt;int&gt;</code> (because it extends <code>A</code>) and <code>I&lt;String&gt;</code> (because\nit implements<code>B</code>), but <code>int</code> and <code>String</code> aren't the same type:</p>\n<p>{% prettify dart tag=pre+code %}\nclass I<T> {}\nclass A implements I<int> {}\nclass B implements I<String> {}\n[!class C extends A implements B {}!]\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Rework the type hierarchy to avoid this situation. For example, you might\nmake one or both of the inherited types generic so that <code>C</code> can specify the\nsame type for both type arguments:</p>\n<p>{% prettify dart tag=pre+code %}\nclass I<T> {}\nclass A<S> implements I<S> {}\nclass B implements I<String> {}\nclass C extends A<String> implements B {}\n{% endprettify %}</p>"
    },
    {
        "key": "conflicting_method_and_field",
        "name": "Conflicting method and field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Class '{0}' can't define method '{1}' and have field '{2}.{1}' with the same name.\n\nTry converting the method to a getter, or renaming the method to a name that doesn't conflict."
    },
    {
        "key": "conflicting_static_and_instance",
        "name": "Conflicting static and instance",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Class '{0}' can't define static member '{1}' and have instance member '{2}.{1}' with the same name.\n\nTry renaming the member to a name that doesn't conflict."
    },
    {
        "key": "conflicting_type_variable_and_container",
        "name": "Conflicting type variable and container",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't be used to name both a type variable and the class in which the type variable is defined.\n\nTry renaming either the type variable or the class."
    },
    {
        "key": "conflicting_type_variable_and_member",
        "name": "Conflicting type variable and member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't be used to name both a type variable and a member in this class.\n\nTry renaming either the type variable or the member."
    },
    {
        "key": "const_constructor_field_type_mismatch",
        "name": "Const constructor field type mismatch",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "In a const constructor, a value of type '{0}' can't be assigned to the field '{1}', which has type '{2}'.\n\nTry using a subtype, or removing the keyword 'const'."
    },
    {
        "key": "const_constructor_param_type_mismatch",
        "name": "Const constructor param type mismatch",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A value of type '{0}' can't be assigned to a parameter of type '{1}' in a const\nconstructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the runtime type of a constant\nvalue can't be assigned to the static type of a constant constructor's\nparameter.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the runtime type of <code>i</code>\nis <code>int</code>, which can't be assigned to the static type of <code>s</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String s;</p>\n<p>const C(this.s);\n}</p>\n<p>const dynamic i = 0;</p>\n<p>void f() {\nconst C([!i!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Pass a value of the correct type to the constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String s;</p>\n<p>const C(this.s);\n}</p>\n<p>const dynamic i = 0;</p>\n<p>void f() {\nconst C('$i');\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_constructor_param_type_mismatch"
    },
    {
        "key": "const_constructor_throws_exception",
        "name": "Const constructor throws exception",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Const constructors can't throw exceptions.\n\nTry removing the throw statement, or removing the keyword 'const'."
    },
    {
        "key": "const_constructor_with_field_initialized_by_non_const",
        "name": "Const constructor with field initialized by non const",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Can't define the 'const' constructor because the field '{0}' is initialized\nwith a non-constant value.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constructor has the keyword\n<code>const</code>, but a field in the class is initialized to a non-constant value.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the field <code>s</code> is\ninitialized to a non-constant value:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String s = 3.toString();\n[!const!] C();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the field can be initialized to a constant value, then change the\ninitializer to a constant expression:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String s = '3';\nconst C();\n}\n{% endprettify %}</p>\n<p>If the field can't be initialized to a constant value, then remove the\nkeyword <code>const</code> from the constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String s = 3.toString();\nC();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_constructor_with_field_initialized_by_non_const"
    },
    {
        "key": "const_constructor_with_mixin_with_field",
        "name": "Const constructor with mixin with field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "This constructor can't be declared 'const' because a mixin adds the instance field: {0}.\n\nTry removing the 'const' keyword or removing the 'with' clause from the class declaration, or removing the field from the mixin class."
    },
    {
        "key": "const_constructor_with_non_const_super",
        "name": "Const constructor with non const super",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A constant constructor can't call a non-constant super constructor of '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constructor that is marked as\n<code>const</code> invokes a constructor from its superclass that isn't marked as\n<code>const</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the <code>const</code> constructor\nin <code>B</code> invokes the constructor <code>nonConst</code> from the class <code>A</code>, and the\nsuperclass constructor isn't a <code>const</code> constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nconst A();\nA.nonConst();\n}</p>\n<p>class B extends A {\nconst B() : [!super.nonConst()!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If it isn't essential to invoke the superclass constructor that is\ncurrently being invoked, then invoke a constant constructor from the\nsuperclass:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nconst A();\nA.nonConst();\n}</p>\n<p>class B extends A {\nconst B() : super();\n}\n{% endprettify %}</p>\n<p>If it's essential that the current constructor be invoked and if you can\nmodify it, then add <code>const</code> to the constructor in the superclass:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nconst A();\nconst A.nonConst();\n}</p>\n<p>class B extends A {\nconst B() : super.nonConst();\n}\n{% endprettify %}</p>\n<p>If it's essential that the current constructor be invoked and you can't\nmodify it, then remove <code>const</code> from the constructor in the subclass:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nconst A();\nA.nonConst();\n}</p>\n<p>class B extends A {\nB() : super.nonConst();\n}\n{% endprettify %}</p>"
    },
    {
        "key": "const_constructor_with_non_final_field",
        "name": "Const constructor with non final field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Can't define a const constructor for a class with non-final fields.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constructor is marked as a\nconst constructor, but the constructor is defined in a class that has at\nleast one non-final instance field (either directly or by inheritance).</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the field <code>x</code> isn't\nfinal:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>const <a href=\"this.x\">!C!</a>;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If it's possible to mark all of the fields as final, then do so:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int x;</p>\n<p>const C(this.x);\n}\n{% endprettify %}</p>\n<p>If it isn't possible to mark all of the fields as final, then remove the\nkeyword <code>const</code> from the constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>C(this.x);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_constructor_with_non_final_field"
    },
    {
        "key": "const_deferred_class",
        "name": "Const deferred class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Deferred classes can't be created with 'const'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class from a library that is\nimported using a deferred import is used to create a <code>const</code> object.\nConstants are evaluated at compile time, and classes from deferred\nlibraries aren't available at compile time.</p>\n<p>For more information, see the language tour's coverage of\n<a href=\"https://dart.dev/guides/language/language-tour#lazily-loading-a-library\">deferred loading</a>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because it attempts to create a\n<code>const</code> instance of a class from a deferred library:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:convert' deferred as convert;</p>\n<p>const json2 = [!convert.JsonCodec()!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the object isn't required to be a constant, then change the code so that\na non-constant instance is created:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:convert' deferred as convert;</p>\n<p>final json2 = convert.JsonCodec();\n{% endprettify %}</p>\n<p>If the object must be a constant, then remove <code>deferred</code> from the import\ndirective:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:convert' as convert;</p>\n<p>const json2 = convert.JsonCodec();\n{% endprettify %}</p>"
    },
    {
        "key": "const_eval_throws_exception",
        "name": "Const eval throws exception",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Evaluation of this constant expression throws an exception.\n\nnull"
    },
    {
        "key": "const_eval_throws_idbze",
        "name": "Const eval throws idbze",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Evaluation of this constant expression throws an IntegerDivisionByZeroException.\n\nnull"
    },
    {
        "key": "const_eval_type_bool",
        "name": "Const eval type bool",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "In constant expressions, operands of this operator must be of type 'bool'.\n\nnull"
    },
    {
        "key": "const_eval_type_bool_int",
        "name": "Const eval type bool int",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "In constant expressions, operands of this operator must be of type 'bool' or 'int'.\n\nnull"
    },
    {
        "key": "const_eval_type_bool_num_string",
        "name": "Const eval type bool num string",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "In constant expressions, operands of this operator must be of type 'bool', 'num', 'String' or 'null'.\n\nnull"
    },
    {
        "key": "const_eval_type_int",
        "name": "Const eval type int",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "In constant expressions, operands of this operator must be of type 'int'.\n\nnull"
    },
    {
        "key": "const_eval_type_num",
        "name": "Const eval type num",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "In constant expressions, operands of this operator must be of type 'num'.\n\nnull"
    },
    {
        "key": "const_eval_type_type",
        "name": "Const eval type type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "In constant expressions, operands of this operator must be of type 'Type'.\n\nnull"
    },
    {
        "key": "const_initialized_with_non_constant_value",
        "name": "Const initialized with non constant value",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Const variables must be initialized with a constant value.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a value that isn't statically\nknown to be a constant is assigned to a variable that's declared to be a\n<code>const</code> variable.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> isn't declared to\nbe <code>const</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x = 0;\nconst y = [!x!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the value being assigned can be declared to be <code>const</code>, then change the\ndeclaration:</p>\n<p>{% prettify dart tag=pre+code %}\nconst x = 0;\nconst y = x;\n{% endprettify %}</p>\n<p>If the value can't be declared to be <code>const</code>, then remove the <code>const</code>\nmodifier from the variable, possibly using <code>final</code> in its place:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x = 0;\nfinal y = x;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_initialized_with_non_constant_value"
    },
    {
        "key": "const_initialized_with_non_constant_value_from_deferred_library",
        "name": "Const initialized with non constant value from deferred library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Constant values from a deferred library can't be used to initialize a 'const'\nvariable.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a <code>const</code> variable is\ninitialized using a <code>const</code> variable from a library that is imported using\na deferred import. Constants are evaluated at compile time, and values from\ndeferred libraries aren't available at compile time.</p>\n<p>For more information, see the language tour's coverage of\n<a href=\"https://dart.dev/guides/language/language-tour#lazily-loading-a-library\">deferred loading</a>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the variable <code>pi</code> is\nbeing initialized using the constant <code>math.pi</code> from the library\n<code>dart:math</code>, and <code>dart:math</code> is imported as a deferred library:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' deferred as math;</p>\n<p>const pi = [!math.pi!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to reference the value of the constant from the imported\nlibrary, then remove the keyword <code>deferred</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' as math;</p>\n<p>const pi = math.pi;\n{% endprettify %}</p>\n<p>If you don't need to reference the imported constant, then remove the\nreference:</p>\n<p>{% prettify dart tag=pre+code %}\nconst pi = 3.14;\n{% endprettify %}</p>"
    },
    {
        "key": "const_instance_field",
        "name": "Const instance field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Only static fields can be declared as const.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an instance field is marked as\nbeing const.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> is an instance\nfield:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\n[!const!] int f = 3;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the field needs to be an instance field, then remove the keyword\n<code>const</code>, or replace it with <code>final</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int f = 3;\n}\n{% endprettify %}</p>\n<p>If the field really should be a const field, then make it a static field:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic const int f = 3;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_instance_field"
    },
    {
        "key": "prefer_final_fields",
        "name": "Prefer final fields",
        "description": "Private field could be final.",
        "severity": "MINOR",
        "type": "CODE_SMELL"
    },
    {
        "key": "prefer_final_in_for_each",
        "name": "Prefer final in for each",
        "description": "Prefer final in for-each loop variable if reference is not reassigned.",
        "severity": "MINOR",
        "type": "CODE_SMELL"
    },
    {
        "key": "prefer_final_locals",
        "name": "Prefer final locals",
        "description": "Prefer final for variable declarations if they are not reassigned.",
        "severity": "MINOR",
        "type": "CODE_SMELL"
    },
    {
        "key": "const_spread_expected_list_or_set",
        "name": "Const spread expected list or set",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A list or a set is expected in this spread.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the expression of a spread\noperator in a constant list or set evaluates to something other than a list\nor a set.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the value of <code>list1</code> is\n<code>null</code>, which is neither a list nor a set:</p>\n<p>{% prettify dart tag=pre+code %}\nconst List<int> list1 = null;\nconst List<int> list2 = [...[!list1!]];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the expression to something that evaluates to either a constant list\nor a constant set:</p>\n<p>{% prettify dart tag=pre+code %}\nconst List<int> list1 = [];\nconst List<int> list2 = [...list1];\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_spread_expected_list_or_set"
    },
    {
        "key": "const_spread_expected_map",
        "name": "Const spread expected map",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A map is expected in this spread.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the expression of a spread\noperator in a constant map evaluates to something other than a map.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the value of <code>map1</code> is\n<code>null</code>, which isn't a map:</p>\n<p>{% prettify dart tag=pre+code %}\nconst Map&lt;String, int&gt; map1 = null;\nconst Map&lt;String, int&gt; map2 = {...[!map1!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the expression to something that evaluates to a constant map:</p>\n<p>{% prettify dart tag=pre+code %}\nconst Map&lt;String, int&gt; map1 = {};\nconst Map&lt;String, int&gt; map2 = {...map1};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_spread_expected_map"
    },
    {
        "key": "const_with_non_const",
        "name": "Const with non const",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The constructor being called isn't a const constructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the keyword <code>const</code> is used to\ninvoke a constructor that isn't marked with <code>const</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the constructor in <code>A</code>\nisn't a const constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA();\n}</p>\n<p>A f() =&gt; [!const!] A();\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If it's desirable and possible to make the class a constant class (by\nmaking all of the fields of the class, including inherited fields, final),\nthen add the keyword <code>const</code> to the constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nconst A();\n}</p>\n<p>A f() =&gt; const A();\n{% endprettify %}</p>\n<p>Otherwise, remove the keyword <code>const</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA();\n}</p>\n<p>A f() =&gt; A();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_with_non_const"
    },
    {
        "key": "const_with_non_constant_argument",
        "name": "Const with non constant argument",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Arguments of a constant creation must be constant expressions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a const constructor is invoked\nwith an argument that isn't a constant expression.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>i</code> isn't a constant:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int i;\nconst C(this.i);\n}\nC f(int i) =&gt; const C([!i!]);\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Either make all of the arguments constant expressions, or remove the\n<code>const</code> keyword to use the non-constant form of the constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int i;\nconst C(this.i);\n}\nC f(int i) =&gt; C(i);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_with_non_constant_argument"
    },
    {
        "key": "const_with_type_parameters",
        "name": "Const with type parameters",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A constant creation can't use a type parameter as a type argument.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a type parameter is used as a\ntype argument in a <code>const</code> invocation of a constructor. This isn't allowed\nbecause the value of the type parameter (the actual type that will be used\nat runtime) can't be known at compile time.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the type parameter <code>T</code>\nis being used as a type argument when creating a constant:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nconst C();\n}</p>\n<p>C<T> newC<T>() =&gt; const C&lt;[!T!]&gt;();\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type that will be used for the type parameter can be known at\ncompile time, then remove the use of the type parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nconst C();\n}</p>\n<p>C<int> newC() =&gt; const C<int>();\n{% endprettify %}</p>\n<p>If the type that will be used for the type parameter can't be known until\nruntime, then remove the keyword <code>const</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nconst C();\n}</p>\n<p>C<T> newC<T>() =&gt; C<T>();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#const_with_type_parameters"
    },
    {
        "key": "const_with_undefined_constructor",
        "name": "Const with undefined constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The class '{0}' doesn't have a constant constructor '{1}'.\n\nTry calling a different constructor."
    },
    {
        "key": "const_with_undefined_constructor_default",
        "name": "Const with undefined constructor default",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The class '{0}' doesn't have a default constant constructor.\n\nTry calling a different constructor."
    },
    {
        "key": "constant_identifier_names",
        "name": "Prefer using lowerCamelCase for constant names.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> using lowerCamelCase for constant names.</p>\n<p>In new code, use <code>lowerCamelCase</code> for constant variables, including enum values.</p>\n<p>In existing code that uses <code>ALL_CAPS_WITH_UNDERSCORES</code> for constants, you may\ncontinue to use all caps to stay consistent.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">const pi = 3.14;\nconst defaultTimeout = 1000;\nfinal urlScheme = RegExp('^([a-z]+):');\n\nclass Dice {\n  static final numberGenerator = Random();\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">const PI = 3.14;\nconst kDefaultTimeout = 1000;\nfinal URL_SCHEME = RegExp('^([a-z]+):');\n\nclass Dice {\n  static final NUMBER_GENERATOR = Random();\n}\n\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/constant_identifier_names.html"
    },
    {
        "key": "continue_label_on_switch",
        "name": "Continue label on switch",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "A continue label resolves to switch, must be loop or switch member\n\nnull"
    },
    {
        "key": "control_flow_in_finally",
        "name": "Avoid control flow in finally blocks.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>AVOID</strong> control flow leaving finally blocks.</p>\n<p>Using control flow in finally blocks will inevitably cause unexpected behavior\nthat is hard to debug.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Ok {\n  double compliantMethod() {\n    var i = 5;\n    try {\n      i = 1 / 0;\n    } catch (e) {\n      print(e); // OK\n    }\n    return i;\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class BadReturn {\n  double nonCompliantMethod() {\n    try {\n      return 1 / 0;\n    } catch (e) {\n      print(e);\n    } finally {\n      return 1.0; // LINT\n    }\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class BadContinue {\n  double nonCompliantMethod() {\n    for (var o in [1, 2]) {\n      try {\n        print(o / 0);\n      } catch (e) {\n        print(e);\n      } finally {\n        continue; // LINT\n      }\n    }\n    return 1.0;\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class BadBreak {\n  double nonCompliantMethod() {\n    for (var o in [1, 2]) {\n      try {\n        print(o / 0);\n      } catch (e) {\n        print(e);\n      } finally {\n        break; // LINT\n      }\n    }\n    return 1.0;\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/control_flow_in_finally.html"
    },
    {
        "key": "could_not_infer",
        "name": "Could not infer",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Couldn't infer type parameter '{0}'.{1}\n\nnull"
    },
    {
        "key": "creation_with_non_type",
        "name": "Creation with non type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' isn't a class.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an instance creation using\neither <code>new</code> or <code>const</code> specifies a name that isn't defined as a class.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>f</code> is a function\nrather than a class:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() =&gt; 0;</p>\n<p>void g() {\nnew <a href=\"\">!f!</a>;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If a class should be created, then replace the invalid name with the name\nof a valid class:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() =&gt; 0;</p>\n<p>void g() {\nnew Object();\n}\n{% endprettify %}</p>\n<p>If the name is the name of a function and you want that function to be\ninvoked, then remove the <code>new</code> or <code>const</code> keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() =&gt; 0;</p>\n<p>void g() {\nf();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#creation_with_non_type"
    },
    {
        "key": "curly_braces_in_flow_control_structures",
        "name": "DO use curly braces for all flow control structures.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use curly braces for all flow control structures.</p>\n<p>Doing so avoids the <a href=\"https://en.wikipedia.org/wiki/Dangling_else\">dangling else</a>\nproblem.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (isWeekDay) {\n  print('Bike to work!');\n} else {\n  print('Go dancing or read a book!');\n}\n</code></pre>\n<p>There is one exception to this: an <code>if</code> statement with no <code>else</code> clause where\nthe entire <code>if</code> statement and the then body all fit in one line. In that case,\nyou may leave off the braces if you prefer:</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (arg == null) return defaultValue;\n</code></pre>\n<p>If the body wraps to the next line, though, use braces:</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (overflowChars != other.overflowChars) {\n  return overflowChars &lt; other.overflowChars;\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">if (overflowChars != other.overflowChars)\n  return overflowChars &lt; other.overflowChars;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/curly_braces_in_flow_control_structures.html"
    },
    {
        "key": "dead_code",
        "name": "Dead code",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Dead code.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when code is found that won't be\nexecuted because execution will never reach the code.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the invocation of\n<code>print</code> occurs after the function has returned:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nreturn;\n[!print('here');!]\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the code isn't needed, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nreturn;\n}\n{% endprettify %}</p>\n<p>If the code needs to be executed, then either move the code to a place\nwhere it will be executed:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nprint('here');\nreturn;\n}\n{% endprettify %}</p>\n<p>Or, rewrite the code before it, so that it can be reached:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f({bool skipPrinting = true}) {\nif (skipPrinting) {\nreturn;\n}\nprint('here');\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#dead_code"
    },
    {
        "key": "dead_code_catch_following_catch",
        "name": "Dead code catch following catch",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Dead code: Catch clauses after a 'catch (e)' or an 'on Object catch (e)' are\nnever reached.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a <code>catch</code> clause is found that\ncan't be executed because itâ€™s after a <code>catch</code> clause of the form\n<code>catch (e)</code> or <code>on Object catch (e)</code>. The first <code>catch</code> clause that matches\nthe thrown object is selected, and both of those forms will match any\nobject, so no <code>catch</code> clauses that follow them will be selected.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n} catch (e) {\n} [!on String {\n}!]\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the clause should be selectable, then move the clause before the general\nclause:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n} on String {\n} catch (e) {\n}\n}\n{% endprettify %}</p>\n<p>If the clause doesn't need to be selectable, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n} catch (e) {\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#dead_code_catch_following_catch"
    },
    {
        "key": "dead_code_on_catch_subtype",
        "name": "Dead code on catch subtype",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Dead code: This on-catch block wonâ€™t be executed because '{0}' is a subtype of\n'{1}' and hence will have been caught already.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a <code>catch</code> clause is found that\ncan't be executed because it is after a <code>catch</code> clause that catches either\nthe same type or a supertype of the clause's type. The first <code>catch</code> clause\nthat matches the thrown object is selected, and the earlier clause always\nmatches anything matchable by the highlighted clause, so the highlighted\nclause will never be selected.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n} on num {\n} [!on int {\n}!]\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the clause should be selectable, then move the clause before the general\nclause:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n} on int {\n} on num {\n}\n}\n{% endprettify %}</p>\n<p>If the clause doesn't need to be selectable, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n} on num {\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#dead_code_on_catch_subtype"
    },
    {
        "key": "dead_null_aware_expression",
        "name": "Dead null aware expression",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The left operand can't be null, so the right operand is never executed.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic in two cases.</p>\n<p>The first is when the left operand of an <code>??</code> operator can't be <code>null</code>.\nThe right operand is only evaluated if the left operand has the value\n<code>null</code>, and because the left operand can't be <code>null</code>, the right operand is\nnever evaluated.</p>\n<p>The second is when the left-hand side of an assignment using the <code>??=</code>\noperator can't be <code>null</code>. The right-hand side is only evaluated if the\nleft-hand side has the value <code>null</code>, and because the left-hand side can't\nbe <code>null</code>, the right-hand side is never evaluated.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>x</code> can't be <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint f(int x) {\nreturn x ?? [!0!];\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>f</code> can't be <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f = -1;</p>\n<p>void m(int x) {\nf ??= [!x!];\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the diagnostic is reported for an <code>??</code> operator, then remove the <code>??</code>\noperator and the right operand:</p>\n<p>{% prettify dart tag=pre+code %}\nint f(int x) {\nreturn x;\n}\n{% endprettify %}</p>\n<p>If the diagnostic is reported for an assignment, and the assignment isn't\nneeded, then remove the assignment:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f = -1;</p>\n<p>void m(int x) {\n}\n}\n{% endprettify %}</p>\n<p>If the assignment is needed, but should be based on a different condition,\nthen rewrite the code to use <code>=</code> and the different condition:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f = -1;</p>\n<p>void m(int x) {\nif (f &lt; 0) {\nf = x;\n}\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#dead_null_aware_expression"
    },
    {
        "key": "default_list_constructor",
        "name": "Default list constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The default 'List' constructor isn't available when null safety is enabled.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds a use of the default\nconstructor for the class <code>List</code> in code that has opted in to null safety.</p>\n<h4>Example</h4>\n<p>Assuming the following code is opted in to null safety, it produces this\ndiagnostic because it uses the default <code>List</code> constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nvar l = <a href=\"\">!List<int>!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If no initial size is provided, then convert the code to use a list\nliteral:</p>\n<p>{% prettify dart tag=pre+code %}\nvar l = <int>[];\n{% endprettify %}</p>\n<p>If an initial size needs to be provided and there is a single reasonable\ninitial value for the elements, then use <code>List.filled</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvar l = List.filled(3, 0);\n{% endprettify %}</p>\n<p>If an initial size needs to be provided but each element needs to be\ncomputed, then use <code>List.generate</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvar l = List.generate(3, (i) =&gt; i);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#default_list_constructor"
    },
    {
        "key": "default_value_in_redirecting_factory_constructor",
        "name": "Default value in redirecting factory constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Default values aren't allowed in factory constructors that redirect to another\nconstructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a factory constructor that\nredirects to another constructor specifies a default value for an optional\nparameter.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the factory constructor\nin <code>A</code> has a default value for the optional parameter <code>x</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nfactory A([int [!x!] = 0]) = B;\n}</p>\n<p>class B implements A {\nB([int x = 1]) {}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the default value from the factory constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nfactory A([int x]) = B;\n}</p>\n<p>class B implements A {\nB([int x = 1]) {}\n}\n{% endprettify %}</p>\n<p>Note that this fix might change the value used when the optional parameter\nis omitted. If that happens, and if that change is a problem, then consider\nmaking the optional parameter a required parameter in the factory method:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nfactory A(int x) = B;\n}</p>\n<p>class B implements A {\nB([int x = 1]) {}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#default_value_in_redirecting_factory_constructor"
    },
    {
        "key": "default_value_on_required_parameter",
        "name": "Default value on required parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Required named parameters can't have a default value.\n\nTry removing either the default value or the 'required' modifier."
    },
    {
        "key": "deferred_import_of_extension",
        "name": "Deferred import of extension",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Imports of deferred libraries must hide all extensions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a library that is imported using\na deferred import declares an extension that is visible in the importing\nlibrary. Extension methods are resolved at compile time, and extensions\nfrom deferred libraries aren't available at compile time.</p>\n<p>For more information, see the language tour's coverage of\n<a href=\"https://dart.dev/guides/language/language-tour#lazily-loading-a-library\">deferred loading</a>.</p>\n<h4>Example</h4>\n<p>Given a file (<code>a.dart</code>) that defines a named extension:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}</p>\n<p>extension E on String {\nint get size =&gt; length;\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the named extension is\nvisible to the library:</p>\n<p>{% prettify dart tag=pre+code %}\nimport [!'a.dart'!] deferred as a;</p>\n<p>void f() {\na.C();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the library must be imported as <code>deferred</code>, then either add a <code>show</code>\nclause listing the names being referenced or add a <code>hide</code> clause listing\nall of the named extensions. Adding a <code>show</code> clause would look like this:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' deferred as a show C;</p>\n<p>void f() {\na.C();\n}\n{% endprettify %}</p>\n<p>Adding a <code>hide</code> clause would look like this:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' deferred as a hide E;</p>\n<p>void f() {\na.C();\n}\n{% endprettify %}</p>\n<p>With the first fix, the benefit is that if new extensions are added to the\nimported library, then the extensions won't cause a diagnostic to be\ngenerated.</p>\n<p>If the library doesn't need to be imported as <code>deferred</code>, or if you need to\nmake use of the extension method declared in it, then remove the keyword\n<code>deferred</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' as a;</p>\n<p>void f() {\na.C();\n}\n{% endprettify %}</p>"
    },
    {
        "key": "definitely_unassigned_late_local_variable",
        "name": "Definitely unassigned late local variable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The late local variable '{0}' is definitely unassigned at this point.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when <a href=\"https://dart.dev/tools/diagnostic-messages#definite-assignment\">definite assignment</a> analysis\nshows that a local variable that's marked as <code>late</code> is read before being\nassigned.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>x</code> wasn't assigned a\nvalue before being read:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(bool b) {\nlate int x;\nprint([!x!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Assign a value to the variable before reading from it:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(bool b) {\nlate int x;\nx = b ? 1 : 0;\nprint(x);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#definitely_unassigned_late_local_variable"
    },
    {
        "key": "deprecated_consistency",
        "name": "Missing deprecated annotation.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Do apply <code>@Deprecated()</code> consistently:</p>\n<ul>\n<li>if a class is deprecated, its constructors should also be deprecated.</li>\n<li>if a field is deprecated, the constructor parameter pointing to it should also be deprecated.</li>\n<li>if a constructor parameter pointing to a field is deprecated, the field should also be deprecated.</li>\n</ul>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">@deprecated\nclass A {\n  A();\n}\n\nclass B {\n  B({this.field});\n  @deprecated\n  Object field;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">@deprecated\nclass A {\n  @deprecated\n  A();\n}\n\nclass B {\n  B({@deprecated this.field});\n  @deprecated\n  Object field;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/deprecated_consistency.html"
    },
    {
        "key": "deprecated_extends_function",
        "name": "Deprecated extends function",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Extending 'Function' is deprecated.\n\nTry removing 'Function' from the 'extends' clause."
    },
    {
        "key": "deprecated_function_class_declaration",
        "name": "Deprecated function class declaration",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Declaring a class named 'Function' is deprecated.\n\nTry renaming the class."
    },
    {
        "key": "deprecated_member_use",
        "name": "Deprecated member use",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>'{0}' is deprecated and shouldn't be used.</em></p>\n<p><em>'{0}' is deprecated and shouldn't be used. {1}.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a deprecated library or class\nmember is used in a different package.</p>\n<h4>Examples</h4>\n<p>If the method <code>m</code> in the class <code>C</code> is annotated with <code>@deprecated</code>, then\nthe following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(C c) {\nc.<a href=\"\">!m!</a>;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>The documentation for declarations that are annotated with <code>@deprecated</code>\nshould indicate what code to use in place of the deprecated code.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#deprecated_member_use"
    },
    {
        "key": "deprecated_member_use_from_same_package",
        "name": "Deprecated member use from same package",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>'{0}' is deprecated and shouldn't be used.</em></p>\n<p><em>'{0}' is deprecated and shouldn't be used. {1}.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a deprecated library member or\nclass member is used in the same package in which it's declared.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> is deprecated:</p>\n<p>{% prettify dart tag=pre+code %}\n@deprecated\nvar x = 0;\nvar y = [!x!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>The fix depends on what's been deprecated and what the replacement is. The\ndocumentation for deprecated declarations should indicate what code to use\nin place of the deprecated code.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#deprecated_member_use_from_same_package"
    },
    {
        "key": "deprecated_mixin_function",
        "name": "Deprecated mixin function",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Mixing in 'Function' is deprecated.\n\nTry removing 'Function' from the 'with' clause."
    },
    {
        "key": "diagnostic_describe_all_properties",
        "name": "DO reference all public properties in debug methods.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DO</strong> reference all public properties in <code>debug</code> method implementations.</p>\n<p>Implementers of <code>Diagnosticable</code> should reference all public properties in\na <code>debugFillProperties(...)</code> or <code>debugDescribeChildren(...)</code> method\nimplementation to improve debuggability at runtime.</p>\n<p>Public properties are defined as fields and getters that are</p>\n<ul>\n<li>not package-private (e.g., prefixed with <code>_</code>)</li>\n<li>not <code>static</code> or overriding</li>\n<li>not themselves <code>Widget</code>s or collections of <code>Widget</code>s</li>\n</ul>\n<p>In addition, the \"debug\" prefix is treated specially for properties in Flutter.\nFor the purposes of diagnostics, a property <code>foo</code> and a prefixed property\n<code>debugFoo</code> are treated as effectively describing the same property and it is\nsufficient to refer to one or the other.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Absorber extends Widget {\n  bool get absorbing =&gt; _absorbing;\n  bool _absorbing;\n  bool get ignoringSemantics =&gt; _ignoringSemantics;\n  bool _ignoringSemantics;\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty&lt;bool&gt;('absorbing', absorbing));\n    // Missing reference to ignoringSemantics\n  }\n}  \n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Absorber extends Widget {\n  bool get absorbing =&gt; _absorbing;\n  bool _absorbing;\n  bool get ignoringSemantics =&gt; _ignoringSemantics;\n  bool _ignoringSemantics;\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty&lt;bool&gt;('absorbing', absorbing));\n    properties.add(DiagnosticsProperty&lt;bool&gt;('ignoringSemantics', ignoringSemantics));\n  }\n}  \n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/diagnostic_describe_all_properties.html"
    },
    {
        "key": "directives_ordering",
        "name": "Adhere to Effective Dart Guide directives sorting conventions.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> follow the conventions in the \n<a href=\"https://dart.dev/guides/language/effective-dart/style#ordering\">Effective Dart Guide</a></p>\n<p><strong>DO</strong> place â€œdart:â€ imports before other imports.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'package:bar/bar.dart';\nimport 'package:foo/foo.dart';\n\nimport 'dart:async';  // LINT\nimport 'dart:html';  // LINT\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'dart:html';  // OK\nimport 'package:bar/bar.dart';\n\nimport 'dart:async';  // LINT\nimport 'package:foo/foo.dart';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">import 'dart:async';  // OK\nimport 'dart:html';  // OK\n\nimport 'package:bar/bar.dart';\nimport 'package:foo/foo.dart';\n</code></pre>\n<p><strong>DO</strong> place â€œpackage:â€ imports before relative imports.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'a.dart';\nimport 'b.dart';\n\nimport 'package:bar/bar.dart';  // LINT\nimport 'package:foo/foo.dart';  // LINT\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'package:bar/bar.dart';  // OK\nimport 'a.dart';\n\nimport 'package:foo/foo.dart';  // LINT\nimport 'b.dart';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">import 'package:bar/bar.dart';  // OK\nimport 'package:foo/foo.dart';  // OK\n\nimport 'a.dart';\nimport 'b.dart';\n</code></pre>\n<p><strong>DO</strong> specify exports in a separate section after all imports.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'src/error.dart';\nexport 'src/error.dart'; // LINT\nimport 'src/string_source.dart';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">import 'src/error.dart';\nimport 'src/string_source.dart';\n\nexport 'src/error.dart'; // OK\n</code></pre>\n<p><strong>DO</strong> sort sections alphabetically.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'package:foo/bar.dart'; // OK\nimport 'package:bar/bar.dart'; // LINT\n\nimport 'a/b.dart'; // OK\nimport 'a.dart'; // LINT\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">import 'package:bar/bar.dart'; // OK\nimport 'package:foo/bar.dart'; // OK\n\nimport 'a.dart'; // OK\nimport 'a/b.dart'; // OK\n\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/directives_ordering.html"
    },
    {
        "key": "division_optimization",
        "name": "Division optimization",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The operator x ~/ y is more efficient than (x / y).toInt().\n\nTry re-writing the expression to use the '~/' operator."
    },
    {
        "key": "do_not_use_environment",
        "name": "Do not use environment declared variables.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Using values derived from the environment at compile-time, creates\nhidden global state and makes applications hard to understand and maintain.</p>\n<p><strong>DO NOT</strong> use <code>fromEnvironment</code> or <code>hasEnvironment</code> factory constructors.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">const loggingLevel =\n  bool.hasEnvironment('logging') ? String.fromEnvironment('logging') : null;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/do_not_use_environment.html"
    },
    {
        "key": "duplicate_constructor",
        "name": "Duplicate constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The constructor with name '{0}' is already defined.</em></p>\n<p><em>The default constructor is already defined.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class declares more than one\nunnamed constructor or when it declares more than one constructor with the\nsame name.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because there are two\ndeclarations for the unnamed constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC();</p>\n<p><a href=\"\">!C!</a>;\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because there are two\ndeclarations for the constructor named <code>m</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.m();</p>\n<p><a href=\"\">!C.m!</a>;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If there are multiple unnamed constructors and all of the constructors are\nneeded, then give all of them, or all except one of them, a name:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC();</p>\n<p>C.n();\n}\n{% endprettify %}</p>\n<p>If there are multiple unnamed constructors and all except one of them are\nunneeded, then remove the constructors that aren't needed:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC();\n}\n{% endprettify %}</p>\n<p>If there are multiple named constructors and all of the constructors are\nneeded, then rename all except one of them:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.m();</p>\n<p>C.n();\n}\n{% endprettify %}</p>\n<p>If there are multiple named constructors and all except one of them are\nunneeded, then remove the constructorsthat aren't needed:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.m();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#duplicate_constructor"
    },
    {
        "key": "duplicate_definition",
        "name": "Duplicate definition",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' is already defined.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a name is declared, and there is\na previous declaration with the same name in the same scope.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the name <code>x</code> is\ndeclared twice:</p>\n<p>{% prettify dart tag=pre+code %}\nint x = 0;\nint [!x!] = 1;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Choose a different name for one of the declarations.</p>\n<p>{% prettify dart tag=pre+code %}\nint x = 0;\nint y = 1;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#duplicate_definition"
    },
    {
        "key": "duplicate_field_formal_parameter",
        "name": "Duplicate field formal parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The field '{0}' can't be referenced in multiple initializing parameters in the same constructor.\n\nTry removing one of the parameters, or using different fields."
    },
    {
        "key": "duplicate_hidden_name",
        "name": "Duplicate hidden name",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Duplicate hidden name.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a name occurs multiple times in\na <code>hide</code> clause. Repeating the name is unnecessary.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the name <code>min</code> is\nhidden more than once:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' hide min, [!min!];</p>\n<p>var x = pi;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the name was mistyped in one or more places, then correct the mistyped\nnames:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' hide max, min;</p>\n<p>var x = pi;\n{% endprettify %}</p>\n<p>If the name wasn't mistyped, then remove the unnecessary name from the\nlist:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' hide min;</p>\n<p>var x = pi;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#duplicate_hidden_name"
    },
    {
        "key": "duplicate_ignore",
        "name": "Duplicate ignore",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The diagnostic '{0}' doesn't need to be ignored here because it's already being\nignored.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a diagnostic name appears in an\n<code>ignore</code> comment, but the diagnostic is already being ignored, either\nbecause it's already included in the same <code>ignore</code> comment or because it\nappears in an <code>ignore-in-file</code> comment.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the diagnostic named\n<code>unused_local_variable</code> is already being ignored for the whole file so it\ndoesn't need to be ignored on a specific line:</p>\n<p>{% prettify dart tag=pre+code %}\n// ignore_for_file: unused_local_variable\nvoid f() {\n// ignore: [!unused_local_variable!]\nvar x = 0;\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the diagnostic named\n<code>unused_local_variable</code> is being ignored twice on the same line:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\n// ignore: unused_local_variable, [!unused_local_variable!]\nvar x = 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the ignore comment, or remove the unnecessary diagnostic name if the\nignore comment is ignoring more than one diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\n// ignore_for_file: unused_local_variable\nvoid f() {\nvar x = 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#duplicate_ignore"
    },
    {
        "key": "duplicate_import",
        "name": "Duplicate import",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Duplicate import.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an import directive is found\nthat is the same as an import before it in the file. The second import\ndoesnâ€™t add value and should be removed.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';\nimport [!'package:meta/meta.dart'!];</p>\n<p>@sealed class C {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the unnecessary import:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>@sealed class C {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#duplicate_import"
    },
    {
        "key": "duplicate_named_argument",
        "name": "Duplicate named argument",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The argument for the named parameter '{0}' was already specified.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an invocation has two or more\nnamed arguments that have the same name.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because there are two arguments\nwith the name <code>a</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(C c) {\nc.m(a: 0, [!a!]: 1);\n}</p>\n<p>class C {\nvoid m({int a, int b}) {}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If one of the arguments should have a different name, then change the name:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(C c) {\nc.m(a: 0, b: 1);\n}</p>\n<p>class C {\nvoid m({int a, int b}) {}\n}\n{% endprettify %}</p>\n<p>If one of the arguments is wrong, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(C c) {\nc.m(a: 1);\n}</p>\n<p>class C {\nvoid m({int a, int b}) {}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#duplicate_named_argument"
    },
    {
        "key": "duplicate_part",
        "name": "Duplicate part",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The library already contains a part with the URI '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a single file is referenced in\nmultiple part directives.</p>\n<h4>Example</h4>\n<p>Given a file named <code>part.dart</code> containing</p>\n<p>{% prettify dart tag=pre+code %}\npart of lib;\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the file <code>part.dart</code> is\nincluded multiple times:</p>\n<p>{% prettify dart tag=pre+code %}\nlibrary lib;</p>\n<p>part 'part.dart';\npart [!'part.dart'!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove all except the first of the duplicated part directives:</p>\n<p>{% prettify dart tag=pre+code %}\nlibrary lib;</p>\n<p>part 'part.dart';\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#duplicate_part"
    },
    {
        "key": "duplicate_shown_name",
        "name": "Duplicate shown name",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Duplicate shown name.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a name occurs multiple times in\na <code>show</code> clause. Repeating the name is unnecessary.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the name <code>min</code> is shown\nmore than once:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' show min, [!min!];</p>\n<p>var x = min(2, min(0, 1));\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the name was mistyped in one or more places, then correct the mistyped\nnames:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' show max, min;</p>\n<p>var x = max(2, min(0, 1));\n{% endprettify %}</p>\n<p>If the name wasn't mistyped, then remove the unnecessary name from the\nlist:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' show min;</p>\n<p>var x = min(2, min(0, 1));\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#duplicate_shown_name"
    },
    {
        "key": "empty_catches",
        "name": "Avoid empty catch blocks.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> empty catch blocks.</p>\n<p>In general, empty catch blocks should be avoided.  In cases where they are\nintended, a comment should be provided to explain why exceptions are being\ncaught and suppressed.  Alternatively, the exception identifier can be named with\nunderscores (e.g., <code>_</code>) to indicate that we intend to skip it.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">try {\n  ...\n} catch(exception) { }\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">try {\n  ...\n} catch(e) {\n  // ignored, really.\n}\n\n// Alternatively:\ntry {\n  ...\n} catch(_) { }\n\n// Better still:\ntry {\n  ...\n} catch(e) {\n  doSomething(e);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/empty_catches.html"
    },
    {
        "key": "empty_constructor_bodies",
        "name": "Use `;` instead of `{}` for empty constructor bodies.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</a>:</p>\n<p><strong>DO</strong> use <code>;</code> instead of <code>{}</code> for empty constructor bodies.</p>\n<p>In Dart, a constructor with an empty body can be terminated with just a\nsemicolon.  This is required for const constructors.  For consistency and\nbrevity, other constructors should also do this.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  int x, y;\n  Point(this.x, this.y);\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  int x, y;\n  Point(this.x, this.y) {}\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/empty_constructor_bodies.html"
    },
    {
        "key": "empty_statements",
        "name": "Avoid empty statements.",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><strong>AVOID</strong> empty statements.</p>\n<p>Empty statements almost always indicate a bug.</p>\n<p>For example,</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">if (complicated.expression.foo());\n  bar();\n</code></pre>\n<p>Formatted with <code>dart format</code> the bug becomes obvious:</p>\n<pre><code class=\"language-dart\">if (complicated.expression.foo()) ;\nbar();\n\n</code></pre>\n<p>Better to avoid the empty statement altogether.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (complicated.expression.foo())\n  bar();\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/empty_statements.html"
    },
    {
        "key": "enum_constant_same_name_as_enclosing",
        "name": "Enum constant same name as enclosing",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The name of the enum constant can't be the same as the enum's name.\n\nTry renaming the constant."
    },
    {
        "key": "equal_elements_in_const_set",
        "name": "Equal elements in const set",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Two elements in a constant set literal can't be equal.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when two elements in a constant set\nliteral have the same value. The set can only contain each value once,\nwhich means that one of the values is unnecessary.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the string <code>'a'</code> is\nspecified twice:</p>\n<p>{% prettify dart tag=pre+code %}\nconst Set<String> set = {'a', [!'a'!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove one of the duplicate values:</p>\n<p>{% prettify dart tag=pre+code %}\nconst Set<String> set = {'a'};\n{% endprettify %}</p>\n<p>Note that literal sets preserve the order of their elements, so the choice\nof which element to remove might affect the order in which elements are\nreturned by an iterator.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#equal_elements_in_const_set"
    },
    {
        "key": "equal_elements_in_set",
        "name": "Equal elements in set",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Two elements in a set literal shouldn't be equal.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an element in a non-constant set\nis the same as a previous element in the same set. If two elements are the\nsame, then the second value is ignored, which makes having both elements\npointless and likely signals a bug.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the element <code>1</code> appears\ntwice:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = 1;\nconst b = 1;\nvar s = <int>{a, [!b!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If both elements should be included in the set, then change one of the\nelements:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = 1;\nconst b = 2;\nvar s = <int>{a, b};\n{% endprettify %}</p>\n<p>If only one of the elements is needed, then remove the one that isn't\nneeded:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = 1;\nvar s = <int>{a};\n{% endprettify %}</p>\n<p>Note that literal sets preserve the order of their elements, so the choice\nof which element to remove might affect the order in which elements are\nreturned by an iterator.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#equal_elements_in_set"
    },
    {
        "key": "equal_keys_in_const_map",
        "name": "Equal keys in const map",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Two keys in a constant map literal can't be equal.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a key in a constant map is the\nsame as a previous key in the same map. If two keys are the same, then the\nsecond value would overwrite the first value, which makes having both pairs\npointless.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the key <code>1</code> is used\ntwice:</p>\n<p>{% prettify dart tag=pre+code %}\nconst map = &lt;int, String&gt;{1: 'a', 2: 'b', [!1!]: 'c', 4: 'd'};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If both entries should be included in the map, then change one of the keys\nto be different:</p>\n<p>{% prettify dart tag=pre+code %}\nconst map = &lt;int, String&gt;{1: 'a', 2: 'b', 3: 'c', 4: 'd'};\n{% endprettify %}</p>\n<p>If only one of the entries is needed, then remove the one that isn't\nneeded:</p>\n<p>{% prettify dart tag=pre+code %}\nconst map = &lt;int, String&gt;{1: 'a', 2: 'b', 4: 'd'};\n{% endprettify %}</p>\n<p>Note that literal maps preserve the order of their entries, so the choice\nof which entry to remove might affect the order in which keys and values\nare returned by an iterator.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#equal_keys_in_const_map"
    },
    {
        "key": "equal_keys_in_map",
        "name": "Equal keys in map",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Two keys in a map literal shouldn't be equal.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a key in a non-constant map is\nthe same as a previous key in the same map. If two keys are the same, then\nthe second value overwrites the first value, which makes having both pairs\npointless and likely signals a bug.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the keys <code>a</code> and <code>b</code>\nhave the same value:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = 1;\nconst b = 1;\nvar m = &lt;int, String&gt;{a: 'a', [!b!]: 'b'};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If both entries should be included in the map, then change one of the keys:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = 1;\nconst b = 2;\nvar m = &lt;int, String&gt;{a: 'a', b: 'b'};\n{% endprettify %}</p>\n<p>If only one of the entries is needed, then remove the one that isn't\nneeded:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = 1;\nvar m = &lt;int, String&gt;{a: 'a'};\n{% endprettify %}</p>\n<p>Note that literal maps preserve the order of their entries, so the choice\nof which entry to remove might affect the order in which the keys and\nvalues are returned by an iterator.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#equal_keys_in_map"
    },
    {
        "key": "exhaustive_cases",
        "name": "Define case clauses for all constants in enum-like classes.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Switching on instances of enum-like classes should be exhaustive.</p>\n<p>Enum-like classes are defined as concrete (non-abstract) classes that have:</p>\n<ul>\n<li>only private non-factory constructors</li>\n<li>two or more static const fields whose type is the enclosing class and</li>\n<li>no subclasses of the class in the defining library</li>\n</ul>\n<p><strong>DO</strong> define case clauses for all constants in enum-like classes.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class EnumLike {\n  final int i;\n  const E._(this.i);\n\n  static const e = E._(1);\n  static const f = E._(2);\n  static const g = E._(3);\n}\n\nvoid bad(EnumLike e) {\n  // Missing case.\n  switch(e) { // LINT\n    case E.e :\n      print('e');\n      break;\n    case E.f :\n      print('e');\n      break;\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class EnumLike {\n  final int i;\n  const E._(this.i);\n\n  static const e = E._(1);\n  static const f = E._(2);\n  static const g = E._(3);\n}\n\nvoid ok(E e) {\n  // All cases covered.\n  switch(e) { // OK\n    case E.e :\n      print('e');\n      break;\n    case E.f :\n      print('e');\n      break;\n    case E.g :\n      print('e');\n      break;\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/exhaustive_cases.html"
    },
    {
        "key": "expected_one_list_type_arguments",
        "name": "Expected one list type arguments",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>List literals require one type argument or none, but {0} found.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a list literal has more than one\ntype argument.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the list literal has\ntwo type arguments when it can have at most one:</p>\n<p>{% prettify dart tag=pre+code %}\nvar l = [!&lt;int, int&gt;!][];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove all except one of the type arguments:</p>\n<p>{% prettify dart tag=pre+code %}\nvar l = <int>[];\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#expected_one_list_type_arguments"
    },
    {
        "key": "expected_one_set_type_arguments",
        "name": "Expected one set type arguments",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Set literals require one type argument or none, but {0} were found.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a set literal has more than one\ntype argument.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the set literal has\nthree type arguments when it can have at most one:</p>\n<p>{% prettify dart tag=pre+code %}\nvar s = [!&lt;int, String, int&gt;!]{0, 'a', 1};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove all except one of the type arguments:</p>\n<p>{% prettify dart tag=pre+code %}\nvar s = <int>{0, 1};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#expected_one_set_type_arguments"
    },
    {
        "key": "expected_two_map_type_arguments",
        "name": "Expected two map type arguments",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Map literals require two type arguments or none, but {0} found.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a map literal has either one or\nmore than two type arguments.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the map literal has\nthree type arguments when it can have either two or zero:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = [!&lt;int, String, int&gt;!]{};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove all except two of the type arguments:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = &lt;int, String&gt;{};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#expected_two_map_type_arguments"
    },
    {
        "key": "export_internal_library",
        "name": "Export internal library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The library '{0}' is internal and can't be exported.\n\nnull"
    },
    {
        "key": "export_legacy_symbol",
        "name": "Export legacy symbol",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The symbol '{0}' is defined in a legacy library, and can't be re-exported from\na library with null safety enabled.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a library that was opted in to\nnull safety exports another library, and the exported library is opted out\nof null safety.</p>\n<h4>Example</h4>\n<p>Given a library that is opted out of null safety:</p>\n<p>{% prettify dart tag=pre+code %}\n// @dart = 2.8\nString s;\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because it's exporting symbols\nfrom an opted-out library:</p>\n<p>{% prettify dart tag=pre+code %}\nexport [!'optedOut.dart'!];</p>\n<p>class C {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you're able to do so, migrate the exported library so that it doesn't\nneed to opt out:</p>\n<p>{% prettify dart tag=pre+code %}\nString? s;\n{% endprettify %}</p>\n<p>If you can't migrate the library, then remove the export:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}\n{% endprettify %}</p>\n<p>If the exported library (the one that is opted out) itself exports an\nopted-in library, then it's valid for your library to indirectly export the\nsymbols from the opted-in library. You can do so by adding a hide\ncombinator to the export directive in your library that hides all of the\nnames declared in the opted-out library.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#export_legacy_symbol"
    },
    {
        "key": "export_of_non_library",
        "name": "Export of non library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The exported library '{0}' can't have a part-of directive.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an export directive references a\npart rather than a library.</p>\n<h4>Example</h4>\n<p>Given a file named <code>part.dart</code> containing</p>\n<p>{% prettify dart tag=pre+code %}\npart of lib;\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the file <code>part.dart</code> is\na part, and only libraries can be exported:</p>\n<p>{% prettify dart tag=pre+code %}\nlibrary lib;</p>\n<p>export [!'part.dart'!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Either remove the export directive, or change the URI to be the URI of the\nlibrary containing the part.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#export_of_non_library"
    },
    {
        "key": "expression_in_map",
        "name": "Expression in map",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Expressions can't be used in a map literal.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the analyzer finds an\nexpression, rather than a map entry, in what appears to be a map literal.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nvar map = &lt;String, int&gt;{'a': 0, 'b': 1, [!'c'!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the expression is intended to compute either a key or a value in an\nentry, fix the issue by replacing the expression with the key or the value.\nFor example:</p>\n<p>{% prettify dart tag=pre+code %}\nvar map = &lt;String, int&gt;{'a': 0, 'b': 1, 'c': 2};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#expression_in_map"
    },
    {
        "key": "extends_non_class",
        "name": "Extends non class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Classes can only extend other classes.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an <code>extends</code> clause contains a\nname that is declared to be something other than a class.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> is declared to be a\nfunction:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {}</p>\n<p>class C extends [!f!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you want the class to extend a class other than <code>Object</code>, then replace\nthe name in the <code>extends</code> clause with the name of that class:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {}</p>\n<p>class C extends B {}</p>\n<p>class B {}\n{% endprettify %}</p>\n<p>If you want the class to extend <code>Object</code>, then remove the <code>extends</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {}</p>\n<p>class C {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extends_non_class"
    },
    {
        "key": "extends_type_alias_expands_to_type_parameter",
        "name": "Extends type alias expands to type parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Type aliases that expand to a type parameter can't be used as superclasses.\n\nTry specifying a different superclass, or removing the extends clause."
    },
    {
        "key": "extension_as_expression",
        "name": "Extension as expression",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Extension '{0}' can't be used as an expression.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the name of an extension is used\nin an expression other than in an extension override or to qualify an\naccess to a static member of the extension. Because classes define a type,\nthe name of a class can be used to refer to the instance of <code>Type</code>\nrepresenting the type of the class. Extensions, on the other hand, don't\ndefine a type and can't be used as a type literal.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>E</code> is an extension:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on int {\nstatic String m() =&gt; '';\n}</p>\n<p>var x = [!E!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the name of the extension with a name that can be referenced, such\nas a static member defined on the extension:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on int {\nstatic String m() =&gt; '';\n}</p>\n<p>var x = E.m();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extension_as_expression"
    },
    {
        "key": "extension_conflicting_static_and_instance",
        "name": "Extension conflicting static and instance",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Extension '{0}' can't define static member '{1}' and an instance member with\nthe same name.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension declaration\ncontains both an instance member and a static member that have the same\nname. The instance member and the static member can't have the same name\nbecause it's unclear which member is being referenced by an unqualified use\nof the name within the body of the extension.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the name <code>a</code> is being\nused for two different members:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on Object {\nint get a =&gt; 0;\nstatic int <a href=\"\">!a!</a> =&gt; 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Rename or remove one of the members:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on Object {\nint get a =&gt; 0;\nstatic int b() =&gt; 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extension_conflicting_static_and_instance"
    },
    {
        "key": "extension_declares_member_of_object",
        "name": "Extension declares member of object",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Extensions can't declare members with the same name as a member declared by\n'Object'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension declaration\ndeclares a member with the same name as a member declared in the class\n<code>Object</code>. Such a member can never be used because the member in <code>Object</code> is\nalways found first.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>toString</code> is defined\nby <code>Object</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString <a href=\"\">!toString!</a> =&gt; this;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the member or rename it so that the name doesn't conflict with the\nmember in <code>Object</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString displayString() =&gt; this;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extension_declares_member_of_object"
    },
    {
        "key": "extension_override_access_to_static_member",
        "name": "Extension override access to static member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>An extension override can't be used to access a static member from an\nextension.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension override is the\nreceiver of the invocation of a static member. Similar to static members in\nclasses, the static members of an extension should be accessed using the\nname of the extension, not an extension override.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>m</code> is static:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nstatic void m() {}\n}</p>\n<p>void f() {\nE('').<a href=\"\">!m!</a>;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the extension override with the name of the extension:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nstatic void m() {}\n}</p>\n<p>void f() {\nE.m();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extension_override_access_to_static_member"
    },
    {
        "key": "extension_override_argument_not_assignable",
        "name": "Extension override argument not assignable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The type of the argument to the extension override '{0}' isn't assignable to\nthe extended type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the argument to an extension\noverride isn't assignable to the type being extended by the extension.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>3</code> isn't a <code>String</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nvoid method() {}\n}</p>\n<p>void f() {\nE([!3!]).method();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you're using the correct extension, then update the argument to have the\ncorrect type:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nvoid method() {}\n}</p>\n<p>void f() {\nE(3.toString()).method();\n}\n{% endprettify %}</p>\n<p>If there's a different extension that's valid for the type of the argument,\nthen either replace the name of the extension or unwrap the argument so\nthat the correct extension is found.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extension_override_argument_not_assignable"
    },
    {
        "key": "extension_override_with_cascade",
        "name": "Extension override with cascade",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Extension overrides have no value so they can't be used as the receiver of a\ncascade expression.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension override is used as\nthe receiver of a cascade expression. The value of a cascade expression\n<code>e..m</code> is the value of the receiver <code>e</code>, but extension overrides aren't\nexpressions and don't have a value.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>E(3)</code> isn't an\nexpression:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on int {\nvoid m() {}\n}\nf() {\n<a href=\"3\">!E!</a>..m();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Use <code>.</code> rather than <code>..</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on int {\nvoid m() {}\n}\nf() {\nE(3).m();\n}\n{% endprettify %}</p>\n<p>If there are multiple cascaded accesses, you'll need to duplicate the\nextension override for each one.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extension_override_with_cascade"
    },
    {
        "key": "extension_override_without_access",
        "name": "Extension override without access",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>An extension override can only be used to access instance members.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension override is found\nthat isn't being used to access one of the members of the extension. The\nextension override syntax doesn't have any runtime semantics; it only\ncontrols which member is selected at compile time.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>E(i)</code> isn't an\nexpression:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on int {\nint get a =&gt; 0;\n}</p>\n<p>void f(int i) {\nprint([!E(i)!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you want to invoke one of the members of the extension, then add the\ninvocation:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on int {\nint get a =&gt; 0;\n}</p>\n<p>void f(int i) {\nprint(E(i).a);\n}\n{% endprettify %}</p>\n<p>If you don't want to invoke a member, then unwrap the argument:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on int {\nint get a =&gt; 0;\n}</p>\n<p>void f(int i) {\nprint(i);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extension_override_without_access"
    },
    {
        "key": "external_field_constructor_initializer",
        "name": "External field constructor initializer",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "External fields cannot have initializers.\n\nTry removing the field initializer or the 'external' keyword from the field declaration."
    },
    {
        "key": "external_field_initializer",
        "name": "External field initializer",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "External fields cannot have initializers.\n\nTry removing the initializer or the 'external' keyword."
    },
    {
        "key": "external_variable_initializer",
        "name": "External variable initializer",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "External variables cannot have initializers.\n\nTry removing the initializer or the 'external' keyword."
    },
    {
        "key": "extra_positional_arguments",
        "name": "Extra positional arguments",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Too many positional arguments: {0} expected, but {1} found.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a method or function invocation\nhas more positional arguments than the method or function allows.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> defines 2\nparameters but is invoked with 3 arguments:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int a, int b) {}\nvoid g() {\nf(1, 2, [!3!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the arguments that don't correspond to parameters:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int a, int b) {}\nvoid g() {\nf(1, 2);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extra_positional_arguments"
    },
    {
        "key": "extra_positional_arguments_could_be_named",
        "name": "Extra positional arguments could be named",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Too many positional arguments: {0} expected, but {1} found.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a method or function invocation\nhas more positional arguments than the method or function allows, but the\nmethod or function defines named parameters.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> defines 2\npositional parameters but has a named parameter that could be used for the\nthird argument:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int a, int b, {int c}) {}\nvoid g() {\nf(1, 2, [!3!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If some of the arguments should be values for named parameters, then add\nthe names before the arguments:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int a, int b, {int c}) {}\nvoid g() {\nf(1, 2, c: 3);\n}\n{% endprettify %}</p>\n<p>Otherwise, remove the arguments that don't correspond to positional\nparameters:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int a, int b, {int c}) {}\nvoid g() {\nf(1, 2);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#extra_positional_arguments_could_be_named"
    },
    {
        "key": "field_initialized_by_multiple_initializers",
        "name": "Field initialized by multiple initializers",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The field '{0}' can't be initialized twice in the same constructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the initializer list of a\nconstructor initializes a field more than once. There is no value to allow\nboth initializers because only the last value is preserved.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the field <code>f</code> is being\ninitialized twice:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C() : f = 0, [!f!] = 1;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove one of the initializers:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C() : f = 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#field_initialized_by_multiple_initializers"
    },
    {
        "key": "field_initialized_in_initializer_and_declaration",
        "name": "Field initialized in initializer and declaration",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Fields can't be initialized in the constructor if they are final and were\nalready initialized at their declaration.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a final field is initialized in\nboth the declaration of the field and in an initializer in a constructor.\nFinal fields can only be assigned once, so it can't be initialized in both\nplaces.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>f</code> is :</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int f = 0;\nC() : [!f!] = 1;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the initialization doesn't depend on any values passed to the\nconstructor, and if all of the constructors need to initialize the field to\nthe same value, then remove the initializer from the constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int f = 0;\nC();\n}\n{% endprettify %}</p>\n<p>If the initialization depends on a value passed to the constructor, or if\ndifferent constructors need to initialize the field differently, then\nremove the initializer in the field's declaration:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int f;\nC() : f = 1;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#field_initialized_in_initializer_and_declaration"
    },
    {
        "key": "field_initialized_in_parameter_and_initializer",
        "name": "Field initialized in parameter and initializer",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Fields can't be initialized in both the parameter list and the initializers.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a field is initialized in both\nthe parameter list and in the initializer list of a constructor.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the field <code>f</code> is\ninitialized both by a field formal parameter and in the initializer list:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C(this.f) : [!f!] = 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the field should be initialized by the parameter, then remove the\ninitialization in the initializer list:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C(this.f);\n}\n{% endprettify %}</p>\n<p>If the field should be initialized in the initializer list and the\nparameter isn't needed, then remove the parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C() : f = 0;\n}\n{% endprettify %}</p>\n<p>If the field should be initialized in the initializer list and the\nparameter is needed, then make it a normal parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C(int g) : f = g * 2;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#field_initialized_in_parameter_and_initializer"
    },
    {
        "key": "field_initializer_factory_constructor",
        "name": "Field initializer factory constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Initializing formal parameters can't be used in factory constructors.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a factory constructor has a\nfield formal parameter. Factory constructors can't assign values to fields\nbecause no instance is created; hence, there is no field to assign.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the factory constructor\nuses a field formal parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint? f;</p>\n<p>factory C([!this.f!]) =&gt; throw 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the field formal parameter with a normal parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint? f;</p>\n<p>factory C(int f) =&gt; throw 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#field_initializer_factory_constructor"
    },
    {
        "key": "field_initializer_not_assignable",
        "name": "Field initializer not assignable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The initializer type '{0}' can't be assigned to the field type '{1}' in a const\nconstructor.</em></p>\n<p><em>The initializer type '{0}' can't be assigned to the field type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the initializer list of a\nconstructor initializes a field to a value that isn't assignable to the\nfield.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>0</code> has the type <code>int</code>,\nand an <code>int</code> can't be assigned to a field of type <code>String</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nString s;</p>\n<p>C() : s = [!0!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type of the field is correct, then change the value assigned to it\nso that the value has a valid type:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nString s;</p>\n<p>C() : s = '0';\n}\n{% endprettify %}</p>\n<p>If the type of the value is correct, then change the type of the field to\nallow the assignment:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint s;</p>\n<p>C() : s = 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#field_initializer_not_assignable"
    },
    {
        "key": "field_initializer_outside_constructor",
        "name": "Field initializer outside constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Initializing formal parameters can only be used in constructors.\n\nTry using a normal parameter."
    },
    {
        "key": "field_initializer_redirecting_constructor",
        "name": "Field initializer redirecting constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The redirecting constructor can't have a field initializer.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a redirecting constructor\ninitializes a field in the object. This isn't allowed because the instance\nthat has the field hasn't been created at the point at which it should be\ninitialized.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the constructor\n<code>C.zero</code>, which redirects to the constructor <code>C</code>, has a field formal\nparameter that initializes the field <code>f</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C(this.f);</p>\n<p>C.zero([!this.f!]) : this(f);\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the constructor\n<code>C.zero</code>, which redirects to the constructor <code>C</code>, has an initializer that\ninitializes the field <code>f</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C(this.f);</p>\n<p>C.zero() : [!f = 0!], this(1);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the initialization is done by a field formal parameter, then use a\nnormal parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C(this.f);</p>\n<p>C.zero(int f) : this(f);\n}\n{% endprettify %}</p>\n<p>If the initialization is done in an initializer, then remove the\ninitializer:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C(this.f);</p>\n<p>C.zero() : this(0);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#field_initializer_redirecting_constructor"
    },
    {
        "key": "field_initializing_formal_not_assignable",
        "name": "Field initializing formal not assignable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The parameter type '{0}' is incompatible with the field type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the type of a field formal\nparameter isn't assignable to the type of the field being initialized.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the field formal\nparameter has the type <code>String</code>, but the type of the field is <code>int</code>. The\nparameter must have a type that is a subtype of the field's type.</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C([!String this.f!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type of the field is incorrect, then change the type of the field to\nmatch the type of the parameter, and consider removing the type from the\nparameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nString f;</p>\n<p>C(this.f);\n}\n{% endprettify %}</p>\n<p>If the type of the parameter is incorrect, then remove the type of the\nparameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C(this.f);\n}\n{% endprettify %}</p>\n<p>If the types of both the field and the parameter are correct, then use an\ninitializer rather than a field formal parameter to convert the parameter\nvalue into a value of the correct type:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint f;</p>\n<p>C(String s) : f = int.parse(s);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#field_initializing_formal_not_assignable"
    },
    {
        "key": "file_import_inside_lib_references_file_outside",
        "name": "File import inside lib references file outside",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "A file in the 'lib' directory shouldn't import a file outside the 'lib' directory.\n\nTry removing the import, or moving the imported file inside the 'lib' directory."
    },
    {
        "key": "file_import_outside_lib_references_file_inside",
        "name": "File import outside lib references file inside",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "A file outside the 'lib' directory shouldn't reference a file inside the 'lib' directory using a relative path.\n\nTry using a package: URI instead."
    },
    {
        "key": "file_names",
        "name": "Name source files using `lowercase_with_underscores`.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> name source files using <code>lowercase_with_underscores</code>.</p>\n<p>Some file systems are not case-sensitive, so many projects require filenames to\nbe all lowercase. Using a separating character allows names to still be readable\nin that form. Using underscores as the separator ensures that the name is still\na valid Dart identifier, which may be helpful if the language later supports\nsymbolic imports.</p>\n<p><strong>GOOD:</strong></p>\n<ul>\n<li><code>slider_menu.dart</code></li>\n<li><code>file_system.dart</code></li>\n</ul>\n<p><strong>BAD:</strong></p>\n<ul>\n<li><code>SliderMenu.dart</code></li>\n<li><code>filesystem.dart</code></li>\n<li><code>file-system.dart</code></li>\n</ul>\n<p>Files without a strict <code>.dart</code> extension are ignored.  For example:</p>\n<p><strong>OK:</strong></p>\n<ul>\n<li><code>file-system.g.dart</code></li>\n<li><code>SliderMenu.css.dart</code></li>\n</ul>\n<p>The lint <code>library_names</code> can be used to enforce the same kind of naming on the\nlibrary.</p>\n\n@see https://dart-lang.github.io/linter/lints/file_names.html"
    },
    {
        "key": "final_initialized_in_declaration_and_constructor",
        "name": "Final initialized in declaration and constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{0}' is final and was given a value when it was declared, so it can't be set\nto a new value.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a final field is initialized\ntwice: once where it's declared and once by a constructor's parameter.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the field <code>f</code> is\ninitialized twice:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int f = 0;</p>\n<p>C(this.[!f!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the field should have the same value for all instances, then remove the\ninitialization in the parameter list:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int f = 0;</p>\n<p>C();\n}\n{% endprettify %}</p>\n<p>If the field can have different values in different instances, then remove\nthe initialization in the declaration:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int f;</p>\n<p>C(this.f);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#final_initialized_in_declaration_and_constructor"
    },
    {
        "key": "final_initialized_multiple_times",
        "name": "Final initialized multiple times",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' is a final field and so can only be set once.\n\nTry removing all but one of the initializations."
    },
    {
        "key": "final_not_initialized",
        "name": "Final not initialized",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The final variable '{0}' must be initialized.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a final field or variable isn't\ninitialized.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> doesn't have an\ninitializer:</p>\n<p>{% prettify dart tag=pre+code %}\nfinal [!x!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>For variables and static fields, you can add an initializer:</p>\n<p>{% prettify dart tag=pre+code %}\nfinal x = 0;\n{% endprettify %}</p>\n<p>For instance fields, you can add an initializer as shown in the previous\nexample, or you can initialize the field in every constructor. You can\ninitialize the field by using a field formal parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int x;\nC(this.x);\n}\n{% endprettify %}</p>\n<p>You can also initialize the field by using an initializer in the\nconstructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal int x;\nC(int y) : x = y * 2;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#final_not_initialized"
    },
    {
        "key": "final_not_initialized_constructor",
        "name": "Final not initialized constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>All final variables must be initialized, but '{0}' and '{1}' aren't.</em></p>\n<p><em>All final variables must be initialized, but '{0}' isn't.</em></p>\n<p><em>All final variables must be initialized, but '{0}', '{1}', and {2} others\naren't.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class defines one or more\nfinal instance fields without initializers and has at least one constructor\nthat doesn't initialize those fields. All final instance fields must be\ninitialized when the instance is created, either by the field's initializer\nor by the constructor.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String value;</p>\n<p><a href=\"\">!C!</a>;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the value should be passed in to the constructor directly, then use a\nfield formal parameter to initialize the field <code>value</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String value;</p>\n<p>C(this.value);\n}\n{% endprettify %}</p>\n<p>If the value should be computed indirectly from a value provided by the\ncaller, then add a parameter and include an initializer:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String value;</p>\n<p>C(Object o) : value = o.toString();\n}\n{% endprettify %}</p>\n<p>If the value of the field doesn't depend on values that can be passed to\nthe constructor, then add an initializer for the field as part of the field\ndeclaration:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String value = '';</p>\n<p>C();\n}\n{% endprettify %}</p>\n<p>If the value of the field doesn't depend on values that can be passed to\nthe constructor but different constructors need to initialize it to\ndifferent values, then add an initializer for the field in the initializer\nlist:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfinal String value;</p>\n<p>C() : value = '';</p>\n<p>C.named() : value = 'c';\n}\n{% endprettify %}</p>\n<p>However, if the value is the same for all instances, then consider using a\nstatic field instead of an instance field:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic const String value = '';</p>\n<p>C();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#final_not_initialized_constructor"
    },
    {
        "key": "flutter_style_todos",
        "name": "Use Flutter TODO format: // TODO(username): message, https://URL-to-issue.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> Use Flutter TODO format.</p>\n<p>From the <a href=\"https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#comments\">Flutter docs</a>:</p>\n<blockquote>\n<p>TODOs should include the string TODO in all caps, followed by the GitHub username of the person with the best context about the problem referenced by the TODO in parenthesis. A TODO is not a commitment that the person referenced will fix the problem, it is intended to be the person with enough context to explain the problem. Thus, when you create a TODO, it is almost always your username that is given.</p>\n</blockquote>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">// TODO(username): message.\n// TODO(username): message, https://URL-to-issue.\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/flutter_style_todos.html"
    },
    {
        "key": "for_in_of_invalid_element_type",
        "name": "For in of invalid element type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The type '{0}' used in the 'for' loop must implement '{1}' with a type argument\nthat can be assigned to '{2}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the <code>Iterable</code> or <code>Stream</code> in a\nfor-in loop has an element type that can't be assigned to the loop\nvariable.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>&lt;String&gt;[]</code> has an\nelement type of <code>String</code>, and <code>String</code> can't be assigned to the type of <code>e</code>\n(<code>int</code>):</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nfor (int e in [!<String>[]!]) {\nprint(e);\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type of the loop variable is correct, then update the type of the\niterable:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nfor (int e in <int>[]) {\nprint(e);\n}\n}\n{% endprettify %}</p>\n<p>If the type of the iterable is correct, then update the type of the loop\nvariable:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nfor (String e in <String>[]) {\nprint(e);\n}\n}\n{% endprettify %}</p>"
    },
    {
        "key": "for_in_of_invalid_type",
        "name": "For in of invalid type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The type '{0}' used in the 'for' loop must implement {1}.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the expression following <code>in</code> in\na for-in loop has a type that isn't a subclass of <code>Iterable</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>m</code> is a <code>Map</code>, and\n<code>Map</code> isn't a subclass of <code>Iterable</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Map&lt;String, String&gt; m) {\nfor (String s in [!m!]) {\nprint(s);\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the expression with one that produces an iterable value:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Map&lt;String, String&gt; m) {\nfor (String s in m.values) {\nprint(s);\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#for_in_of_invalid_type"
    },
    {
        "key": "for_in_with_const_variable",
        "name": "For in with const variable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A for-in loop variable can't be a 'const'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the loop variable declared in a\nfor-in loop is declared to be a <code>const</code>. The variable can't be a <code>const</code>\nbecause the value can't be computed at compile time.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the loop variable <code>x</code>\nis declared to be a <code>const</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nfor ([!const!] x in [0, 1, 2]) {\nprint(x);\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If there's a type annotation, then remove the <code>const</code> modifier from the\ndeclaration.</p>\n<p>If there's no type, then replace the <code>const</code> modifier with <code>final</code>, <code>var</code>,\nor a type annotation:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nfor (final x in [0, 1, 2]) {\nprint(x);\n}\n}\n{% endprettify %}</p>"
    },
    {
        "key": "generic_function_type_cannot_be_bound",
        "name": "Generic function type cannot be bound",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Generic function types can't be used as type parameter bounds\n\nTry making the free variable in the function type part of the larger declaration signature"
    },
    {
        "key": "generic_function_type_cannot_be_type_argument",
        "name": "Generic function type cannot be type argument",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "A generic function type can't be a type argument.\n\nTry removing type parameters from the generic function type, or using 'dynamic' as the type argument here."
    },
    {
        "key": "getter_not_assignable_setter_types",
        "name": "Getter not assignable setter types",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The return type of getter '{0}' is '{1}' which isn't assignable to the type '{2}' of its setter '{3}'.\n\nTry changing the types so that they are compatible."
    },
    {
        "key": "getter_not_subtype_setter_types",
        "name": "Getter not subtype setter types",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The return type of getter '{0}' is '{1}' which isn't a subtype of the type\n'{2}' of its setter '{3}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the return type of a getter\nisn't a subtype of the type of the parameter of a setter with the same\nname.</p>\n<p>The subtype relationship is a requirement whether the getter and setter are\nin the same class or whether one of them is in a superclass of the other.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the return type of the\ngetter <code>x</code> is <code>num</code>, the parameter type of the setter <code>x</code> is <code>int</code>, and\n<code>num</code> isn't a subtype of <code>int</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nnum get [!x!] =&gt; 0;</p>\n<p>set x(int y) {}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type of the getter is correct, then change the type of the setter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nnum get x =&gt; 0;</p>\n<p>set x(num y) {}\n}\n{% endprettify %}</p>\n<p>If the type of the setter is correct, then change the type of the getter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint get x =&gt; 0;</p>\n<p>set x(int y) {}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#getter_not_subtype_setter_types"
    },
    {
        "key": "hash_and_equals",
        "name": "Always override `hashCode` if overriding `==`.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DO</strong> override <code>hashCode</code> if overriding <code>==</code> and prefer overriding <code>==</code> if\noverriding <code>hashCode</code>.</p>\n<p>Every object in Dart has a <code>hashCode</code>.  Both the <code>==</code> operator and the\n<code>hashCode</code> property of objects must be consistent in order for a common hash\nmap implementation to function properly.  Thus, when overriding <code>==</code>, the\n<code>hashCode</code> should also be overridden to maintain consistency. Similarly, if\n<code>hashCode</code> is overridden, <code>==</code> should be also.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Bad {\n  final int value;\n  Bad(this.value);\n\n  @override\n  bool operator ==(Object other) =&gt; other is Bad &amp;&amp; other.value == value;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Better {\n  final int value;\n  Better(this.value);\n\n  @override\n  bool operator ==(Object other) =&gt; other is Better &amp;&amp; other.value == value;\n\n  @override\n  int get hashCode =&gt; value.hashCode;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/hash_and_equals.html"
    },
    {
        "key": "if_element_condition_from_deferred_library",
        "name": "If element condition from deferred library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Constant values from a deferred library can't be used as values in an if condition inside a const collection literal.\n\nTry making the deferred import non-deferred."
    },
    {
        "key": "illegal_async_generator_return_type",
        "name": "Illegal async generator return type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Functions marked 'async*' must have a return type that is a supertype of\n'Stream<T>' for some type 'T'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the body of a function has the\n<code>async*</code> modifier even though the return type of the function isn't either\n<code>Stream</code> or a supertype of <code>Stream</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the body of the\nfunction <code>f</code> has the 'async*' modifier even though the return type <code>int</code>\nisn't a supertype of <code>Stream</code>:</p>\n<p>{% prettify dart tag=pre+code %}\n[!int!] f() async* {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the function should be asynchronous, then change the return type to be\neither <code>Stream</code> or a supertype of <code>Stream</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nStream<int> f() async* {}\n{% endprettify %}</p>\n<p>If the function should be synchronous, then remove the <code>async*</code> modifier:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() =&gt; 0;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#illegal_async_generator_return_type"
    },
    {
        "key": "illegal_async_return_type",
        "name": "Illegal async return type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Functions marked 'async' must have a return type assignable to 'Future'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the body of a function has the\n<code>async</code> modifier even though the return type of the function isn't\nassignable to <code>Future</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the body of the\nfunction <code>f</code> has the <code>async</code> modifier even though the return type isn't\nassignable to <code>Future</code>:</p>\n<p>{% prettify dart tag=pre+code %}\n[!int!] f() async {\nreturn 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the function should be asynchronous, then change the return type to be\nassignable to <code>Future</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nFuture<int> f() async {\nreturn 0;\n}\n{% endprettify %}</p>\n<p>If the function should be synchronous, then remove the <code>async</code> modifier:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() =&gt; 0;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#illegal_async_return_type"
    },
    {
        "key": "illegal_sync_generator_return_type",
        "name": "Illegal sync generator return type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Functions marked 'sync*' must have a return type that is a supertype of\n'Iterable<T>' for some type 'T'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the body of a function has the\n<code>sync*</code> modifier even though the return type of the function isn't either\n<code>Iterable</code> or a supertype of <code>Iterable</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the body of the\nfunction <code>f</code> has the 'sync*' modifier even though the return type <code>int</code>\nisn't a supertype of <code>Iterable</code>:</p>\n<p>{% prettify dart tag=pre+code %}\n[!int!] f() sync* {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the function should return an iterable, then change the return type to\nbe either <code>Iterable</code> or a supertype of <code>Iterable</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nIterable<int> f() sync* {}\n{% endprettify %}</p>\n<p>If the function should return a single value, then remove the <code>sync*</code>\nmodifier:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() =&gt; 0;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#illegal_sync_generator_return_type"
    },
    {
        "key": "implementation_imports",
        "name": "Don't import implementation files from another package.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the the <a href=\"https://dart.dev/tools/pub/package-layout#implementation-files\">pub package layout doc</a>:</p>\n<p><strong>DON'T</strong> import implementation files from another package.</p>\n<p>The libraries inside <code>lib</code> are publicly visible: other packages are free to\nimport them.  But much of a package's code is internal implementation libraries\nthat should only be imported and used by the package itself.  Those go inside a\nsubdirectory of <code>lib</code> called <code>src</code>.  You can create subdirectories in there if\nit helps you organize things.</p>\n<p>You are free to import libraries that live in <code>lib/src</code> from within other Dart\ncode in the same package (like other libraries in <code>lib</code>, scripts in <code>bin</code>,\nand tests) but you should never import from another package's <code>lib/src</code>\ndirectory.  Those files are not part of the package's public API, and they\nmight change in ways that could break your code.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">// In 'road_runner'\nimport 'package:acme/lib/src/internals.dart;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/implementation_imports.html"
    },
    {
        "key": "implements_non_class",
        "name": "Implements non class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Classes and mixins can only implement other classes and mixins.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a name used in the <code>implements</code>\nclause of a class or mixin declaration is defined to be something other\nthan a class or mixin.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> is a variable\nrather than a class or mixin:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x;\nclass C implements [!x!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the name is the name of an existing class or mixin that's already being\nimported, then add a prefix to the import so that the local definition of\nthe name doesn't shadow the imported name.</p>\n<p>If the name is the name of an existing class or mixin that isn't being\nimported, then add an import, with a prefix, for the library in which itâ€™s\ndeclared.</p>\n<p>Otherwise, either replace the name in the <code>implements</code> clause with the name\nof an existing class or mixin, or remove the name from the <code>implements</code>\nclause.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#implements_non_class"
    },
    {
        "key": "implements_repeated",
        "name": "Implements repeated",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{0}' can only be implemented once.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a single class is specified more\nthan once in an <code>implements</code> clause.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>A</code> is in the list\ntwice:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}\nclass B implements A, [!A!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove all except one occurrence of the class name:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}\nclass B implements A {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#implements_repeated"
    },
    {
        "key": "implements_super_class",
        "name": "Implements super class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{0}' can't be used in both the 'extends' and 'implements' clauses.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when one class is listed in both the\n<code>extends</code> and <code>implements</code> clauses of another class.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the class <code>A</code> is used\nin both the <code>extends</code> and <code>implements</code> clauses for the class <code>B</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}</p>\n<p>class B extends A implements [!A!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you want to inherit the implementation from the class, then remove the\nclass from the <code>implements</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}</p>\n<p>class B extends A {}\n{% endprettify %}</p>\n<p>If you don't want to inherit the implementation from the class, then remove\nthe <code>extends</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}</p>\n<p>class B implements A {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#implements_super_class"
    },
    {
        "key": "implements_type_alias_expands_to_type_parameter",
        "name": "Implements type alias expands to type parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Type aliases that expand to a type parameter can't be implemented.\n\nTry specifying a class or mixin, or removing the list."
    },
    {
        "key": "implicit_this_reference_in_initializer",
        "name": "Implicit this reference in initializer",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The instance member '{0}' can't be accessed in an initializer.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds a reference to an\ninstance member in a constructor's initializer list.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>defaultX</code> is an\ninstance member:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>C() : x = [!defaultX!];</p>\n<p>int get defaultX =&gt; 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the member can be made static, then do so:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>C() : x = defaultX;</p>\n<p>static int get defaultX =&gt; 0;\n}\n{% endprettify %}</p>\n<p>If not, then replace the reference in the initializer with a different\nexpression that doesn't use an instance member:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>C() : x = 0;</p>\n<p>int get defaultX =&gt; 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#implicit_this_reference_in_initializer"
    },
    {
        "key": "import_deferred_library_with_load_function",
        "name": "Import deferred library with load function",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The library '{0}' defines a top-level function named 'loadLibrary' which is hidden by deferring this library.\n\nTry changing the import to not be deferred, or rename the function in the imported library."
    },
    {
        "key": "import_internal_library",
        "name": "Import internal library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The library '{0}' is internal and can't be imported.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds an import whose <code>dart:</code>\nURI references an internal library.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>_interceptors</code> is an\ninternal library:</p>\n<p>{% prettify dart tag=pre+code %}\nimport [!'dart:_interceptors'!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the import directive.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#import_internal_library"
    },
    {
        "key": "import_of_legacy_library_into_null_safe",
        "name": "Import of legacy library into null safe",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The library '{0}' is legacy, and should not be imported into a null safe library.\n\nTry migrating the imported library."
    },
    {
        "key": "import_of_non_library",
        "name": "Import of non library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The imported library '{0}' can't have a part-of directive.\n\nTry importing the library that the part is a part of."
    },
    {
        "key": "inconsistent_case_expression_types",
        "name": "Inconsistent case expression types",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Case expressions must have the same types, '{0}' isn't a '{1}'.\n\nnull"
    },
    {
        "key": "inconsistent_inheritance",
        "name": "Inconsistent inheritance",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Superinterfaces don't have a valid override for '{0}': {1}.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class inherits two or more\nconflicting signatures for a member and doesn't provide an implementation\nthat satisfies all the inherited signatures.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>C</code> is inheriting the\ndeclaration of <code>m</code> from <code>A</code>, and that implementation isn't consistent with\nthe signature of <code>m</code> that's inherited from <code>B</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nvoid m({int a}) {}\n}</p>\n<p>class B {\nvoid m({int b}) {}\n}</p>\n<p>class [!C!] extends A implements B {\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add an implementation of the method that satisfies all the inherited\nsignatures:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nvoid m({int a}) {}\n}</p>\n<p>class B {\nvoid m({int b}) {}\n}</p>\n<p>class C extends A implements B {\nvoid m({int a, int b}) {}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#inconsistent_inheritance"
    },
    {
        "key": "inconsistent_inheritance_getter_and_method",
        "name": "Inconsistent inheritance getter and method",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' is inherited as a getter (from '{1}') and also a method (from '{2}').\n\nTry adjusting the supertypes of this class to remove the inconsistency."
    },
    {
        "key": "inconsistent_language_version_override",
        "name": "Inconsistent language version override",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Parts must have exactly the same language version override as the library.\n\nnull"
    },
    {
        "key": "inference_failure_on_collection_literal",
        "name": "Inference failure on collection literal",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The type argument(s) of '{0}' can't be inferred.\n\nUse explicit type argument(s) for '{0}'."
    },
    {
        "key": "inference_failure_on_function_return_type",
        "name": "Inference failure on function return type",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The return type of '{0}' cannot be inferred.\n\nDeclare the return type of '{0}'."
    },
    {
        "key": "inference_failure_on_instance_creation",
        "name": "Inference failure on instance creation",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The type argument(s) of the constructor '{0}' can't be inferred.\n\nUse explicit type argument(s) for '{0}'."
    },
    {
        "key": "inference_failure_on_uninitialized_variable",
        "name": "Inference failure on uninitialized variable",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The type of {0} can't be inferred without either a type or initializer.\n\nTry specifying the type of the variable."
    },
    {
        "key": "inference_failure_on_untyped_parameter",
        "name": "Inference failure on untyped parameter",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The type of {0} can't be inferred; a type must be explicitly provided.\n\nTry specifying the type of the parameter."
    },
    {
        "key": "initializer_for_non_existent_field",
        "name": "Initializer for non existent field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{0}' isn't a field in the enclosing class.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constructor initializes a\nfield that isn't declared in the class containing the constructor.\nConstructors can't initialize fields that aren't declared and fields that\nare inherited from superclasses.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the initializer is\ninitializing <code>x</code>, but <code>x</code> isn't a field in the class:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint y;</p>\n<p>C() : [!x = 0!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If a different field should be initialized, then change the name to the\nname of the field:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint y;</p>\n<p>C() : y = 0;\n}\n{% endprettify %}</p>\n<p>If the field must be declared, then add a declaration:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;\nint y;</p>\n<p>C() : x = 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#initializer_for_non_existent_field"
    },
    {
        "key": "initializer_for_static_field",
        "name": "Initializer for static field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' is a static field in the enclosing class. Fields initialized in a constructor can't be static.\n\nTry removing the initialization."
    },
    {
        "key": "initializing_formal_for_non_existent_field",
        "name": "Initializing formal for non existent field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{0}' isn't a field in the enclosing class.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a field formal parameter is\nfound in a constructor in a class that doesn't declare the field being\ninitialized. Constructors can't initialize fields that aren't declared and\nfields that are inherited from superclasses.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the field <code>x</code> isn't\ndefined:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint y;</p>\n<p>C([!this.x!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the field name was wrong, then change it to the name of an existing\nfield:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint y;</p>\n<p>C(this.y);\n}\n{% endprettify %}</p>\n<p>If the field name is correct but hasn't yet been defined, then declare the\nfield:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;\nint y;</p>\n<p>C(this.x);\n}\n{% endprettify %}</p>\n<p>If the parameter is needed but shouldn't initialize a field, then convert\nit to a normal parameter and use it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint y;</p>\n<p>C(int x) : y = x * 2;\n}\n{% endprettify %}</p>\n<p>If the parameter isn't needed, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint y;</p>\n<p>C();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#initializing_formal_for_non_existent_field"
    },
    {
        "key": "initializing_formal_for_static_field",
        "name": "Initializing formal for static field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' is a static field in the enclosing class. Fields initialized in a constructor can't be static.\n\nTry removing the initialization."
    },
    {
        "key": "instance_access_to_static_member",
        "name": "Instance access to static member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Static {1} '{0}' can't be accessed through an instance.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an access operator is used to\naccess a static member through an instance of the class.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>zero</code> is a static\nfield, but itâ€™s being accessed as if it were an instance field:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(C c) {\nc.[!zero!];\n}</p>\n<p>class C {\nstatic int zero = 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Use the class to access the static member:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(C c) {\nC.zero;\n}</p>\n<p>class C {\nstatic int zero = 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#instance_access_to_static_member"
    },
    {
        "key": "instance_member_access_from_factory",
        "name": "Instance member access from factory",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Instance members can't be accessed from a factory constructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a factory constructor contains\nan unqualified reference to an instance member. In a generative\nconstructor, the instance of the class is created and initialized before\nthe body of the constructor is executed, so the instance can be bound to\n<code>this</code> and accessed just like it would be in an instance method. But, in a\nfactory constructor, the instance isn't created before executing the body,\nso <code>this</code> can't be used to reference it.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> isn't in scope in\nthe factory constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;\nfactory C() {\nreturn C.<em>([!x!]);\n  }\n  C.</em>(this.x);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Rewrite the code so that it doesn't reference the instance member:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;\nfactory C() {\nreturn C.<em>(0);\n  }\n  C.</em>(this.x);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#instance_member_access_from_factory"
    },
    {
        "key": "instance_member_access_from_static",
        "name": "Instance member access from static",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Instance members can't be accessed from a static method.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a static method contains an\nunqualified reference to an instance member.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the instance field <code>x</code>\nis being referenced in a static method:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>static int m() {\nreturn [!x!];\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the method must reference the instance member, then it can't be static,\nso remove the keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>int m() {\nreturn x;\n}\n}\n{% endprettify %}</p>\n<p>If the method can't be made an instance method, then add a parameter so\nthat an instance of the class can be passed in:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>static int m(C c) {\nreturn c.x;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#instance_member_access_from_static"
    },
    {
        "key": "instantiate_abstract_class",
        "name": "Instantiate abstract class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Abstract classes can't be instantiated.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds a constructor\ninvocation and the constructor is declared in an abstract class. Even\nthough you can't create an instance of an abstract class, abstract classes\ncan declare constructors that can be invoked by subclasses.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>C</code> is an abstract\nclass:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class C {}</p>\n<p>var c = new <a href=\"\">!C!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If there's a concrete subclass of the abstract class that can be used, then\ncreate an instance of the concrete subclass.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#instantiate_abstract_class"
    },
    {
        "key": "instantiate_enum",
        "name": "Instantiate enum",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Enums can't be instantiated.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an enum is instantiated. It's\ninvalid to create an instance of an enum by invoking a constructor; only\nthe instances named in the declaration of the enum can exist.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the enum <code>E</code> is being\ninstantiated:</p>\n<p>{% prettify dart tag=pre+code %}\nenum E {a}</p>\n<p>var e = <a href=\"\">!E!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you intend to use an instance of the enum, then reference one of the\nconstants defined in the enum:</p>\n<p>{% prettify dart tag=pre+code %}\nenum E {a}</p>\n<p>var e = E.a;\n{% endprettify %}</p>\n<p>If you intend to use an instance of a class, then use the name of that class in place of the name of the enum.</p>"
    },
    {
        "key": "instantiate_type_alias_expands_to_type_parameter",
        "name": "Instantiate type alias expands to type parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Type aliases that expand to a type parameter can't be instantiated.\n\nTry replacing it with a class."
    },
    {
        "key": "integer_literal_imprecise_as_double",
        "name": "Integer literal imprecise as double",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The integer literal is being used as a double, but can't be represented as a 64 bit double without overflow and/or loss of precision: {0}\n\nTry using the BigInt class, or switch to the closest valid double: {1}"
    },
    {
        "key": "integer_literal_out_of_range",
        "name": "Integer literal out of range",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The integer literal {0} can't be represented in 64 bits.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an integer literal has a value\nthat is too large (positive) or too small (negative) to be represented in a\n64-bit word.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the value can't be\nrepresented in 64 bits:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x = [!9223372036854775810!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to represent the current value, then wrap it in an instance of\nthe class <code>BigInt</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x = BigInt.parse('9223372036854775810');\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#integer_literal_out_of_range"
    },
    {
        "key": "invalid_annotation",
        "name": "Invalid annotation",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Annotation must be either a const variable reference or const constructor\ninvocation.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an annotation is found that is\nusing something that is neither a variable marked as <code>const</code> or the\ninvocation of a <code>const</code> constructor.</p>\n<p>Getters can't be used as annotations.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the variable <code>v</code> isn't\na <code>const</code> variable:</p>\n<p>{% prettify dart tag=pre+code %}\nvar v = 0;</p>\n<p>[!@v!]\nvoid f() {\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>f</code> isn't a variable:</p>\n<p>{% prettify dart tag=pre+code %}\n[!@f!]\nvoid f() {\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>f</code> isn't a\nconstructor:</p>\n<p>{% prettify dart tag=pre+code %}\n[!@f()!]\nvoid f() {\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>g</code> is a getter:</p>\n<p>{% prettify dart tag=pre+code %}\n[!@g!]\nint get g =&gt; 0;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the annotation is referencing a variable that isn't a <code>const</code>\nconstructor, add the keyword <code>const</code> to the variable's declaration:</p>\n<p>{% prettify dart tag=pre+code %}\nconst v = 0;</p>\n<p>@v\nvoid f() {\n}\n{% endprettify %}</p>\n<p>If the annotation isn't referencing a variable, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nint v = 0;</p>\n<p>void f() {\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_annotation"
    },
    {
        "key": "invalid_annotation_from_deferred_library",
        "name": "Invalid annotation from deferred library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Constant values from a deferred library can't be used as annotations.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constant from a library that\nis imported using a deferred import is used as an annotation. Annotations\nare evaluated at compile time, and constants from deferred libraries aren't\navailable at compile time.</p>\n<p>For more information, see the language tour's coverage of\n<a href=\"https://dart.dev/guides/language/language-tour#lazily-loading-a-library\">deferred loading</a>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the constant <code>pi</code> is\nbeing used as an annotation when the library <code>dart:math</code> is imported as\n<code>deferred</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' deferred as math;</p>\n<p>@[!math.pi!]\nvoid f() {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to reference the constant as an annotation, then remove the\nkeyword <code>deferred</code> from the import:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' as math;</p>\n<p>@math.pi\nvoid f() {}\n{% endprettify %}</p>\n<p>If you can use a different constant as an annotation, then replace the\nannotation with a different constant:</p>\n<p>{% prettify dart tag=pre+code %}\n@deprecated\nvoid f() {}\n{% endprettify %}</p>"
    },
    {
        "key": "invalid_annotation_target",
        "name": "Invalid annotation target",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The annotation '{0}' can only be used on {1}\n\nnull"
    },
    {
        "key": "invalid_assignment",
        "name": "Invalid assignment",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A value of type '{0}' can't be assigned to a variable of type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the static type of an expression\nthat is assigned to a variable isn't assignable to the type of the\nvariable.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the type of the\ninitializer (<code>int</code>) isn't assignable to the type of the variable\n(<code>String</code>):</p>\n<p>{% prettify dart tag=pre+code %}\nint i = 0;\nString s = [!i!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the value being assigned is always assignable at runtime, even though\nthe static types don't reflect that, then add an explicit cast.</p>\n<p>Otherwise, change the value being assigned so that it has the expected\ntype. In the previous example, this might look like:</p>\n<p>{% prettify dart tag=pre+code %}\nint i = 0;\nString s = i.toString();\n{% endprettify %}</p>\n<p>If you canâ€™t change the value, then change the type of the variable to be\ncompatible with the type of the value being assigned:</p>\n<p>{% prettify dart tag=pre+code %}\nint i = 0;\nint s = i;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_assignment"
    },
    {
        "key": "invalid_cast_function",
        "name": "Invalid cast function",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The function '{0}' has type '{1}' that isn't of expected type '{2}'. This means its parameter or return type doesn't match what is expected.\n\nnull"
    },
    {
        "key": "invalid_cast_function_expr",
        "name": "Invalid cast function expr",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The function expression type '{0}' isn't of type '{1}'. This means its parameter or return type doesn't match what is expected. Consider changing parameter type(s) or the returned type(s).\n\nnull"
    },
    {
        "key": "invalid_cast_literal",
        "name": "Invalid cast literal",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The literal '{0}' with type '{1}' isn't of expected type '{2}'.\n\nnull"
    },
    {
        "key": "invalid_cast_literal_list",
        "name": "Invalid cast literal list",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The list literal type '{0}' isn't of expected type '{1}'. The list's type can be changed with an explicit generic type argument or by changing the element types.\n\nnull"
    },
    {
        "key": "invalid_cast_literal_map",
        "name": "Invalid cast literal map",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The map literal type '{0}' isn't of expected type '{1}'. The maps's type can be changed with an explicit generic type arguments or by changing the key and value types.\n\nnull"
    },
    {
        "key": "invalid_cast_literal_set",
        "name": "Invalid cast literal set",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The set literal type '{0}' isn't of expected type '{1}'. The set's type can be changed with an explicit generic type argument or by changing the element types.\n\nnull"
    },
    {
        "key": "invalid_cast_method",
        "name": "Invalid cast method",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The method tear-off '{0}' has type '{1}' that isn't of expected type '{2}'. This means its parameter or return type doesn't match what is expected.\n\nnull"
    },
    {
        "key": "invalid_cast_new_expr",
        "name": "Invalid cast new expr",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The constructor returns type '{0}' that isn't of expected type '{1}'.\n\nnull"
    },
    {
        "key": "invalid_constant",
        "name": "Invalid constant",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Invalid constant value.\n\nnull"
    },
    {
        "key": "invalid_constructor_name",
        "name": "Invalid constructor name",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Invalid constructor name.\n\nnull"
    },
    {
        "key": "invalid_dependency",
        "name": "Invalid dependency",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Publishable packages can't have {0} dependencies.\n\nTry adding a 'publish_to: none' entry to mark the package as not for publishing or remove the {0} dependency."
    },
    {
        "key": "invalid_export_of_internal_element",
        "name": "Invalid export of internal element",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The member '{0}' can't be exported as a part of a package's public API.\n\nTry using a hide clause to hide '{0}'."
    },
    {
        "key": "invalid_export_of_internal_element_indirectly",
        "name": "Invalid export of internal element indirectly",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The member '{0}' can't be exported as a part of a package's public API, but is indirectly exported as part of the signature of '{1}'.\n\nTry using a hide clause to hide '{0}'."
    },
    {
        "key": "invalid_extension_argument_count",
        "name": "Invalid extension argument count",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Extension overrides must have exactly one argument: the value of 'this' in the\nextension method.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension override doesn't\nhave exactly one argument. The argument is the expression used to compute\nthe value of <code>this</code> within the extension method, so there must be one\nargument.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because there are no arguments:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString join(String other) =&gt; '$this $other';\n}</p>\n<p>void f() {\nE[!()!].join('b');\n}\n{% endprettify %}</p>\n<p>And, the following code produces this diagnostic because there's more than\none argument:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString join(String other) =&gt; '$this $other';\n}</p>\n<p>void f() {\nE[!('a', 'b')!].join('c');\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Provide one argument for the extension override:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString join(String other) =&gt; '$this $other';\n}</p>\n<p>void f() {\nE('a').join('b');\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_extension_argument_count"
    },
    {
        "key": "invalid_factory_annotation",
        "name": "Invalid factory annotation",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Only methods can be annotated as factories.\n\nnull"
    },
    {
        "key": "invalid_factory_method_decl",
        "name": "Invalid factory method decl",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Factory method '{0}' must have a return type.\n\nnull"
    },
    {
        "key": "invalid_factory_method_impl",
        "name": "Invalid factory method impl",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Factory method '{0}' doesn't return a newly allocated object.\n\nnull"
    },
    {
        "key": "invalid_factory_name_not_a_class",
        "name": "Invalid factory name not a class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name of a factory constructor must be the same as the name of the\nimmediately enclosing class.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the name of a factory\nconstructor isn't the same as the name of the surrounding class.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the name of the factory\nconstructor (<code>A</code>) isn't the same as the surrounding class (<code>C</code>):</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}</p>\n<p>class C {\nfactory <a href=\"\">!A!</a> =&gt; throw 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the factory returns an instance of the surrounding class, then rename\nthe factory:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}</p>\n<p>class C {\nfactory C() =&gt; throw 0;\n}\n{% endprettify %}</p>\n<p>If the factory returns an instance of a different class, then move the\nfactory to that class:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nfactory A() =&gt; throw 0;\n}</p>\n<p>class C {}\n{% endprettify %}</p>\n<p>If the factory returns an instance of a different class, but you can't\nmodify that class or don't want to move the factory, then convert it to be\na static method:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}</p>\n<p>class C {\nstatic A a() =&gt; throw 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_factory_name_not_a_class"
    },
    {
        "key": "invalid_immutable_annotation",
        "name": "Invalid immutable annotation",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Only classes can be annotated as being immutable.\n\nnull"
    },
    {
        "key": "invalid_implementation_override",
        "name": "Invalid implementation override",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{1}.{0}' ('{2}') isn't a valid concrete implementation of '{3}.{0}' ('{4}').</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when all of the following are true:</p>\n<ul>\n<li>A class defines an abstract member.</li>\n<li>There is a concrete implementation of that member in a superclass.</li>\n<li>The concrete implementation isn't a valid implementation of the abstract\nmethod.</li>\n</ul>\n<p>The concrete implementation can be invalid because of incompatibilities in\neither the return type, the types of parameters, or the type variables.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the method <code>A.add</code> has\na parameter of type <code>int</code>, and the overriding method <code>B.add</code> has a\ncorresponding parameter of type <code>num</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nint add(int a) =&gt; a;\n}\nclass [!B!] extends A {\nint add(num a);\n}\n{% endprettify %}</p>\n<p>This is a problem because in an invocation of <code>B.add</code> like the following:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(B b) {\nb.add(3.4);\n}\n{% endprettify %}</p>\n<p><code>B.add</code> is expecting to be able to take, for example, a <code>double</code>, but when\nthe method <code>A.add</code> is executed (because it's the only concrete\nimplementation of <code>add</code>), a runtime exception will be thrown because a\n<code>double</code> can't be assigned to a parameter of type <code>int</code>.</p>\n<h4>Common fixes</h4>\n<p>If the method in the subclass can conform to the implementation in the\nsuperclass, then change the declaration in the subclass (or remove it if\nit's the same):</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nint add(int a) =&gt; a;\n}\nclass B\textends A {\nint add(int a);\n}\n{% endprettify %}</p>\n<p>If the method in the superclass can be generalized to be a valid\nimplementation of the method in the subclass, then change the superclass\nmethod:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nint add(num a) =&gt; a.floor();\n}\nclass B\textends A {\nint add(num a);\n}\n{% endprettify %}</p>\n<p>If neither the method in the superclass nor the method in the subclass can\nbe changed, then provide a concrete implementation of the method in the\nsubclass:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nint add(int a) =&gt; a;\n}\nclass B\textends A {\nint add(num a) =&gt; a.floor();\n}\n{% endprettify %}</p>"
    },
    {
        "key": "invalid_inline_function_type",
        "name": "Invalid inline function type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Inline function types can't be used for parameters in a generic function type.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a generic function type has a\nfunction-valued parameter that is written using the older inline function\ntype syntax.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the parameter <code>f</code>, in\nthe generic function type used to define <code>F</code>, uses the inline function\ntype syntax:</p>\n<p>{% prettify dart tag=pre+code %}\ntypedef F = int Function(int f[!(!]String s));\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Use the generic function syntax for the parameter's type:</p>\n<p>{% prettify dart tag=pre+code %}\ntypedef F = int Function(int Function(String));\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_inline_function_type"
    },
    {
        "key": "invalid_internal_annotation",
        "name": "Invalid internal annotation",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Only public elements in a package's private API can be annotated as being internal.\n\nnull"
    },
    {
        "key": "invalid_language_version_override",
        "name": "Invalid language version override",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The Dart language version override number must begin with '@dart'\n\nSpecify a Dart language version override with a comment like '// @dart = 2.0'."
    },
    {
        "key": "invalid_literal_annotation",
        "name": "Invalid literal annotation",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Only const constructors can have the <code>@literal</code> annotation.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the <code>@literal</code> annotation is\napplied to anything other than a const constructor.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the constructor isn't\na <code>const</code> constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>class C {\n[!@literal!]\nC();\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>x</code> isn't a\nconstructor:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>[!@literal!]\nvar x;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the annotation is on a constructor and the constructor should always be\ninvoked with <code>const</code>, when possible, then mark the constructor with the\n<code>const</code> keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>class C {\n@literal\nconst C();\n}\n{% endprettify %}</p>\n<p>If the constructor can't be marked as <code>const</code>, then remove the annotation.</p>\n<p>If the annotation is on anything other than a constructor, then remove the\nannotation:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_literal_annotation"
    },
    {
        "key": "invalid_modifier_on_constructor",
        "name": "Invalid modifier on constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The modifier '{0}' can't be applied to the body of a constructor.\n\nTry removing the modifier."
    },
    {
        "key": "invalid_modifier_on_setter",
        "name": "Invalid modifier on setter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The modifier '{0}' can't be applied to the body of a setter.\n\nTry removing the modifier."
    },
    {
        "key": "invalid_non_virtual_annotation",
        "name": "Invalid non virtual annotation",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The member '{0}' can't be '@nonVirtual' because it isn't a concrete instance member.\n\nTry removing @nonVirtual."
    },
    {
        "key": "invalid_null_aware_operator",
        "name": "Invalid null aware operator",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The receiver can't be null because of short-circuiting, so the null-aware\noperator '{0}' can't be used.</em></p>\n<p><em>The receiver can't be null, so the null-aware operator '{0}' is unnecessary.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a null-aware operator (<code>?.</code>,\n<code>?..</code>, <code>?[</code>, <code>?..[</code>, or <code>...?</code>) is used on a target that's known to be\nnon-nullable.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>s</code> can't be <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint? getLength(String s) {\nreturn s[!?.!]length;\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>a</code> can't be <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvar a = [];\nvar b = [[!...?!]a];\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>s?.length</code> can't\nreturn <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String? s) {\ns?.length[!?.!]isEven;\n}\n{% endprettify %}</p>\n<p>The reason <code>s?.length</code> can't return <code>null</code> is because the null-aware\noperator following <code>s</code> short-circuits the evaluation of both <code>length</code> and\n<code>isEven</code> if <code>s</code> is <code>null</code>. In other words, if <code>s</code> is <code>null</code>, then neither\n<code>length</code> nor <code>isEven</code> will be invoked, and if <code>s</code> is non-<code>null</code>, then\n<code>length</code> can't return a <code>null</code> value. Either way, <code>isEven</code> can't be invoked\non a <code>null</code> value, so the null-aware operator is not necessary. See\n<a href=\"/null-safety/understanding-null-safety#smarter-null-aware-methods\">Understanding null safety</a>\nfor more details.</p>\n<p>The following code produces this diagnostic because <code>s</code> can't be <code>null</code>.</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Object? o) {\nvar s = o as String;\ns[!?.!]length;\n}\n{% endprettify %}</p>\n<p>The reason <code>s</code> can't be null, despite the fact that <code>o</code> can be <code>null</code>, is\nbecause of the cast to <code>String</code>, which is a non-nullable type. If <code>o</code> ever\nhas the value <code>null</code>, the cast will fail and the invocation of <code>length</code>\nwill not happen.</p>\n<h4>Common fixes</h4>\n<p>Replace the null-aware operator with a non-null-aware equivalent; for\nexample, change <code>?.</code> to  <code>.</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint getLength(String s) {\nreturn s.length;\n}\n{% endprettify %}</p>\n<p>(Note that the return type was also changed to be non-nullable, which might\nnot be appropriate in some cases.)</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_null_aware_operator"
    },
    {
        "key": "invalid_override",
        "name": "Invalid override",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{1}.{0}' ('{2}') isn't a valid override of '{3}.{0}' ('{4}').</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a member of a class is found\nthat overrides a member from a supertype and the override isn't valid. An\noverride is valid if all of these are true:</p>\n<ul>\n<li>It allows all of the arguments allowed by the overridden member.</li>\n<li>It doesn't require any arguments that aren't required by the overridden\nmember.</li>\n<li>The type of every parameter of the overridden member is assignable to the\ncorresponding parameter of the override.</li>\n<li>The return type of the override is assignable to the return type of the\noverridden member.</li>\n</ul>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the type of the\nparameter <code>s</code> (<code>String</code>) isn't assignable to the type of the parameter <code>i</code>\n(<code>int</code>):</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nvoid m(int i) {}\n}</p>\n<p>class B extends A {\nvoid [!m!](String s) {}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the invalid method is intended to override the method from the\nsuperclass, then change it to conform:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nvoid m(int i) {}\n}</p>\n<p>class B extends A {\nvoid m(int i) {}\n}\n{% endprettify %}</p>\n<p>If it isn't intended to override the method from the superclass, then\nrename it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nvoid m(int i) {}\n}</p>\n<p>class B extends A {\nvoid m2(String s) {}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_override"
    },
    {
        "key": "invalid_override_different_default_values_named",
        "name": "Invalid override different default values named",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Parameters can't override default values, this method overrides '{0}.{1}' where '{2}' has a different value.\n\nTry using the same default value in both methods."
    },
    {
        "key": "invalid_override_different_default_values_positional",
        "name": "Invalid override different default values positional",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Parameters can't override default values, this method overrides '{0}.{1}' where this positional parameter has a different value.\n\nTry using the same default value in both methods."
    },
    {
        "key": "invalid_override_of_non_virtual_member",
        "name": "Invalid override of non virtual member",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The member '{0}' is declared non-virtual in '{1}' and can't be overridden in subclasses.\n\nnull"
    },
    {
        "key": "invalid_reference_to_this",
        "name": "Invalid reference to this",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Invalid reference to 'this' expression.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when <code>this</code> is used outside of an\ninstance method or a generative constructor. The reserved word <code>this</code> is\nonly defined in the context of an instance method or a generative\nconstructor.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>v</code> is a top-level\nvariable:</p>\n<p>{% prettify dart tag=pre+code %}\nC f() =&gt; [!this!];</p>\n<p>class C {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Use a variable of the appropriate type in place of <code>this</code>, declaring it if\nnecessary:</p>\n<p>{% prettify dart tag=pre+code %}\nC f(C c) =&gt; c;</p>\n<p>class C {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_reference_to_this"
    },
    {
        "key": "invalid_required_named_param",
        "name": "Invalid required named param",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The type parameter '{0}' is annotated with @required but only named parameters without a default value can be annotated with it.\n\nRemove @required."
    },
    {
        "key": "invalid_required_optional_positional_param",
        "name": "Invalid required optional positional param",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Incorrect use of the annotation @required on the optional positional parameter '{0}'. Optional positional parameters cannot be required.\n\nRemove @required."
    },
    {
        "key": "invalid_required_positional_param",
        "name": "Invalid required positional param",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Redundant use of the annotation @required on the required positional parameter '{0}'.\n\nRemove @required."
    },
    {
        "key": "invalid_return_type_for_catch_error",
        "name": "Invalid return type for catch error",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>A value of type '{0}' can't be returned by the 'onError' handler because it\nmust be assignable to '{1}'.</em></p>\n<p><em>The return type '{0}' isn't assignable to '{1}', as required by\n'Future.catchError'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an invocation of\n<code>Future.catchError</code> has an argument whose return type isn't compatible with\nthe type returned by the instance of <code>Future</code>. At runtime, the method\n<code>catchError</code> attempts to return the value from the callback as the result\nof the future, which results in another exception being thrown.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>future</code> is declared to\nreturn an <code>int</code> while <code>callback</code> is declared to return a <code>String</code>, and\n<code>String</code> isn't a subtype of <code>int</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Future<int> future, String Function(dynamic, StackTrace) callback) {\nfuture.catchError([!callback!]);\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the closure being\npassed to <code>catchError</code> returns an <code>int</code> while <code>future</code> is declared to\nreturn a <code>String</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Future<String> future) {\nfuture.catchError((error, stackTrace) =&gt; [!3!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the instance of <code>Future</code> is declared correctly, then change the callback\nto match:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Future<int> future, int Function(dynamic, StackTrace) callback) {\nfuture.catchError(callback);\n}\n{% endprettify %}</p>\n<p>If the declaration of the instance of <code>Future</code> is wrong, then change it to\nmatch the callback:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Future<String> future, String Function(dynamic, StackTrace) callback) {\nfuture.catchError(callback);\n}\n{% endprettify %}</p>"
    },
    {
        "key": "invalid_sealed_annotation",
        "name": "Invalid sealed annotation",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The member '{0}' is annotated with '@sealed' but only classes can be annotated with it.\n\nRemove @sealed."
    },
    {
        "key": "invalid_super_invocation",
        "name": "Invalid super invocation",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The superclass call must be last in an initializer list: '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the initializer list of a\nconstructor contains an invocation of a constructor in the superclass, but\nthe invocation isn't the last item in the initializer list.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the invocation of the\nsuperclass' constructor isn't the last item in the initializer list:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA(int x);\n}</p>\n<p>class B extends A {\nB(int x) : <a href=\"x\">!super!</a>, assert(x &gt;= 0);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Move the invocation of the superclass' constructor to the end of the\ninitializer list:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA(int x);\n}</p>\n<p>class B extends A {\nB(int x) : assert(x &gt;= 0), super(x);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_super_invocation"
    },
    {
        "key": "invalid_type_argument_in_const_literal",
        "name": "Invalid type argument in const literal",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Constant list literals can't include a type parameter as a type argument, such\nas '{0}'.</em></p>\n<p><em>Constant map literals can't include a type parameter as a type argument, such\nas '{0}'.</em></p>\n<p><em>Constant set literals can't include a type parameter as a type argument, such\nas '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a type parameter is used as a\ntype argument in a list, map, or set literal that is prefixed by <code>const</code>.\nThis isn't allowed because the value of the type parameter (the actual type\nthat will be used at runtime) can't be known at compile time.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the type parameter <code>T</code>\nis being used as a type argument when creating a constant list:</p>\n<p>{% prettify dart tag=pre+code %}\nList<T> newList<T>() =&gt; const &lt;[!T!]&gt;[];\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the type parameter <code>T</code>\nis being used as a type argument when creating a constant map:</p>\n<p>{% prettify dart tag=pre+code %}\nMap&lt;String, T&gt; newSet<T>() =&gt; const &lt;String, [!T!]&gt;{};\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the type parameter <code>T</code>\nis being used as a type argument when creating a constant set:</p>\n<p>{% prettify dart tag=pre+code %}\nSet<T> newSet<T>() =&gt; const &lt;[!T!]&gt;{};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type that will be used for the type parameter can be known at\ncompile time, then remove the type parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nList<int> newList() =&gt; const <int>[];\n{% endprettify %}</p>\n<p>If the type that will be used for the type parameter can't be known until\nruntime, then remove the keyword <code>const</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nList<T> newList<T>() =&gt; <T>[];\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_type_argument_in_const_literal"
    },
    {
        "key": "invalid_uri",
        "name": "Invalid uri",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Invalid URI syntax: '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a URI in a directive doesn't\nconform to the syntax of a valid URI.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>'#'</code> isn't a valid\nURI:</p>\n<p>{% prettify dart tag=pre+code %}\nimport [!'#'!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the invalid URI with a valid URI.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_uri"
    },
    {
        "key": "invalid_use_of_covariant",
        "name": "Invalid use of covariant",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The 'covariant' keyword can only be used for parameters in instance methods or before non-final instance fields.\n\nTry removing the 'covariant' keyword."
    },
    {
        "key": "invalid_use_of_internal_member",
        "name": "Invalid use of internal member",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The member '{0}' can only be used within its package.\n\nnull"
    },
    {
        "key": "invalid_use_of_null_value",
        "name": "Invalid use of null value",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>An expression whose value is always 'null' can't be dereferenced.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an expression whose value will\nalways be <code>null</code> is dereferenced.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>x</code> will always be\n<code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint f(Null x) {\nreturn [!x!].length;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the value is allowed to be something other than <code>null</code>, then change the\ntype of the expression:</p>\n<p>{% prettify dart tag=pre+code %}\nint f(String? x) {\nreturn x!.length;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_use_of_null_value"
    },
    {
        "key": "invalid_use_of_protected_member",
        "name": "Invalid use of protected member",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The member '{0}' can only be used within instance members of subclasses of '{1}'.\n\nnull"
    },
    {
        "key": "invalid_use_of_visible_for_template_member",
        "name": "Invalid use of visible for template member",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The member '{0}' can only be used within '{1}' or a template library.\n\nnull"
    },
    {
        "key": "invalid_use_of_visible_for_testing_member",
        "name": "Invalid use of visible for testing member",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The member '{0}' can only be used within '{1}' or a test.\n\nnull"
    },
    {
        "key": "invalid_visibility_annotation",
        "name": "Invalid visibility annotation",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The member '{0}' is annotated with '{1}', but this annotation is only\nmeaningful on declarations of public members.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when either the <code>@visibleForTemplate</code>\nor <code>@visibleForTesting</code> annotation is applied to a non-public declaration.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>[!@visibleForTesting!]\nvoid _someFunction() {}</p>\n<p>void f() =&gt; _someFunction();\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the declaration doesn't need to be used by test code, then remove the\nannotation:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid _someFunction() {}</p>\n<p>void f() =&gt; _someFunction();\n{% endprettify %}</p>\n<p>If it does, then make it public:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>@visibleForTesting\nvoid someFunction() {}</p>\n<p>void f() =&gt; someFunction();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invalid_visibility_annotation"
    },
    {
        "key": "invariant_booleans",
        "name": "Conditions should not unconditionally evaluate to `true` or to `false`.",
        "type": "BUG",
        "status": "BETA",
        "severity": "CRITICAL",
        "description": "<p><strong>DON'T</strong> test for conditions that can be inferred at compile time or test the\nsame condition twice.</p>\n<p>Conditional statements using a condition which cannot be anything but <code>false</code>\nhave the effect of making blocks of code non-functional.  If the condition\ncannot evaluate to anything but <code>true</code>, the conditional statement is completely\nredundant, and makes the code less readable.\nIt is quite likely that the code does not match the programmer's intent.\nEither the condition should be removed or it should be updated so that it does\nnot always evaluate to <code>true</code> or <code>false</code> and does not perform redundant tests.\nThis rule will hint to the test conflicting with the linted one.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">// foo can't be both equal and not equal to bar in the same expression\nif(foo == bar &amp;&amp; something &amp;&amp; foo != bar) {...}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void compute(int foo) {\n  if (foo == 4) {\n    doSomething();\n    // we know foo is equal to 4 at this point, so the next condition is always false\n    if (foo &gt; 4) {...}\n    ...\n  }\n  ...\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void compute(bool foo) {\n  if (foo) {\n    return;\n  }\n  doSomething();\n  // foo is always false here\n  if (foo){...}\n  ...\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void nestedOK() {\n  if (foo == bar) {\n    foo = baz;\n    if (foo != bar) {...}\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void nestedOk2() {\n  if (foo == bar) {\n    return;\n  }\n\n  foo = baz;\n  if (foo == bar) {...} // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void nestedOk5() {\n  if (foo != null) {\n    if (bar != null) {\n      return;\n    }\n  }\n\n  if (bar != null) {...} // OK\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/invariant_booleans.html"
    },
    {
        "key": "invocation_of_extension_without_call",
        "name": "Invocation of extension without call",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The extension '{0}' doesn't define a 'call' method so the override can't be\nused in an invocation.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension override is used to\ninvoke a function but the extension doesn't declare a <code>call</code> method.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the extension <code>E</code>\ndoesn't define a <code>call</code> method:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {}</p>\n<p>void f() {\n<a href=\"\">!E('')!</a>;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the extension is intended to define a <code>call</code> method, then declare it:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nint call() =&gt; 0;\n}</p>\n<p>void f() {\nE('')();\n}\n{% endprettify %}</p>\n<p>If the extended type defines a <code>call</code> method, then remove the extension\noverride.</p>\n<p>If the <code>call</code> method isn't defined, then rewrite the code so that it\ndoesn't invoke the <code>call</code> method.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invocation_of_extension_without_call"
    },
    {
        "key": "invocation_of_non_function",
        "name": "Invocation of non function",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{0}' isn't a function.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds a function invocation,\nbut the name of the function being invoked is defined to be something other\nthan a function.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>Binary</code> is the name of\na function type, not a function:</p>\n<p>{% prettify dart tag=pre+code %}\ntypedef Binary = int Function(int, int);</p>\n<p>int f() {\nreturn [!Binary!](1, 2);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the name with the name of a function.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invocation_of_non_function"
    },
    {
        "key": "invocation_of_non_function_expression",
        "name": "Invocation of non function expression",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The expression doesn't evaluate to a function, so it can't be invoked.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a function invocation is found,\nbut the name being referenced isn't the name of a function, or when the\nexpression computing the function doesn't compute a function.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> isn't a function:</p>\n<p>{% prettify dart tag=pre+code %}\nint x = 0;</p>\n<p>int f() =&gt; x;</p>\n<p>var y = <a href=\"\">!x!</a>;\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>f()</code> doesn't return a\nfunction:</p>\n<p>{% prettify dart tag=pre+code %}\nint x = 0;</p>\n<p>int f() =&gt; x;</p>\n<p>var y = <a href=\"\">!f()!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to invoke a function, then replace the code before the argument\nlist with the name of a function or with an expression that computes a\nfunction:</p>\n<p>{% prettify dart tag=pre+code %}\nint x = 0;</p>\n<p>int f() =&gt; x;</p>\n<p>var y = f();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#invocation_of_non_function_expression"
    },
    {
        "key": "iterable_contains_unrelated_type",
        "name": "Invocation of Iterable<E>.contains with references of unrelated types.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DON'T</strong> invoke <code>contains</code> on <code>Iterable</code> with an instance of different type\nthan the parameter type.</p>\n<p>Doing this will invoke <code>==</code> on its elements and most likely will return <code>false</code>.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction() {\n  var list = &lt;int&gt;[];\n  if (list.contains('1')) print('someFunction'); // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction3() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.contains('1')) print('someFunction3'); // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction8() {\n  List&lt;DerivedClass2&gt; list = &lt;DerivedClass2&gt;[];\n  DerivedClass3 instance;\n  if (list.contains(instance)) print('someFunction8'); // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">abstract class SomeIterable&lt;E&gt; implements Iterable&lt;E&gt; {}\n\nabstract class MyClass implements SomeIterable&lt;int&gt; {\n  bool badMethod(String thing) =&gt; this.contains(thing); // LINT\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction10() {\n  var list = [];\n  if (list.contains(1)) print('someFunction10'); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction1() {\n  var list = &lt;int&gt;[];\n  if (list.contains(1)) print('someFunction1'); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction4() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.contains(1)) print('someFunction4'); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction5() {\n  List&lt;ClassBase&gt; list = &lt;ClassBase&gt;[];\n  DerivedClass1 instance;\n  if (list.contains(instance)) print('someFunction5'); // OK\n}\n\nabstract class ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction6() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass2 instance;\n  if (list.contains(instance)) print('someFunction6'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction7() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass3 instance;\n  if (list.contains(instance)) print('someFunction7'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/iterable_contains_unrelated_type.html"
    },
    {
        "key": "join_return_with_assignment",
        "name": "Join return statement with assignment when possible.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> join return statement with assignment when possible.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  B _lazyInstance;\n  static B get instance {\n    _lazyInstance ??= B(); // LINT\n    return _lazyInstance;\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  B _lazyInstance;\n  static B get instance =&gt; _lazyInstance ??= B();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/join_return_with_assignment.html"
    },
    {
        "key": "label_in_outer_scope",
        "name": "Label in outer scope",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Can't reference label '{0}' declared in an outer method.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a <code>break</code> or <code>continue</code>\nstatement references a label that is declared in a method or function\ncontaining the function in which the <code>break</code> or <code>continue</code> statement\nappears. The <code>break</code> and <code>continue</code> statements can't be used to transfer\ncontrol outside the function that contains them.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the label <code>loop</code> is\ndeclared outside the local function <code>g</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nloop:\nwhile (true) {\nvoid g() {\nbreak [!loop!];\n}</p>\n<pre><code>g();\n</code></pre>\n<p>}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Try rewriting the code so that it isn't necessary to transfer control\noutside the local function, possibly by inlining the local function:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nloop:\nwhile (true) {\nbreak loop;\n}\n}\n{% endprettify %}</p>\n<p>If that isn't possible, then try rewriting the local function so that a\nvalue returned by the function can be used to determine whether control is\ntransferred:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nloop:\nwhile (true) {\nbool g() {\nreturn true;\n}</p>\n<pre><code>if (g()) {\n  break loop;\n}\n</code></pre>\n<p>}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#label_in_outer_scope"
    },
    {
        "key": "label_undefined",
        "name": "Label undefined",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Can't reference an undefined label '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds a reference to a label\nthat isn't defined in the scope of the <code>break</code> or <code>continue</code> statement that\nis referencing it.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the label <code>loop</code> isn't\ndefined anywhere:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nfor (int i = 0; i &lt; 10; i++) {\nfor (int j = 0; j &lt; 10; j++) {\nbreak [!loop!];\n}\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the label should be on the innermost enclosing <code>do</code>, <code>for</code>, <code>switch</code>, or\n<code>while</code> statement, then remove the label:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nfor (int i = 0; i &lt; 10; i++) {\nfor (int j = 0; j &lt; 10; j++) {\nbreak;\n}\n}\n}\n{% endprettify %}</p>\n<p>If the label should be on some other statement, then add the label:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nloop: for (int i = 0; i &lt; 10; i++) {\nfor (int j = 0; j &lt; 10; j++) {\nbreak loop;\n}\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#label_undefined"
    },
    {
        "key": "late_final_field_with_const_constructor",
        "name": "Late final field with const constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Can't have a late final field in a class with a const constructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class that has at least one\n<code>const</code> constructor also has a field marked both <code>late</code> and <code>final</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the class <code>A</code> has a\n<code>const</code> constructor and the <code>final</code> field <code>f</code> is marked as <code>late</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\n[!late!] final int f;</p>\n<p>const A();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the field doesn't need to be marked <code>late</code>, then remove the <code>late</code>\nmodifier from the field:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nfinal int f = 0;</p>\n<p>const A();\n}\n{% endprettify %}</p>\n<p>If the field must be marked <code>late</code>, then remove the <code>const</code> modifier from\nthe constructors:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nlate final int f;</p>\n<p>A();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#late_final_field_with_const_constructor"
    },
    {
        "key": "late_final_local_already_assigned",
        "name": "Late final local already assigned",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The late final local variable is already assigned.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the analyzer can prove that a\nlocal variable marked as both <code>late</code> and <code>final</code> was already assigned a\nvalue at the point where another assignment occurs.</p>\n<p>Because <code>final</code> variables can only be assigned once, subsequent assignments\nare guaranteed to fail, so they're flagged.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the <code>final</code> variable\n<code>v</code> is assigned a value in two places:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() {\nlate final int v;\nv = 0;\n[!v!] += 1;\nreturn v;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to be able to reassign the variable, then remove the <code>final</code>\nkeyword:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() {\nlate int v;\nv = 0;\nv += 1;\nreturn v;\n}\n{% endprettify %}</p>\n<p>If you don't need to reassign the variable, then remove all except the\nfirst of the assignments:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() {\nlate final int v;\nv = 0;\nreturn v;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#late_final_local_already_assigned"
    },
    {
        "key": "leading_newlines_in_multiline_strings",
        "name": "Start multiline strings with a newline.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Multiline strings are easier to read when they start with a newline (a newline\nstarting a multiline string is ignored).</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var s1 = '''{\n  \"a\": 1,\n  \"b\": 2\n}''';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var s1 = '''\n{\n  \"a\": 1,\n  \"b\": 2\n}''';\n\nvar s2 = '''This onliner multiline string is ok. It usually allows to escape both ' and \" in the string.''';\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/leading_newlines_in_multiline_strings.html"
    },
    {
        "key": "library_names",
        "name": "Name libraries using `lowercase_with_underscores`.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> name libraries using <code>lowercase_with_underscores</code>.</p>\n<p>Some file systems are not case-sensitive, so many projects require filenames to\nbe all lowercase. Using a separating character allows names to still be readable\nin that form. Using underscores as the separator ensures that the name is still\na valid Dart identifier, which may be helpful if the language later supports\nsymbolic imports.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">library peg_parser;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">library peg-parser;\n</code></pre>\n<p>The lint <code>file_names</code> can be used to enforce the same kind of naming on the\nfile.</p>\n\n@see https://dart-lang.github.io/linter/lints/library_names.html"
    },
    {
        "key": "library_prefixes",
        "name": "Use `lowercase_with_underscores` when specifying a library prefix.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use <code>lowercase_with_underscores</code> when specifying a library prefix.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">import 'dart:math' as math;\nimport 'dart:json' as json;\nimport 'package:js/js.dart' as js;\nimport 'package:javascript_utils/javascript_utils.dart' as js_utils;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'dart:math' as Math;\nimport 'dart:json' as JSON;\nimport 'package:js/js.dart' as JS;\nimport 'package:javascript_utils/javascript_utils.dart' as jsUtils;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/library_prefixes.html"
    },
    {
        "key": "library_private_types_in_public_api",
        "name": "Avoid using private types in public APIs.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> using library private types in public APIs.</p>\n<p>For the purposes of this lint, a public API is considered to be any top-level or\nmember declaration unless the declaration is library private or contained in a\ndeclarartion that's library private. The following uses of types are checked:</p>\n<ul>\n<li>the return type of a function or method,</li>\n<li>the type of any parameter of a function or method,</li>\n<li>the bound of a type parameter to any function, method, class, mixin,\nextension's extended type, or type alias,</li>\n<li>the type of any top level variable or field,</li>\n<li>any type used in the declaration of a type alias (for example\n<code>typedef F = _Private Function();</code>), or</li>\n<li>any type used in the <code>on</code> clause of an extension or a mixin</li>\n</ul>\n<p><strong>GOOD:</strong></p>\n<pre><code>f(String s) { ... }\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code>f(_Private p) { ... }\nclass _Private {}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/library_private_types_in_public_api.html"
    },
    {
        "key": "lines_longer_than_80_chars",
        "name": "Avoid lines longer than 80 characters.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> lines longer than 80 characters</p>\n<p>Readability studies show that long lines of text are harder to read because your\neye has to travel farther when moving to the beginning of the next line. This is\nwhy newspapers and magazines use multiple columns of text.</p>\n<p>If you really find yourself wanting lines longer than 80 characters, our\nexperience is that your code is likely too verbose and could be a little more\ncompact. The main offender is usually <code>VeryLongCamelCaseClassNames</code>. Ask\nyourself, â€œDoes each word in that type name tell me something critical or\nprevent a name collision?â€ If not, consider omitting it.</p>\n<p>Note that <code>dart format</code> does 99% of this for you, but the last 1% is you. It \ndoes not split long string literals to fit in 80 columns, so you have to do \nthat manually.</p>\n<p>We make an exception for URIs and file paths. When those occur in comments or\nstrings (usually in imports and exports), they may remain on a single line even\nif they go over the line limit. This makes it easier to search source files for\na given path.</p>\n\n@see https://dart-lang.github.io/linter/lints/lines_longer_than_80_chars.html"
    },
    {
        "key": "list_element_type_not_assignable",
        "name": "List element type not assignable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The element type '{0}' can't be assigned to the list type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the type of an element in a list\nliteral isn't assignable to the element type of the list.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>2.5</code> is a double, and\nthe list can hold only integers:</p>\n<p>{% prettify dart tag=pre+code %}\nList<int> x = [1, [!2.5!], 3];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you intended to add a different object to the list, then replace the\nelement with an expression that computes the intended object:</p>\n<p>{% prettify dart tag=pre+code %}\nList<int> x = [1, 2, 3];\n{% endprettify %}</p>\n<p>If the object shouldn't be in the list, then remove the element:</p>\n<p>{% prettify dart tag=pre+code %}\nList<int> x = [1, 3];\n{% endprettify %}</p>\n<p>If the object being computed is correct, then widen the element type of the\nlist to allow all of the different types of objects it needs to contain:</p>\n<p>{% prettify dart tag=pre+code %}\nList<num> x = [1, 2.5, 3];\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#list_element_type_not_assignable"
    },
    {
        "key": "list_remove_unrelated_type",
        "name": "Invocation of `remove` with references of unrelated types.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DON'T</strong> invoke <code>remove</code> on <code>List</code> with an instance of different type than\nthe parameter type.</p>\n<p>Doing this will invoke <code>==</code> on its elements and most likely will\nreturn <code>false</code>.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction() {\n  var list = &lt;int&gt;[];\n  if (list.remove('1')) print('someFunction'); // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction3() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.remove('1')) print('someFunction3'); // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction8() {\n  List&lt;DerivedClass2&gt; list = &lt;DerivedClass2&gt;[];\n  DerivedClass3 instance;\n  if (list.remove(instance)) print('someFunction8'); // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">abstract class SomeList&lt;E&gt; implements List&lt;E&gt; {}\n\nabstract class MyClass implements SomeList&lt;int&gt; {\n  bool badMethod(String thing) =&gt; this.remove(thing); // LINT\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction10() {\n  var list = [];\n  if (list.remove(1)) print('someFunction10'); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction1() {\n  var list = &lt;int&gt;[];\n  if (list.remove(1)) print('someFunction1'); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction4() {\n  List&lt;int&gt; list = &lt;int&gt;[];\n  if (list.remove(1)) print('someFunction4'); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction5() {\n  List&lt;ClassBase&gt; list = &lt;ClassBase&gt;[];\n  DerivedClass1 instance;\n  if (list.remove(instance)) print('someFunction5'); // OK\n}\n\nabstract class ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction6() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass2 instance;\n  if (list.remove(instance)) print('someFunction6'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction7() {\n  List&lt;Mixin&gt; list = &lt;Mixin&gt;[];\n  DerivedClass3 instance;\n  if (list.remove(instance)) print('someFunction7'); // OK\n}\n\nabstract class ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/list_remove_unrelated_type.html"
    },
    {
        "key": "literal_only_boolean_expressions",
        "name": "Boolean expression composed only with literals.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DON'T</strong> test for conditions composed only by literals, since the value can be\ninferred at compile time.</p>\n<p>Conditional statements using a condition which cannot be anything but FALSE have\nthe effect of making blocks of code non-functional.  If the condition cannot\nevaluate to anything but <code>true</code>, the conditional statement is completely\nredundant, and makes the code less readable.\nIt is quite likely that the code does not match the programmer's intent.\nEither the condition should be removed or it should be updated so that it does\nnot always evaluate to <code>true</code> or <code>false</code>.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void bad() {\n  if (true) {} // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void bad() {\n  if (true &amp;&amp; 1 != 0) {} // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void bad() {\n  if (1 != 0 &amp;&amp; true) {} // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void bad() {\n  if (1 &lt; 0 &amp;&amp; true) {} // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void bad() {\n  if (true &amp;&amp; false) {} // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void bad() {\n  if (1 != 0) {} // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void bad() {\n  if (true &amp;&amp; 1 != 0 || 3 &lt; 4) {} // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void bad() {\n  if (1 != 0 || 3 &lt; 4 &amp;&amp; true) {} // LINT\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/literal_only_boolean_expressions.html"
    },
    {
        "key": "main_first_positional_parameter_type",
        "name": "Main first positional parameter type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The type of the first positional parameter of the 'main' function must be a\nsupertype of 'List<String>'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the first positional parameter\nof a function named <code>main</code> isn't a supertype of <code>List&lt;String&gt;</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>List&lt;int&gt;</code> isn't a\nsupertype of <code>List&lt;String&gt;</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid main([!List<int>!] args) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the function is an entry point, then change the type of the first\npositional parameter to be a supertype of <code>List&lt;String&gt;</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid main(List<String> args) {}\n{% endprettify %}</p>\n<p>If the function isn't an entry point, then change the name of the function:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(List<int> args) {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#main_first_positional_parameter_type"
    },
    {
        "key": "main_has_required_named_parameters",
        "name": "Main has required named parameters",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The function 'main' can't have any required named parameters.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a function named <code>main</code> has one\nor more required named parameters.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the function named\n<code>main</code> has a required named parameter (<code>x</code>):</p>\n<p>{% prettify dart tag=pre+code %}\nvoid [!main!]({required int x}) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the function is an entry point, then remove the <code>required</code> keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid main({int? x}) {}\n{% endprettify %}</p>\n<p>If the function isn't an entry point, then change the name of the function:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f({required int x}) {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#main_has_required_named_parameters"
    },
    {
        "key": "main_has_too_many_required_positional_parameters",
        "name": "Main has too many required positional parameters",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The function 'main' can't have more than two required positional parameters.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a function named <code>main</code> has more\nthan two required positional parameters.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the function <code>main</code> has\nthree required positional parameters:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid [!main!](List<String> args, int x, int y) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the function is an entry point and the extra parameters aren't used,\nthen remove them:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid main(List<String> args, int x) {}\n{% endprettify %}</p>\n<p>If the function is an entry point, but the extra parameters used are for\nwhen the function isn't being used as an entry point, then make the extra\nparameters optional:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid main(List<String> args, int x, [int y = 0]) {}\n{% endprettify %}</p>\n<p>If the function isn't an entry point, then change the name of the function:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(List<String> args, int x, int y) {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#main_has_too_many_required_positional_parameters"
    },
    {
        "key": "main_is_not_function",
        "name": "Main is not function",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The declaration named 'main' must be a function.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a library contains a declaration\nof the name <code>main</code> that isn't the declaration of a top-level function.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the name <code>main</code> is\nbeing used to declare a top-level variable:</p>\n<p>{% prettify dart tag=pre+code %}\nvar [!main!] = 3;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Use a different name for the declaration:</p>\n<p>{% prettify dart tag=pre+code %}\nvar mainIndex = 3;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#main_is_not_function"
    },
    {
        "key": "map_entry_not_in_map",
        "name": "Map entry not in map",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Map entries can only be used in a map literal.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a map entry (a key/value pair)\nis found in a set literal.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the literal has a map\nentry even though it's a set literal:</p>\n<p>{% prettify dart tag=pre+code %}\nconst collection = <String>{[!'a' : 'b'!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you intended for the collection to be a map, then change the code so\nthat it is a map. In the previous example, you could do this by adding\nanother type argument:</p>\n<p>{% prettify dart tag=pre+code %}\nconst collection = &lt;String, String&gt;{'a' : 'b'};\n{% endprettify %}</p>\n<p>In other cases, you might need to change the explicit type from <code>Set</code> to\n<code>Map</code>.</p>\n<p>If you intended for the collection to be a set, then remove the map entry,\npossibly by replacing the colon with a comma if both values should be\nincluded in the set:</p>\n<p>{% prettify dart tag=pre+code %}\nconst collection = <String>{'a', 'b'};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#map_entry_not_in_map"
    },
    {
        "key": "map_key_type_not_assignable",
        "name": "Map key type not assignable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The element type '{0}' can't be assigned to the map key type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a key of a key-value pair in a\nmap literal has a type that isn't assignable to the key type of the map.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>2</code> is an <code>int</code>, but\nthe keys of the map are required to be <code>String</code>s:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = &lt;String, String&gt;{[!2!] : 'a'};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type of the map is correct, then change the key to have the correct\ntype:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = &lt;String, String&gt;{'2' : 'a'};\n{% endprettify %}</p>\n<p>If the type of the key is correct, then change the key type of the map:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = &lt;int, String&gt;{2 : 'a'};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#map_key_type_not_assignable"
    },
    {
        "key": "map_value_type_not_assignable",
        "name": "Map value type not assignable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The element type '{0}' can't be assigned to the map value type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a value of a key-value pair in a\nmap literal has a type that isn't assignable to the the value type of the\nmap.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>2</code> is an <code>int</code>, but/\nthe values of the map are required to be <code>String</code>s:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = &lt;String, String&gt;{'a' : [!2!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type of the map is correct, then change the value to have the\ncorrect type:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = &lt;String, String&gt;{'a' : '2'};\n{% endprettify %}</p>\n<p>If the type of the value is correct, then change the value type of the map:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = &lt;String, int&gt;{'a' : 2};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#map_value_type_not_assignable"
    },
    {
        "key": "missing_const_in_list_literal",
        "name": "Missing const in list literal",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "List literals must be prefixed with 'const' when used as a constant expression.\n\nTry adding the keyword 'const' before the literal."
    },
    {
        "key": "missing_const_in_map_literal",
        "name": "Missing const in map literal",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Map literals must be prefixed with 'const' when used as a constant expression.\n\nTry adding the keyword 'const' before the literal."
    },
    {
        "key": "missing_const_in_set_literal",
        "name": "Missing const in set literal",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Set literals must be prefixed with 'const' when used as a constant expression.\n\nTry adding the keyword 'const' before the literal."
    },
    {
        "key": "missing_dart_library",
        "name": "Missing dart library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Required library '{0}' is missing.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when either the Dart or Flutter SDK\nisnâ€™t installed correctly, and, as a result, one of the <code>dart:</code> libraries\ncan't be found.</p>\n<h4>Common fixes</h4>\n<p>Reinstall the Dart or Flutter SDK.</p>"
    },
    {
        "key": "missing_default_value_for_parameter",
        "name": "Missing default value for parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The parameter '{0}' can't have a value of 'null' because of its type, but the\nimplicit default value is 'null'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an optional parameter, whether\npositional or named, has a <a href=\"https://dart.dev/tools/diagnostic-messages#potentially-non-nullable\">potentially non-nullable</a> type and doesn't\nspecify a default value. Optional parameters that have no explicit default\nvalue have an implicit default value of <code>null</code>. If the type of the\nparameter doesn't allow the parameter to have a value of <code>null</code>, then the\nimplicit default value isn't valid.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>x</code> can't be <code>null</code>,\nand no non-<code>null</code> default value is specified:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f([int [!x!]]) {}\n{% endprettify %}</p>\n<p>As does this:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid g({int [!x!]}) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you want to use <code>null</code> to indicate that no value was provided, then you\nneed to make the type nullable:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f([int? x]) {}\nvoid g({int? x}) {}\n{% endprettify %}</p>\n<p>If the parameter can't be null, then either provide a default value:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f([int x = 1]) {}\nvoid g({int x = 2}) {}\n{% endprettify %}</p>\n<p>or make the parameter a required parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int x) {}\nvoid g({required int x}) {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#missing_default_value_for_parameter"
    },
    {
        "key": "missing_enum_constant_in_switch",
        "name": "Missing enum constant in switch",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Missing case clause for '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a <code>switch</code> statement for an enum\ndoesn't include an option for one of the values in the enumeration.</p>\n<p>Note that <code>null</code> is always a possible value for an enum and therefore also\nmust be handled.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the enum constant <code>e2</code>\nisn't handled:</p>\n<p>{% prettify dart tag=pre+code %}\nenum E { e1, e2 }</p>\n<p>void f(E e) {\n[!switch (e)!] {\ncase E.e1:\nbreak;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If there's special handling for the missing values, then add a <code>case</code>\nclause for each of the missing values:</p>\n<p>{% prettify dart tag=pre+code %}\nenum E { e1, e2 }</p>\n<p>void f(E e) {\nswitch (e) {\ncase E.e1:\nbreak;\ncase E.e2:\nbreak;\n}\n}\n{% endprettify %}</p>\n<p>If the missing values should be handled the same way, then add a <code>default</code>\nclause:</p>\n<p>{% prettify dart tag=pre+code %}\nenum E { e1, e2 }</p>\n<p>void f(E e) {\nswitch (e) {\ncase E.e1:\nbreak;\ndefault:\nbreak;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#missing_enum_constant_in_switch"
    },
    {
        "key": "missing_js_lib_annotation",
        "name": "Missing js lib annotation",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The @JS() annotation can only be used if it is also declared on the library directive.\n\nTry adding the annotation to the library directive."
    },
    {
        "key": "missing_required_argument",
        "name": "Missing required argument",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The named parameter '{0}' is required, but there's no corresponding argument.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an invocation of a function is\nmissing a required named parameter.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the invocation of <code>f</code>\ndoesn't include a value for the required named parameter <code>end</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int start, {required int end}) {}\nvoid g() {\n<a href=\"3\">!f!</a>;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add a named argument corresponding to the missing required parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int start, {required int end}) {}\nvoid g() {\nf(3, end: 5);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#missing_required_argument"
    },
    {
        "key": "missing_required_param",
        "name": "Missing required param",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The parameter '{0}' is required.</em></p>\n<p><em>The parameter '{0}' is required. {1}.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a method or function with a\nnamed parameter that is annotated as being required is invoked without\nproviding a value for the parameter.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the named parameter <code>x</code>\nis required:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>void f({@required int x}) {}</p>\n<p>void g() {\n<a href=\"\">!f!</a>;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Provide the required value:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>void f({@required int x}) {}</p>\n<p>void g() {\nf(x: 2);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#missing_required_param"
    },
    {
        "key": "missing_return",
        "name": "Missing return",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>This function has a return type of '{0}', but doesn't end with a return\nstatement.</em></p>\n<h4>Description</h4>\n<p>Any function or method that doesn't end with either an explicit return or a\nthrow implicitly returns <code>null</code>. This is rarely the desired behavior. The\nanalyzer produces this diagnostic when it finds an implicit return.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> doesn't end with a\nreturn:</p>\n<p>{% prettify dart tag=pre+code %}\nint [!f!](int x) {\nif (x &lt; 0) {\nreturn 0;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add a <code>return</code> statement that makes the return value explicit, even if\n<code>null</code> is the appropriate value.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#missing_return"
    },
    {
        "key": "missing_whitespace_between_adjacent_strings",
        "name": "Missing whitespace between adjacent strings.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Add a trailing whitespace to prevent missing whitespace between adjacent\nstrings.</p>\n<p>With long text split accross adjacent strings it's easy to forget a whitespace\nbetween strings.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var s =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed'\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var s =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed '\n  'do eiusmod tempor incididunt ut labore et dolore magna';\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/missing_whitespace_between_adjacent_strings.html"
    },
    {
        "key": "mixin_application_concrete_super_invoked_member_type",
        "name": "Mixin application concrete super invoked member type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The super-invoked member '{0}' has the type '{1}', but the concrete member in the class has type '{2}'.\n\nnull"
    },
    {
        "key": "mixin_application_no_concrete_super_invoked_member",
        "name": "Mixin application no concrete super invoked member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The class doesn't have a concrete implementation of the super-invoked member\n'{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a <a href=\"https://dart.dev/tools/diagnostic-messages#mixin-application\">mixin application</a> contains\nan invocation of a member from its superclass, and there's no concrete\nmember of that name in the mixin application's superclass.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the mixin <code>M</code> contains\nthe invocation <code>super.m()</code>, and the class <code>A</code>, which is the superclass of\nthe <a href=\"https://dart.dev/tools/diagnostic-messages#mixin-application\">mixin application</a> <code>A+M</code>, doesn't define a concrete implementation\nof <code>m</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nvoid m();\n}</p>\n<p>mixin M on A {\nvoid bar() {\nsuper.m();\n}\n}</p>\n<p>abstract class B extends A with [!M!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you intended to apply the mixin <code>M</code> to a different class, one that has a\nconcrete implementation of <code>m</code>, then change the superclass of <code>B</code> to that\nclass:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nvoid m();\n}</p>\n<p>mixin M on A {\nvoid bar() {\nsuper.m();\n}\n}</p>\n<p>class C implements A {\nvoid m() {}\n}</p>\n<p>abstract class B extends C with M {}\n{% endprettify %}</p>\n<p>If you need to make <code>B</code> a subclass of <code>A</code>, then add a concrete\nimplementation of <code>m</code> in <code>A</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nvoid m() {}\n}</p>\n<p>mixin M on A {\nvoid bar() {\nsuper.m();\n}\n}</p>\n<p>abstract class B extends A with M {}\n{% endprettify %}</p>"
    },
    {
        "key": "mixin_application_not_implemented_interface",
        "name": "Mixin application not implemented interface",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't be mixed onto '{1}' because '{1}' doesn't implement '{2}'.\n\nTry extending the class '{0}'."
    },
    {
        "key": "mixin_class_declares_constructor",
        "name": "Mixin class declares constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The class '{0}' can't be used as a mixin because it declares a constructor.\n\nnull"
    },
    {
        "key": "mixin_declares_constructor",
        "name": "Mixin declares constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Mixins can't declare constructors.\n\nnull"
    },
    {
        "key": "mixin_inference_inconsistent_matching_classes",
        "name": "Mixin inference inconsistent matching classes",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Type parameters couldn't be inferred for the mixin '{0}' because the base class implements the mixin's supertype constraint '{1}' in multiple conflicting ways\n\nnull"
    },
    {
        "key": "mixin_inference_no_matching_class",
        "name": "Mixin inference no matching class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Type parameters couldn't be inferred for the mixin '{0}' because the base class doesn't implement the mixin's supertype constraint '{1}'\n\nnull"
    },
    {
        "key": "mixin_inference_no_possible_substitution",
        "name": "Mixin inference no possible substitution",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Type parameters couldn't be inferred for the mixin '{0}' because no type parameter substitution could be found matching the mixin's supertype constraints\n\nnull"
    },
    {
        "key": "mixin_inherits_from_not_object",
        "name": "Mixin inherits from not object",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The class '{0}' can't be used as a mixin because it extends a class other than Object.\n\nnull"
    },
    {
        "key": "mixin_instantiate",
        "name": "Mixin instantiate",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Mixins can't be instantiated.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a mixin is instantiated.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the mixin <code>M</code> is being\ninstantiated:</p>\n<p>{% prettify dart tag=pre+code %}\nmixin M {}</p>\n<p>var m = <a href=\"\">!M!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you intend to use an instance of a class, then use the name of that\nclass in place of the name of the mixin.</p>"
    },
    {
        "key": "mixin_of_non_class",
        "name": "Mixin of non class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Classes can only mix in mixins and classes.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a name in a <code>with</code> clause is\ndefined to be something other than a mixin or a class.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>F</code> is defined to be a\nfunction type:</p>\n<p>{% prettify dart tag=pre+code %}\ntypedef F = int Function(String);</p>\n<p>class C with [!F!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the invalid name from the list, possibly replacing it with the name\nof the intended mixin or class:</p>\n<p>{% prettify dart tag=pre+code %}\ntypedef F = int Function(String);</p>\n<p>class C {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#mixin_of_non_class"
    },
    {
        "key": "mixin_of_type_alias_expands_to_type_parameter",
        "name": "Mixin of type alias expands to type parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Type aliases that expand to a type parameter can't be mixed in.\n\nnull"
    },
    {
        "key": "mixin_on_sealed_class",
        "name": "Mixin on sealed class",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The class '{0}' shouldn't be used as a mixin constraint because it is sealed,\nand any class mixing in this mixin must have '{0}' as a superclass.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the superclass constraint of a\nmixin is a class from a different package that was marked as <code>@sealed</code>.\nClasses that are sealed can't be extended, implemented, mixed in, or used\nas a superclass constraint.</p>\n<h4>Examples</h4>\n<p>If the package <code>p</code> defines a sealed class:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>@sealed\nclass C {}\n{% endprettify %}</p>\n<p>Then, the following code, when in a package other than <code>p</code>, produces this\ndiagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:p/p.dart';</p>\n<p>[!mixin M on C {}!]\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the classes that use the mixin don't need to be subclasses of the sealed\nclass, then consider adding a field and delegating to the wrapped instance\nof the sealed class.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#mixin_on_sealed_class"
    },
    {
        "key": "mixin_on_type_alias_expands_to_type_parameter",
        "name": "Mixin on type alias expands to type parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Type aliases that expand to a type parameter can't be used assuperclass constraints.\n\nnull"
    },
    {
        "key": "mixin_super_class_constraint_deferred_class",
        "name": "Mixin super class constraint deferred class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Deferred classes can't be used as super-class constraints.\n\nTry changing the import to not be deferred."
    },
    {
        "key": "mixin_super_class_constraint_non_interface",
        "name": "Mixin super class constraint non interface",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Only classes and mixins can be used as superclass constraints.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a type following the <code>on</code>\nkeyword in a mixin declaration is neither a class nor a mixin.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>F</code> is neither a class\nnor a mixin:</p>\n<p>{% prettify dart tag=pre+code %}\ntypedef F = void Function();</p>\n<p>mixin M on [!F!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type was intended to be a class but was mistyped, then replace the\nname.</p>\n<p>Otherwise, remove the type from the <code>on</code> clause.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#mixin_super_class_constraint_non_interface"
    },
    {
        "key": "mixin_with_non_class_superclass",
        "name": "Mixin with non class superclass",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Mixin can only be applied to class.\n\nnull"
    },
    {
        "key": "mixins_super_class",
        "name": "Mixins super class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't be used in both 'extends' and 'with' clauses.\n\nTry removing one of the occurrences."
    },
    {
        "key": "multiple_redirecting_constructor_invocations",
        "name": "Multiple redirecting constructor invocations",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Constructors can have at most one 'this' redirection.\n\nTry removing all but one of the redirections."
    },
    {
        "key": "multiple_super_initializers",
        "name": "Multiple super initializers",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Constructor may have at most one 'super' initializer.\n\nTry removing all but one of the 'super' initializers."
    },
    {
        "key": "must_be_immutable",
        "name": "Must be immutable",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>This class (or a class that this class inherits from) is marked as\n'@immutable', but one or more of its instance fields aren't final: {0}</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an immutable class defines one\nor more instance fields that aren't final. A class is immutable if it's\nmarked as being immutable using the annotation <code>@immutable</code> or if it's a\nsubclass of an immutable class.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the field <code>x</code> isn't\nfinal:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>@immutable\nclass [!C!] {\nint x;</p>\n<p>C(this.x);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If instances of the class should be immutable, then add the keyword <code>final</code>\nto all non-final field declarations:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>@immutable\nclass C {\nfinal int x;</p>\n<p>C(this.x);\n}\n{% endprettify %}</p>\n<p>If the instances of the class should be mutable, then remove the\nannotation, or choose a different superclass if the annotation is\ninherited:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>C(this.x);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#must_be_immutable"
    },
    {
        "key": "must_call_super",
        "name": "Must call super",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>This method overrides a method annotated as '@mustCallSuper' in '{0}', but\ndoesn't invoke the overridden method.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a method that overrides a method\nthat is annotated as <code>@mustCallSuper</code> doesn't invoke the overridden method\nas required.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the method <code>m</code> in <code>B</code>\ndoesn't invoke the overridden method <code>m</code> in <code>A</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>class A {\n@mustCallSuper\nm() {}\n}</p>\n<p>class B extends A {\n@override\n<a href=\"\">!m!</a> {}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add an invocation of the overridden method in the overriding method:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>class A {\n@mustCallSuper\nm() {}\n}</p>\n<p>class B extends A {\n@override\nm() {\nsuper.m();\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#must_call_super"
    },
    {
        "key": "new_with_undefined_constructor",
        "name": "New with undefined constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The class '{0}' doesn't have a constructor named '{1}'.\n\nTry invoking a different constructor, or define a constructor named '{1}'."
    },
    {
        "key": "new_with_undefined_constructor_default",
        "name": "New with undefined constructor default",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The class '{0}' doesn't have a default constructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an unnamed constructor is\ninvoked on a class that defines named constructors but the class doesnâ€™t\nhave an unnamed constructor.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>A</code> doesn't define an\nunnamed constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA.a();\n}</p>\n<p>A f() =&gt; <a href=\"\">!A!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If one of the named constructors does what you need, then use it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA.a();\n}</p>\n<p>A f() =&gt; A.a();\n{% endprettify %}</p>\n<p>If none of the named constructors does what you need, and you're able to\nadd an unnamed constructor, then add the constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA();\nA.a();\n}</p>\n<p>A f() =&gt; A();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#new_with_undefined_constructor_default"
    },
    {
        "key": "no_adjacent_strings_in_list",
        "name": "Don't use adjacent strings in list.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DON'T</strong> use adjacent strings in list.</p>\n<p>This can be sign of forgotten comma.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">List&lt;String&gt; list = &lt;String&gt;[\n  'a' +\n  'b',\n  'c',\n];\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">List&lt;String&gt; list = &lt;String&gt;[\n  'a'\n  'b',\n  'c',\n];\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/no_adjacent_strings_in_list.html"
    },
    {
        "key": "no_annotation_constructor_arguments",
        "name": "No annotation constructor arguments",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Annotation creation must have arguments.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an annotation consists of a\nsingle identifier, but that identifier is the name of a class rather than a\nvariable. To create an instance of the class, the identifier must be\nfollowed by an argument list.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>C</code> is a class, and a\nclass can't be used as an annotation without invoking a <code>const</code> constructor\nfrom the class:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nconst C();\n}</p>\n<p>[!@C!]\nvar x;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add the missing argument list:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nconst C();\n}</p>\n<p>@C()\nvar x;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#no_annotation_constructor_arguments"
    },
    {
        "key": "no_combined_super_signature",
        "name": "No combined super signature",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Can't infer missing types in '{0}' from overridden methods: {1}.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when there is a method declaration\nfor which one or more types needs to be inferred, and those types can't be\ninferred because none of the overridden methods has a function type that is\na supertype of all the other overridden methods, as specified by\n<a href=\"https://dart.dev/tools/diagnostic-messages#override-inference\">override inference</a>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the method <code>m</code> declared\nin the class <code>C</code> is missing both the return type and the type of the\nparameter <code>a</code>, and neither of the missing types can be inferred for it:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nA m(String a);\n}</p>\n<p>abstract class B {\nB m(int a);\n}</p>\n<p>abstract class C implements A, B {\n<a href=\"a\">!m!</a>;\n}\n{% endprettify %}</p>\n<p>In this example, override inference can't be performed because the\noverridden methods are incompatible in these ways:</p>\n<ul>\n<li>Neither parameter type (<code>String</code> and <code>int</code>) is a supertype of the other.</li>\n<li>Neither return type is a subtype of the other.</li>\n</ul>\n<h4>Common fixes</h4>\n<p>If possible, add types to the method in the subclass that are consistent\nwith the types from all the overridden methods:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nA m(String a);\n}</p>\n<p>abstract class B {\nB m(int a);\n}</p>\n<p>abstract class C implements A, B {\nC m(Object a);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#no_combined_super_signature"
    },
    {
        "key": "no_default_cases",
        "name": "No default cases.",
        "type": "CODE_SMELL",
        "status": "BETA",
        "severity": "MINOR",
        "description": "<p>Switches on enums and enum-like classes should not use a <code>default</code> clause.</p>\n<p>Enum-like classes are defined as concrete (non-abstract) classes that have:</p>\n<ul>\n<li>only private non-factory constructors</li>\n<li>two or more static const fields whose type is the enclosing class and</li>\n<li>no subclasses of the class in the defining library</li>\n</ul>\n<p><strong>DO</strong> define default behavior outside switch statements.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">  switch (testEnum) {\n    case TestEnum.A:\n      return '123';\n    case TestEnum.B:\n      return 'abc';\n  }\n  // Default here.\n  return null;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">  switch (testEnum) {\n    case TestEnum.A:\n      return '123';\n    case TestEnum.B:\n      return 'abc';\n    default:\n      return null;\n  }\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/no_default_cases.html"
    },
    {
        "key": "no_default_super_constructor",
        "name": "No default super constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The superclass '{0}' doesn't have a zero argument constructor.\n\nTry declaring a zero argument constructor in '{0}', or explicitly invoking a different constructor in '{0}'."
    },
    {
        "key": "no_duplicate_case_values",
        "name": "Don't use more than one case with same value.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DON'T</strong> use more than one case with same value.</p>\n<p>This is usually a typo or changed value of constant.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">const int A = 1;\nswitch (v) {\n  case A:\n  case 2:\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">const int A = 1;\nswitch (v) {\n  case 1:\n  case 2:\n  case A:\n  case 2:\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/no_duplicate_case_values.html"
    },
    {
        "key": "no_generative_constructor_in_superclass",
        "name": "No generative constructor in superclass",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The class '{0}' cannot extend '{1}' because '{1}' only has factory constructors (no generative constructors), and '{0}' has at least one generative constructor.\n\nTry implementing the class instead, adding a generative (not factory) constructor to the superclass {0}, or a factory constructor to the subclass."
    },
    {
        "key": "no_logic_in_create_state",
        "name": "Don't put any logic in createState.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DON'T</strong> put any logic in <code>createState()</code>.</p>\n<p>Implementations of  <code>createState()</code> should return a new instance\nof a State object and do nothing more.  Since state access is preferred \nvia the <code>widget</code> field,  passing data to <code>State</code> objects using custom\nconstructor parameters should also be avoided and so further, the State\nconstructor is required to be passed no arguments.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">MyState global;\n\nclass MyStateful extends StatefulWidget {\n  @override\n  MyState createState() {\n    global = MyState();\n    return global;\n  } \n}\n</code></pre>\n<pre><code class=\"language-dart\">class MyStateful extends StatefulWidget {\n  @override\n  MyState createState() =&gt; MyState()..field = 42;\n}\n</code></pre>\n<pre><code class=\"language-dart\">class MyStateful extends StatefulWidget {\n  @override\n  MyState createState() =&gt; MyState(42);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class MyStateful extends StatefulWidget {\n  @override\n  MyState createState() {\n    return MyState();\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/no_logic_in_create_state.html"
    },
    {
        "key": "no_runtimeType_toString",
        "name": "Avoid calling toString() on runtimeType.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Calling <code>toString</code> on a runtime type is a non-trivial operation that can\nnegatively impact performance. It's better to avoid it.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  String toString() =&gt; '$runtimeType()';\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  String toString() =&gt; 'A()';\n}\n</code></pre>\n<p>This lint has some exceptions where performance is not a problem or where real\ntype information is more important than performance:</p>\n<ul>\n<li>in assertion</li>\n<li>in throw expressions</li>\n<li>in catch clauses</li>\n<li>in mixin declaration</li>\n<li>in abstract class</li>\n</ul>\n\n@see https://dart-lang.github.io/linter/lints/no_runtimeType_toString.html"
    },
    {
        "key": "non_abstract_class_inherits_abstract_member",
        "name": "Non abstract class inherits abstract member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Missing concrete implementation of '{0}'.</em></p>\n<p><em>Missing concrete implementations of '{0}' and '{1}'.</em></p>\n<p><em>Missing concrete implementations of '{0}', '{1}', '{2}', '{3}', and {4} more.</em></p>\n<p><em>Missing concrete implementations of '{0}', '{1}', '{2}', and '{3}'.</em></p>\n<p><em>Missing concrete implementations of '{0}', '{1}', and '{2}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a concrete class inherits one or\nmore abstract members, and doesn't provide or inherit an implementation for\nat least one of those abstract members.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the class <code>B</code> doesn't\nhave a concrete implementation of <code>m</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nvoid m();\n}</p>\n<p>class [!B!] extends A {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the subclass can provide a concrete implementation for some or all of\nthe abstract inherited members, then add the concrete implementations:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nvoid m();\n}</p>\n<p>class B extends A {\nvoid m() {}\n}\n{% endprettify %}</p>\n<p>If there is a mixin that provides an implementation of the inherited\nmethods, then apply the mixin to the subclass:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nvoid m();\n}</p>\n<p>class B extends A with M {}</p>\n<p>mixin M {\nvoid m() {}\n}\n{% endprettify %}</p>\n<p>If the subclass can't provide a concrete implementation for all of the\nabstract inherited members, then mark the subclass as being abstract:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nvoid m();\n}</p>\n<p>abstract class B extends A {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_abstract_class_inherits_abstract_member"
    },
    {
        "key": "non_bool_condition",
        "name": "Non bool condition",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Conditions must have a static type of 'bool'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a condition, such as an <code>if</code> or\n<code>while</code> loop, doesn't have the static type <code>bool</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> has the static type\n<code>int</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int x) {\nif ([!x!]) {\n// ...\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the condition so that it produces a Boolean value:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int x) {\nif (x == 0) {\n// ...\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_bool_condition"
    },
    {
        "key": "non_bool_expression",
        "name": "Non bool expression",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The expression in an assert must be of type 'bool'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the first expression in an\nassert has a type other than <code>bool</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the type of <code>p</code> is\n<code>int</code>, but a <code>bool</code> is required:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int p) {\nassert([!p!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the expression so that it has the type <code>bool</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int p) {\nassert(p &gt; 0);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_bool_expression"
    },
    {
        "key": "non_bool_negation_expression",
        "name": "Non bool negation expression",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A negation operand must have a static type of 'bool'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the operand of the unary\nnegation operator (<code>!</code>) doesn't have the type <code>bool</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> is an <code>int</code> when it\nmust be a <code>bool</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint x = 0;\nbool y = ![!x!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the operand with an expression that has the type <code>bool</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint x = 0;\nbool y = !(x &gt; 0);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_bool_negation_expression"
    },
    {
        "key": "non_bool_operand",
        "name": "Non bool operand",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The operands of the operator '{0}' must be assignable to 'bool'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when one of the operands of either\nthe <code>&amp;&amp;</code> or <code>||</code> operator doesn't have the type <code>bool</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>a</code> isn't a Boolean\nvalue:</p>\n<p>{% prettify dart tag=pre+code %}\nint a = 3;\nbool b = [!a!] || a &gt; 1;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the operand to a Boolean value:</p>\n<p>{% prettify dart tag=pre+code %}\nint a = 3;\nbool b = a == 0 || a &gt; 1;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_bool_operand"
    },
    {
        "key": "non_const_call_to_literal_constructor",
        "name": "Non const call to literal constructor",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>This instance creation must be 'const', because the {0} constructor is marked\nas '@literal'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constructor that has the\n<code>@literal</code> annotation is invoked without using the <code>const</code> keyword, but all\nof the arguments to the constructor are constants. The annotation indicates\nthat the constructor should be used to create a constant value whenever\npossible.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>class C {\n@literal\nconst C();\n}</p>\n<p>C f() =&gt; [!C()!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add the keyword <code>const</code> before the constructor invocation:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'package:meta/meta.dart';</p>\n<p>class C {\n@literal\nconst C();\n}</p>\n<p>void f() =&gt; const C();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_const_call_to_literal_constructor"
    },
    {
        "key": "non_const_map_as_expression_statement",
        "name": "Non const map as expression statement",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "A non-constant map or set literal without type arguments can't be used as an expression statement.\n\nnull"
    },
    {
        "key": "non_constant_annotation_constructor",
        "name": "Non constant annotation constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Annotation creation can only call a const constructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an annotation is the invocation\nof an existing constructor even though the invoked constructor isn't a\nconst constructor.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the constructor for <code>C</code>\nisn't a const constructor:</p>\n<p>{% prettify dart tag=pre+code %}\n[!@C()!]\nvoid f() {\n}</p>\n<p>class C {\nC();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If it's valid for the class to have a const constructor, then create a\nconst constructor that can be used for the annotation:</p>\n<p>{% prettify dart tag=pre+code %}\n@C()\nvoid f() {\n}</p>\n<p>class C {\nconst C();\n}\n{% endprettify %}</p>\n<p>If it isn't valid for the class to have a const constructor, then either\nremove the annotation or use a different class for the annotation.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_constant_annotation_constructor"
    },
    {
        "key": "non_constant_case_expression",
        "name": "Non constant case expression",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Case expressions must be constant.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the expression in a <code>case</code>\nclause isn't a constant expression.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>j</code> isn't a constant:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int i, int j) {\nswitch (i) {\ncase [!j!]:\n// ...\nbreak;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Either make the expression a constant expression, or rewrite the <code>switch</code>\nstatement as a sequence of <code>if</code> statements:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int i, int j) {\nif (i == j) {\n// ...\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_constant_case_expression"
    },
    {
        "key": "non_constant_case_expression_from_deferred_library",
        "name": "Non constant case expression from deferred library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Constant values from a deferred library can't be used as a case expression.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the expression in a case clause\nreferences a constant from a library that is imported using a deferred\nimport. In order for switch statements to be compiled efficiently, the\nconstants referenced in case clauses need to be available at compile time,\nand constants from deferred libraries aren't available at compile time.</p>\n<p>For more information, see the language tour's coverage of\n<a href=\"https://dart.dev/guides/language/language-tour#lazily-loading-a-library\">deferred loading</a>.</p>\n<h4>Example</h4>\n<p>Given a file (<code>a.dart</code>) that defines the constant <code>zero</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nconst zero = 0;\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the library <code>a.dart</code> is\nimported using a <code>deferred</code> import, and the constant <code>a.zero</code>, declared in\nthe imported library, is used in a case clause:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' deferred as a;</p>\n<p>void f(int x) {\nswitch (x) {\ncase [!a.zero!]:\n// ...\nbreak;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to reference the constant from the imported library, then\nremove the <code>deferred</code> keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' as a;</p>\n<p>void f(int x) {\nswitch (x) {\ncase a.zero:\n// ...\nbreak;\n}\n}\n{% endprettify %}</p>\n<p>If you need to reference the constant from the imported library and also\nneed the imported library to be deferred, then rewrite the switch statement\nas a sequence of <code>if</code> statements:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' deferred as a;</p>\n<p>void f(int x) {\nif (x == a.zero) {\n// ...\n}\n}\n{% endprettify %}</p>\n<p>If you don't need to reference the constant, then replace the case\nexpression:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int x) {\nswitch (x) {\ncase 0:\n// ...\nbreak;\n}\n}\n{% endprettify %}</p>"
    },
    {
        "key": "non_constant_default_value",
        "name": "Non constant default value",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The default value of an optional parameter must be constant.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an optional parameter, either\nnamed or positional, has a default value that isn't a compile-time\nconstant.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nvar defaultValue = 3;</p>\n<p>void f([int value = [!defaultValue!]]) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the default value can be converted to be a constant, then convert it:</p>\n<p>{% prettify dart tag=pre+code %}\nconst defaultValue = 3;</p>\n<p>void f([int value = defaultValue]) {}\n{% endprettify %}</p>\n<p>If the default value needs to change over time, then apply the default\nvalue inside the function:</p>\n<p>{% prettify dart tag=pre+code %}\nvar defaultValue = 3;</p>\n<p>void f([int value]) {\nvalue ??= defaultValue;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_constant_default_value"
    },
    {
        "key": "non_constant_default_value_from_deferred_library",
        "name": "Non constant default value from deferred library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Constant values from a deferred library can't be used as a default parameter\nvalue.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the default value of an optional\nparameter uses a constant from a library imported using a deferred import.\nDefault values need to be available at compile time, and constants from\ndeferred libraries aren't available at compile time.</p>\n<p>For more information, see the language tour's coverage of\n<a href=\"https://dart.dev/guides/language/language-tour#lazily-loading-a-library\">deferred loading</a>.</p>\n<h4>Example</h4>\n<p>Given a file (<code>a.dart</code>) that defines the constant <code>zero</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nconst zero = 0;\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>zero</code> is declared in a\nlibrary imported using a deferred import:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' deferred as a;</p>\n<p>void f({int x = [!a.zero!]}) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to reference the constant from the imported library, then\nremove the <code>deferred</code> keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' as a;</p>\n<p>void f({int x = a.zero}) {}\n{% endprettify %}</p>\n<p>If you don't need to reference the constant, then replace the default\nvalue:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f({int x = 0}) {}\n{% endprettify %}</p>"
    },
    {
        "key": "non_constant_identifier_names",
        "name": "Name non-constant identifiers using lowerCamelCase.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> name non-constant identifiers using lowerCamelCase.</p>\n<p>Class members, top-level definitions, variables, parameters, named parameters\nand named constructors should capitalize the first letter of each word\nexcept the first word, and use no separators.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var item;\n\nHttpRequest httpRequest;\n\nalign(clearItems) {\n  // ...\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/non_constant_identifier_names.html"
    },
    {
        "key": "non_constant_list_element",
        "name": "Non constant list element",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The values in a const list literal must be constants.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an element in a constant list\nliteral isn't a constant value. The list literal can be constant either\nexplicitly (because it's prefixed by the <code>const</code> keyword) or implicitly\n(because it appears in a <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a>).</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> isn't a constant,\neven though it appears in an implicitly constant list literal:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x = 2;\nvar y = const <int>[0, 1, [!x!]];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the list needs to be a constant list, then convert the element to be a\nconstant. In the example above, you might add the <code>const</code> keyword to the\ndeclaration of <code>x</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nconst x = 2;\nvar y = const <int>[0, 1, x];\n{% endprettify %}</p>\n<p>If the expression can't be made a constant, then the list can't be a\nconstant either, so you must change the code so that the list isn't a\nconstant. In the example above this means removing the <code>const</code> keyword\nbefore the list literal:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x = 2;\nvar y = <int>[0, 1, x];\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_constant_list_element"
    },
    {
        "key": "non_constant_map_element",
        "name": "Non constant map element",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The elements in a const map literal must be constant.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an <code>if</code> element or a spread\nelement in a constant map isn't a constant element.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because it's attempting to\nspread a non-constant map:</p>\n<p>{% prettify dart tag=pre+code %}\nvar notConst = &lt;int, int&gt;{};\nvar map = const &lt;int, int&gt;{...[!notConst!]};\n{% endprettify %}</p>\n<p>Similarly, the following code produces this diagnostic because the\ncondition in the <code>if</code> element isn't a constant expression:</p>\n<p>{% prettify dart tag=pre+code %}\nbool notConst = true;\nvar map = const &lt;int, int&gt;{if ([!notConst!]) 1 : 2};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the map needs to be a constant map, then make the elements constants.\nIn the spread example, you might do that by making the collection being\nspread a constant:</p>\n<p>{% prettify dart tag=pre+code %}\nconst notConst = &lt;int, int&gt;{};\nvar map = const &lt;int, int&gt;{...notConst};\n{% endprettify %}</p>\n<p>If the map doesn't need to be a constant map, then remove the <code>const</code>\nkeyword:</p>\n<p>{% prettify dart tag=pre+code %}\nbool notConst = true;\nvar map = &lt;int, int&gt;{if (notConst) 1 : 2};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_constant_map_element"
    },
    {
        "key": "non_constant_map_key",
        "name": "Non constant map key",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The keys in a const map literal must be constant.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a key in a constant map literal\nisn't a constant value.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic beause <code>a</code> isn't a constant:</p>\n<p>{% prettify dart tag=pre+code %}\nvar a = 'a';\nvar m = const {[!a!]: 0};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the map needs to be a constant map, then make the key a constant:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = 'a';\nvar m = const {a: 0};\n{% endprettify %}</p>\n<p>If the map doesn't need to be a constant map, then remove the <code>const</code>\nkeyword:</p>\n<p>{% prettify dart tag=pre+code %}\nvar a = 'a';\nvar m = {a: 0};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_constant_map_key"
    },
    {
        "key": "non_constant_map_value",
        "name": "Non constant map value",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The values in a const map literal must be constant.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a value in a constant map\nliteral isn't a constant value.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>a</code> isn't a constant:</p>\n<p>{% prettify dart tag=pre+code %}\nvar a = 'a';\nvar m = const {0: [!a!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the map needs to be a constant map, then make the key a constant:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = 'a';\nvar m = const {0: a};\n{% endprettify %}</p>\n<p>If the map doesn't need to be a constant map, then remove the <code>const</code>\nkeyword:</p>\n<p>{% prettify dart tag=pre+code %}\nvar a = 'a';\nvar m = {0: a};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_constant_map_value"
    },
    {
        "key": "non_constant_set_element",
        "name": "Non constant set element",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The values in a const set literal must be constants.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constant set literal contains\nan element that isn't a compile-time constant.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>i</code> isn't a constant:</p>\n<p>{% prettify dart tag=pre+code %}\nvar i = 0;</p>\n<p>var s = const {[!i!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the element can be changed to be a constant, then change it:</p>\n<p>{% prettify dart tag=pre+code %}\nconst i = 0;</p>\n<p>var s = const {i};\n{% endprettify %}</p>\n<p>If the element can't be a constant, then remove the keyword <code>const</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvar i = 0;</p>\n<p>var s = {i};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_constant_set_element"
    },
    {
        "key": "non_generative_constructor",
        "name": "Non generative constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The constructor '{0}' is a factory constructor, but must be a generative constructor to be a valid superinitializer.\n\nTry calling a different constructor of the superclass, or making the called constructor not be a factory constructor."
    },
    {
        "key": "non_generative_implicit_constructor",
        "name": "Non generative implicit constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The default constructor of superclass '{0}' (called by the implicit default constructor of '{1}') must be a generative constructor, but factory found.\n\nTry adding an explicit constructor that has a different superinitializer or changing the superclass constructor '{2}' to not be a factory constructor."
    },
    {
        "key": "non_sync_factory",
        "name": "Non sync factory",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Factory bodies can't use 'async', 'async*', or 'sync*'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the body of a factory\nconstructor is marked with <code>async</code>, <code>async*</code>, or <code>sync*</code>. All constructors,\nincluding factory constructors, are required to return an instance of the\nclass in which they're declared, not a <code>Future</code>, <code>Stream</code>, or <code>Iterator</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the body of the factory\nconstructor is marked with <code>async</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfactory C() [!async!] {\nreturn C.<em>();\n  }\n  C.</em>();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the member must be declared as a factory constructor, then remove the\nkeyword appearing before the body:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfactory C() {\nreturn C.<em>();\n  }\n  C.</em>();\n}\n{% endprettify %}</p>\n<p>If the member must return something other than an instance of the enclosing\nclass, then make the member a static method:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic Future<C> m() async {\nreturn C.<em>();\n  }\n  C.</em>();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_sync_factory"
    },
    {
        "key": "non_type_as_type_argument",
        "name": "Non type as type argument",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' isn't a type so it can't be used as a type argument.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an identifier that isn't a type\nis used as a type argument.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> is a variable, not\na type:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x = 0;\nList&lt;[!x!]&gt; xList = [];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the type argument to be a type:</p>\n<p>{% prettify dart tag=pre+code %}\nvar x = 0;\nList<int> xList = [];\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_type_as_type_argument"
    },
    {
        "key": "non_type_in_catch_clause",
        "name": "Non type in catch clause",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' isn't a type and can't be used in an on-catch clause.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the identifier following the\n<code>on</code> in a <code>catch</code> clause is defined to be something other than a type.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> is a function, not\na type:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n// ...\n} on [!f!] {\n// ...\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the name to the type of object that should be caught:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n// ...\n} on FormatException {\n// ...\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#non_type_in_catch_clause"
    },
    {
        "key": "non_void_return_for_operator",
        "name": "Non void return for operator",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The return type of the operator []= must be 'void'.\n\nTry changing the return type to 'void'."
    },
    {
        "key": "non_void_return_for_setter",
        "name": "Non void return for setter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The return type of the setter must be 'void' or absent.\n\nTry removing the return type, or define a method rather than a setter."
    },
    {
        "key": "not_a_type",
        "name": "Not a type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>{0} isn't a type.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a name is used as a type but\ndeclared to be something other than a type.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> is a function:</p>\n<p>{% prettify dart tag=pre+code %}\nf() {}\ng([!f!] v) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the name with the name of a type.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#not_a_type"
    },
    {
        "key": "not_assigned_potentially_non_nullable_local_variable",
        "name": "Not assigned potentially non nullable local variable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The non-nullable local variable '{0}' must be assigned before it can be used.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a local variable is referenced\nand has all these characteristics:</p>\n<ul>\n<li>Has a type that's <a href=\"https://dart.dev/tools/diagnostic-messages#potentially-non-nullable\">potentially non-nullable</a>.</li>\n<li>Doesn't have an initializer.</li>\n<li>Isn't marked as <code>late</code>.</li>\n<li>The analyzer can't prove that the local variable will be assigned before\nthe reference based on the specification of [definite assignment.][]</li>\n</ul>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>x</code> can't have a value\nof <code>null</code>, but is referenced before a value was assigned to it:</p>\n<p>{% prettify dart tag=pre+code %}\nString f() {\nint x;\nreturn [!x!].toString();\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the assignment to <code>x</code>\nmight not be executed, so it might have a value of <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint g(bool b) {\nint x;\nif (b) {\nx = 1;\n}\nreturn [!x!] * 2;\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the analyzer can't\nprove, based on definite assignment analysis, that <code>x</code> won't be referenced\nwithout having a value assigned to it:</p>\n<p>{% prettify dart tag=pre+code %}\nint h(bool b) {\nint x;\nif (b) {\nx = 1;\n}\nif (b) {\nreturn [!x!] * 2;\n}\nreturn 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If <code>null</code> is a valid value, then make the variable nullable:</p>\n<p>{% prettify dart tag=pre+code %}\nString f() {\nint? x;\nreturn x!.toString();\n}\n{% endprettify %}</p>\n<p>If <code>null</code> isnâ€™t a valid value, and there's a reasonable default value, then\nadd an initializer:</p>\n<p>{% prettify dart tag=pre+code %}\nint g(bool b) {\nint x = 2;\nif (b) {\nx = 1;\n}\nreturn x * 2;\n}\n{% endprettify %}</p>\n<p>Otherwise, ensure that a value was assigned on every possible code path\nbefore the value is accessed:</p>\n<p>{% prettify dart tag=pre+code %}\nint g(bool b) {\nint x;\nif (b) {\nx = 1;\n} else {\nx = 2;\n}\nreturn x * 2;\n}\n{% endprettify %}</p>\n<p>You can also mark the variable as <code>late</code>, which removes the diagnostic, but\nif the variable isn't assigned a value before it's accessed, then it\nresults in an exception being thrown at runtime. This approach should only\nbe used if you're sure that the variable will always be assigned, even\nthough the analyzer can't prove it based on definite assignment analysis.</p>\n<p>{% prettify dart tag=pre+code %}\nint h(bool b) {\nlate int x;\nif (b) {\nx = 1;\n}\nif (b) {\nreturn x * 2;\n}\nreturn 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#not_assigned_potentially_non_nullable_local_variable"
    },
    {
        "key": "not_enough_positional_arguments",
        "name": "Not enough positional arguments",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>{0} positional argument(s) expected, but {1} found.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a method or function invocation\nhas fewer positional arguments than the number of required positional\nparameters.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> declares two\nrequired parameters, but only one argument is provided:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int a, int b) {}\nvoid g() {\nf[!(0)!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add arguments corresponding to the remaining parameters:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int a, int b) {}\nvoid g() {\nf(0, 1);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#not_enough_positional_arguments"
    },
    {
        "key": "not_initialized_non_nullable_instance_field",
        "name": "Not initialized non nullable instance field",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Non-nullable instance field '{0}' must be initialized.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a field is declared and has all\nthese characteristics:</p>\n<ul>\n<li>Has a type that's <a href=\"https://dart.dev/tools/diagnostic-messages#potentially-non-nullable\">potentially non-nullable</a></li>\n<li>Doesn't have an initializer</li>\n<li>Isn't marked as <code>late</code></li>\n</ul>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>x</code> is implicitly\ninitialized to <code>null</code> when it isn't allowed to be <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint [!x!];\n}\n{% endprettify %}</p>\n<p>Similarly, the following code produces this diagnostic because <code>x</code> is\nimplicitly initialized to <code>null</code>, when it isn't allowed to be <code>null</code>, by\none of the constructors, even though it's initialized by other\nconstructors:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>C(this.x);</p>\n<p>[!C!].n();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If there's a reasonable default value for the field thatâ€™s the same for all\ninstances, then add an initializer expression:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x = 0;\n}\n{% endprettify %}</p>\n<p>If the value of the field should be provided when an instance is created,\nthen add a constructor that sets the value of the field or update an\nexisting constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x;</p>\n<p>C(this.x);\n}\n{% endprettify %}</p>\n<p>You can also mark the field as <code>late</code>, which removes the diagnostic, but if\nthe field isn't assigned a value before it's accessed, then it results in\nan exception being thrown at runtime. This approach should only be used if\nyou're sure that the field will always be assigned before it's referenced.</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nlate int x;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#not_initialized_non_nullable_instance_field"
    },
    {
        "key": "not_initialized_non_nullable_variable",
        "name": "Not initialized non nullable variable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The non-nullable variable '{0}' must be initialized.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a static field or top-level\nvariable has a type that's non-nullable and doesn't have an initializer.\nFields and variables that don't have an initializer are normally\ninitialized to <code>null</code>, but the type of the field or variable doesn't allow\nit to be set to <code>null</code>, so an explicit initializer must be provided.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the field <code>f</code> can't be\ninitialized to <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic int [!f!];\n}\n{% endprettify %}</p>\n<p>Similarly, the following code produces this diagnostic because the\ntop-level variable <code>v</code> can't be initialized to <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint [!v!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the field or variable can't be initialized to <code>null</code>, then add an\ninitializer that sets it to a non-null value:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic int f = 0;\n}\n{% endprettify %}</p>\n<p>If the field or variable should be initialized to <code>null</code>, then change the\ntype to be nullable:</p>\n<p>{% prettify dart tag=pre+code %}\nint? v;\n{% endprettify %}</p>\n<p>If the field or variable can't be initialized in the declaration but will\nalways be initialized before it's referenced, then mark it as being <code>late</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic late int f;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#not_initialized_non_nullable_variable"
    },
    {
        "key": "not_instantiated_bound",
        "name": "Not instantiated bound",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Type parameter bound types must be instantiated.\n\nTry adding type arguments to the type parameter bound."
    },
    {
        "key": "not_iterable_spread",
        "name": "Not iterable spread",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Spread elements in list or set literals must implement 'Iterable'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the static type of the\nexpression of a spread element that appears in either a list literal or a\nset literal doesn't implement the type <code>Iterable</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = &lt;String, int&gt;{'a': 0, 'b': 1};\nvar s = <String>{...[!m!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>The most common fix is to replace the expression with one that produces an\niterable object:</p>\n<p>{% prettify dart tag=pre+code %}\nvar m = &lt;String, int&gt;{'a': 0, 'b': 1};\nvar s = <String>{...m.keys};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#not_iterable_spread"
    },
    {
        "key": "not_map_spread",
        "name": "Not map spread",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Spread elements in map literals must implement 'Map'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the static type of the\nexpression of a spread element that appears in a map literal doesn't\nimplement the type <code>Map</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>l</code> isn't a <code>Map</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvar l =  <String>['a', 'b'];\nvar m = &lt;int, String&gt;{...[!l!]};\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>The most common fix is to replace the expression with one that produces a\nmap:</p>\n<p>{% prettify dart tag=pre+code %}\nvar l =  <String>['a', 'b'];\nvar m = &lt;int, String&gt;{...l.asMap()};\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#not_map_spread"
    },
    {
        "key": "not_null_aware_null_spread",
        "name": "Not null aware null spread",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The Null typed expression can't be used with a non-null-aware spread.\n\nnull"
    },
    {
        "key": "null_aware_before_operator",
        "name": "Null aware before operator",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The left operand uses '?.', so its value can be null.\n\nnull"
    },
    {
        "key": "null_aware_in_condition",
        "name": "Null aware in condition",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The value of the '?.' operator can be 'null', which isn't appropriate in a condition.\n\nTry replacing the '?.' with a '.', testing the left-hand side for null if necessary."
    },
    {
        "key": "null_aware_in_logical_operator",
        "name": "Null aware in logical operator",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The value of the '?.' operator can be 'null', which isn't appropriate as an operand of a logical operator.\n\nnull"
    },
    {
        "key": "null_check_always_fails",
        "name": "Null check always fails",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "This null-check will always throw an exception because the expression will always evaluate to 'null'.\n\nnull"
    },
    {
        "key": "null_check_on_nullable_type_parameter",
        "name": "Don't use null check on a potentially nullable type parameter.",
        "type": "CODE_SMELL",
        "status": "BETA",
        "severity": "MINOR",
        "description": "<p>Don't use null check on a potentially nullable type parameter.</p>\n<p>Given a generic type parameter <code>T</code> which has a nullable bound (e.g. the default\nbound of <code>Object?</code>), it is very easy to introduce erroneous null checks when\nworking with a variable of type <code>T?</code>. Specifically, it is not uncommon to have\n<code>T? x;</code> and want to assert that <code>x</code> has been set to a valid value of type <code>T</code>.\nA common mistake is to do so using <code>x!</code>. This is almost always incorrect, since\nif <code>T</code> is a nullable type, <code>x</code> may validly hold <code>null</code> as a value of type <code>T</code>.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">T run&lt;T&gt;(T callback()) {\n  T? result;\n   (() { result = callback(); })();\n  return result!;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">T run&lt;T&gt;(T callback()) {\n  T? result;\n   (() { result = callback(); })();\n  return result as T;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/null_check_on_nullable_type_parameter.html"
    },
    {
        "key": "null_closures",
        "name": "Do not pass `null` as an argument where a closure is expected.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO NOT</strong> pass null as an argument where a closure is expected.</p>\n<p>Often a closure that is passed to a method will only be called conditionally,\nso that tests and \"happy path\" production calls do not reveal that <code>null</code> will\nresult in an exception being thrown.</p>\n<p>This rule only catches null literals being passed where closures are expected\nin the following locations:</p>\n<h4>Constructors</h4>\n<ul>\n<li>From <code>dart:async</code>\n<ul>\n<li><code>Future</code> at the 0th positional parameter</li>\n<li><code>Future.microtask</code> at the 0th positional parameter</li>\n<li><code>Future.sync</code> at the 0th positional parameter</li>\n<li><code>Timer</code> at the 0th positional parameter</li>\n<li><code>Timer.periodic</code> at the 1st positional parameter</li>\n</ul>\n</li>\n<li>From <code>dart:core</code>\n<ul>\n<li><code>List.generate</code> at the 1st positional parameter</li>\n</ul>\n</li>\n</ul>\n<h4>Static functions</h4>\n<ul>\n<li>From <code>dart:async</code>\n<ul>\n<li><code>scheduleMicrotask</code> at the 0th positional parameter</li>\n<li><code>Future.doWhile</code> at the 0th positional parameter</li>\n<li><code>Future.forEach</code> at the 0th positional parameter</li>\n<li><code>Future.wait</code> at the named parameter <code>cleanup</code></li>\n<li><code>Timer.run</code> at the 0th positional parameter</li>\n</ul>\n</li>\n</ul>\n<h4>Instance methods</h4>\n<ul>\n<li>From <code>dart:async</code>\n<ul>\n<li><code>Future.then</code> at the 0th positional parameter</li>\n<li><code>Future.complete</code> at the 0th positional parameter</li>\n</ul>\n</li>\n<li>From <code>dart:collection</code>\n<ul>\n<li><code>Queue.removeWhere</code> at the 0th positional parameter</li>\n<li>`Queue.retain</li>\n<li><code>Iterable.firstWhere</code> at the 0th positional parameter, and the named\nparameter <code>orElse</code></li>\n<li><code>Iterable.forEach</code> at the 0th positional parameter</li>\n<li><code>Iterable.fold</code> at the 1st positional parameter</li>\n<li><code>Iterable.lastWhere</code> at the 0th positional parameter, and the named\nparameter <code>orElse</code></li>\n<li><code>Iterable.map</code> at the 0th positional parameter</li>\n<li><code>Iterable.reduce</code> at the 0th positional parameter</li>\n<li><code>Iterable.singleWhere</code> at the 0th positional parameter, and the named\nparameter <code>orElse</code></li>\n<li><code>Iterable.skipWhile</code> at the 0th positional parameter</li>\n<li><code>Iterable.takeWhile</code> at the 0th positional parameter</li>\n<li><code>Iterable.where</code> at the 0th positional parameter</li>\n<li><code>List.removeWhere</code> at the 0th positional parameter</li>\n<li><code>List.retainWhere</code> at the 0th positional parameter</li>\n<li><code>String.replaceAllMapped</code> at the 1st positional parameter</li>\n<li><code>String.replaceFirstMapped</code> at the 1st positional parameter</li>\n<li><code>String.splitMapJoin</code> at the named parameters <code>onMatch</code> and <code>onNonMatch</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">[1, 3, 5].firstWhere((e) =&gt; e.isOdd, orElse: null);\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">[1, 3, 5].firstWhere((e) =&gt; e.isOdd, orElse: () =&gt; null);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/null_closures.html"
    },
    {
        "key": "nullable_type_in_catch_clause",
        "name": "Nullable type in catch clause",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>A potentially nullable type can't be used in an 'on' clause because it isn't\nvalid to throw a nullable expression.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the type following <code>on</code> in a\n<code>catch</code> clause is a nullable type. It isn't valid to specify a nullable\ntype because it isn't possible to catch <code>null</code> (because it's a runtime\nerror to throw <code>null</code>).</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the exception type is\nspecified to allow <code>null</code> when <code>null</code> can't be thrown:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n// ...\n} on [!FormatException?!] {\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the question mark from the type:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n// ...\n} on FormatException {\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#nullable_type_in_catch_clause"
    },
    {
        "key": "nullable_type_in_extends_clause",
        "name": "Nullable type in extends clause",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A class can't extend a nullable type.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class declaration uses an\n<code>extends</code> clause to specify a superclass, and the superclass is followed by\na <code>?</code>.</p>\n<p>It isn't valid to specify a nullable superclass because doing so would have\nno meaning; it wouldn't change either the interface or implementation being\ninherited by the class containing the <code>extends</code> clause.</p>\n<p>Note, however, that it <em>is</em> valid to use a nullable type as a type argument\nto the superclass, such as <code>class A extends B&lt;C?&gt; {}</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>A?</code> is a nullable\ntype, and nullable types can't be used in an <code>extends</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}\nclass B extends [!A?!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the question mark from the type:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}\nclass B extends A {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#nullable_type_in_extends_clause"
    },
    {
        "key": "nullable_type_in_implements_clause",
        "name": "Nullable type in implements clause",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A class or mixin can't implement a nullable type.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class or mixin declaration has\nan <code>implements</code> clause, and an interface is followed by a <code>?</code>.</p>\n<p>It isn't valid to specify a nullable interface because doing so would have\nno meaning; it wouldn't change the interface being inherited by the class\ncontaining the <code>implements</code> clause.</p>\n<p>Note, however, that it <em>is</em> valid to use a nullable type as a type argument\nto the interface, such as <code>class A implements B&lt;C?&gt; {}</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>A?</code> is a nullable\ntype, and nullable types can't be used in an <code>implements</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}\nclass B implements [!A?!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the question mark from the type:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}\nclass B implements A {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#nullable_type_in_implements_clause"
    },
    {
        "key": "nullable_type_in_on_clause",
        "name": "Nullable type in on clause",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A mixin can't have a nullable type as a superclass constraint.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a mixin declaration uses an <code>on</code>\nclause to specify a superclass constraint, and the class that's specified\nis followed by a <code>?</code>.</p>\n<p>It isn't valid to specify a nullable superclass constraint because doing so\nwould have no meaning; it wouldn't change the interface being depended on\nby the mixin containing the <code>on</code> clause.</p>\n<p>Note, however, that it <em>is</em> valid to use a nullable type as a type argument\nto the superclass constraint, such as <code>mixin A on B&lt;C?&gt; {}</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>A?</code> is a nullable type\nand nullable types can't be used in an <code>on</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}\nmixin M on [!C?!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the question mark from the type:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}\nmixin M on C {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#nullable_type_in_on_clause"
    },
    {
        "key": "nullable_type_in_with_clause",
        "name": "Nullable type in with clause",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A class or mixin can't mix in a nullable type.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class or mixin declaration has\na <code>with</code> clause, and a mixin is followed by a <code>?</code>.</p>\n<p>It isn't valid to specify a nullable mixin because doing so would have no\nmeaning; it wouldn't change either the interface or implementation being\ninherited by the class containing the <code>with</code> clause.</p>\n<p>Note, however, that it <em>is</em> valid to use a nullable type as a type argument\nto the mixin, such as <code>class A with B&lt;C?&gt; {}</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>A?</code> is a nullable\ntype, and nullable types can't be used in a <code>with</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nmixin M {}\nclass C with [!M?!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the question mark from the type:</p>\n<p>{% prettify dart tag=pre+code %}\nmixin M {}\nclass C with M {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#nullable_type_in_with_clause"
    },
    {
        "key": "object_cannot_extend_another_class",
        "name": "Object cannot extend another class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The class 'Object' can't extend any other class.\n\nnull"
    },
    {
        "key": "omit_local_variable_types",
        "name": "Omit type annotations for local variables.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>CONSIDER</strong> omitting type annotations for local variables.</p>\n<p>Usually, the types of local variables can be easily inferred, so it isn't\nnecessary to annotate them.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Map&lt;int, List&lt;Person&gt;&gt; groupByZip(Iterable&lt;Person&gt; people) {\n  Map&lt;int, List&lt;Person&gt;&gt; peopleByZip = &lt;int, List&lt;Person&gt;&gt;{};\n  for (Person person in people) {\n    peopleByZip.putIfAbsent(person.zip, () =&gt; &lt;Person&gt;[]);\n    peopleByZip[person.zip].add(person);\n  }\n  return peopleByZip;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Map&lt;int, List&lt;Person&gt;&gt; groupByZip(Iterable&lt;Person&gt; people) {\n  var peopleByZip = &lt;int, List&lt;Person&gt;&gt;{};\n  for (var person in people) {\n    peopleByZip.putIfAbsent(person.zip, () =&gt; &lt;Person&gt;[]);\n    peopleByZip[person.zip].add(person);\n  }\n  return peopleByZip;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/omit_local_variable_types.html"
    },
    {
        "key": "on_repeated",
        "name": "On repeated",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The type '{0}' can be included in the superclass constraints only once.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the same type is listed in the\nsuperclass constraints of a mixin multiple times.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>A</code> is included twice\nin the superclass constraints for <code>M</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nmixin M on A, [!A!] {\n}</p>\n<p>class A {}\nclass B {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If a different type should be included in the superclass constraints, then\nreplace one of the occurrences with the other type:</p>\n<p>{% prettify dart tag=pre+code %}\nmixin M on A, B {\n}</p>\n<p>class A {}\nclass B {}\n{% endprettify %}</p>\n<p>If no other type was intended, then remove the repeated type name:</p>\n<p>{% prettify dart tag=pre+code %}\nmixin M on A {\n}</p>\n<p>class A {}\nclass B {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#on_repeated"
    },
    {
        "key": "one_member_abstracts",
        "name": "Avoid defining a one-member abstract class when a simple function will do.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</a>:</p>\n<p><strong>AVOID</strong> defining a one-member abstract class when a simple function will do.</p>\n<p>Unlike Java, Dart has first-class functions, closures, and a nice light syntax\nfor using them.  If all you need is something like a callback, just use a\nfunction.  If you're defining a class and it only has a single abstract member\nwith a meaningless name like <code>call</code> or <code>invoke</code>, there is a good chance\nyou just want a function.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">typedef Predicate = bool Function(item);\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">abstract class Predicate {\n  bool test(item);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/one_member_abstracts.html"
    },
    {
        "key": "only_throw_errors",
        "name": "Only throw instances of classes extending either Exception or Error.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> throw only instances of classes that extend <code>dart.core.Error</code> or\n<code>dart.core.Exception</code>.</p>\n<p>Throwing instances that do not extend <code>Error</code> or <code>Exception</code> is a bad practice;\ndoing this is usually a hack for something that should be implemented more\nthoroughly.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void throwString() {\n  throw 'hello world!'; // LINT\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void throwArgumentError() {\n  Error error = ArgumentError('oh!');\n  throw error; // OK\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/only_throw_errors.html"
    },
    {
        "key": "optional_parameter_in_operator",
        "name": "Optional parameter in operator",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Optional parameters aren't allowed when defining an operator.\n\nTry removing the optional parameters."
    },
    {
        "key": "overridden_fields",
        "name": "Don't override fields.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> override fields.</p>\n<p>Overriding fields is almost always done unintentionally.  Regardless, it is a\nbad practice to do so.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Base {\n  Object field = 'lorem';\n\n  Object something = 'change';\n}\n\nclass Bad1 extends Base {\n  @override\n  final field = 'ipsum'; // LINT\n}\n\nclass Bad2 extends Base {\n  @override\n  Object something = 'done'; // LINT\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Base {\n  Object field = 'lorem';\n\n  Object something = 'change';\n}\n\nclass Ok extends Base {\n  Object newField; // OK\n\n  final Object newFinal = 'ignore'; // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">abstract class BaseLoggingHandler {\n  Base transformer;\n}\n\nclass LogPrintHandler implements BaseLoggingHandler {\n  @override\n  Derived transformer; // OK\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/overridden_fields.html"
    },
    {
        "key": "override_on_non_overriding_member",
        "name": "Override on non overriding member",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The field doesn't override an inherited getter or setter.</em></p>\n<p><em>The getter doesn't override an inherited getter.</em></p>\n<p><em>The method doesn't override an inherited method.</em></p>\n<p><em>The setter doesn't override an inherited setter.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class member is annotated with\nthe <code>@override</code> annotation, but the member isnâ€™t declared in any of the\nsupertypes of the class.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>m</code> isn't declared in\nany of the supertypes of <code>C</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\n@override\nString <a href=\"\">!m!</a> =&gt; '';\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the member is intended to override a member with a different name, then\nupdate the member to have the same name:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\n@override\nString toString() =&gt; '';\n}\n{% endprettify %}</p>\n<p>If the member is intended to override a member that was removed from the\nsuperclass, then consider removing the member from the subclass.</p>\n<p>If the member can't be removed, then remove the annotation.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#override_on_non_overriding_member"
    },
    {
        "key": "package_api_docs",
        "name": "Provide doc comments for all public APIs.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> provide doc comments for all public APIs.</p>\n<p>As described in the <a href=\"https://dart.dev/tools/pub/package-layout#implementation-files\">pub package layout doc</a>,\npublic APIs consist in everything in your package's <code>lib</code> folder, minus\nimplementation files in <code>lib/src</code>, adding elements explicitly exported with an\n<code>export</code> directive.</p>\n<p>For example, given <code>lib/foo.dart</code>:</p>\n<pre><code class=\"language-dart\">export 'src/bar.dart' show Bar;\nexport 'src/baz.dart';\n\nclass Foo { }\n\nclass _Foo { }\n</code></pre>\n<p>its API includes:</p>\n<ul>\n<li><code>Foo</code> (but not <code>_Foo</code>)</li>\n<li><code>Bar</code> (exported) and</li>\n<li>all <em>public</em> elements in <code>src/baz.dart</code></li>\n</ul>\n<p>All public API members should be documented with <code>///</code> doc-style comments.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">/// A Foo.\nabstract class Foo {\n  /// Start foo-ing.\n  void start() =&gt; _start();\n\n  _start();\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Bar {\n  void bar();\n}\n</code></pre>\n<p>Advice for writing good doc comments can be found in the\n<a href=\"https://dart.dev/guides/language/effective-dart/documentation\">Doc Writing Guidelines</a>.</p>\n\n@see https://dart-lang.github.io/linter/lints/package_api_docs.html"
    },
    {
        "key": "package_import_contains_dot_dot",
        "name": "Package import contains dot dot",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "A package import shouldn't contain '..'.\n\nnull"
    },
    {
        "key": "package_names",
        "name": "Use `lowercase_with_underscores` for package names.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/tools/pub/pubspec\">Pubspec format description</a>:</p>\n<p><strong>DO</strong> use <code>lowercase_with_underscores</code> for package names.</p>\n<p>Package names should be all lowercase, with underscores to separate words,\n<code>just_like_this</code>.  Use only basic Latin letters and Arabic digits: [a-z0-9_].\nAlso, make sure the name is a valid Dart identifier -- that it doesn't start\nwith digits and isn't a reserved word.</p>\n\n@see https://dart-lang.github.io/linter/lints/package_names.html"
    },
    {
        "key": "package_prefixed_library_names",
        "name": "Prefix library names with the package name and a dot-separated path.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> prefix library names with the package name and a dot-separated path.</p>\n<p>This guideline helps avoid the warnings you get when two libraries have the same\nname.  Here are the rules we recommend:</p>\n<ul>\n<li>Prefix all library names with the package name.</li>\n<li>Make the entry library have the same name as the package.</li>\n<li>For all other libraries in a package, after the package name add the\ndot-separated path to the library's Dart file.</li>\n<li>For libraries under <code>lib</code>, omit the top directory name.</li>\n</ul>\n<p>For example, say the package name is <code>my_package</code>.  Here are the library names\nfor various files in the package:</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">// In lib/my_package.dart\nlibrary my_package;\n\n// In lib/other.dart\nlibrary my_package.other;\n\n// In lib/foo/bar.dart\nlibrary my_package.foo.bar;\n\n// In example/foo/bar.dart\nlibrary my_package.example.foo.bar;\n\n// In lib/src/private.dart\nlibrary my_package.src.private;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/package_prefixed_library_names.html"
    },
    {
        "key": "parameter_assignments",
        "name": "Don't reassign references to parameters of functions or methods.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> assign new values to parameters of methods or functions.</p>\n<p>Assigning new values to parameters is generally a bad practice unless an\noperator such as <code>??=</code> is used.  Otherwise, arbitrarily reassigning parameters\nis usually a mistake.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void badFunction(int parameter) { // LINT\n  parameter = 4;\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void badFunction(int required, {int optional: 42}) { // LINT\n  optional ??= 8;\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void badFunctionPositional(int required, [int optional = 42]) { // LINT\n  optional ??= 8;\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n    void badMethod(int parameter) { // LINT\n    parameter = 4;\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void ok(String parameter) {\n  print(parameter);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void actuallyGood(int required, {int optional}) { // OK\n  optional ??= ...;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void actuallyGoodPositional(int required, [int optional]) { // OK\n  optional ??= ...;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  void ok(String parameter) {\n    print(parameter);\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/parameter_assignments.html"
    },
    {
        "key": "part_of_different_library",
        "name": "Part of different library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Expected this library to be part of '{0}', not '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a library attempts to include a\nfile as a part of itself when the other file is a part of a different\nlibrary.</p>\n<h4>Example</h4>\n<p>Given a file named <code>part.dart</code> containing</p>\n<p>{% prettify dart tag=pre+code %}\npart of 'library.dart';\n{% endprettify %}</p>\n<p>The following code, in any file other than <code>library.dart</code>, produces this\ndiagnostic because it attempts to include <code>part.dart</code> as a part of itself\nwhen <code>part.dart</code> is a part of a different library:</p>\n<p>{% prettify dart tag=pre+code %}\npart [!'package:a/part.dart'!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the library should be using a different file as a part, then change the\nURI in the part directive to be the URI of the other file.</p>\n<p>If the part file should be a part of this library, then update the URI (or\nlibrary name) in the part-of directive to be the URI (or name) of the\ncorrect library.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#part_of_different_library"
    },
    {
        "key": "part_of_non_part",
        "name": "Part of non part",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The included part '{0}' must have a part-of directive.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a part directive is found and\nthe referenced file doesn't have a part-of directive.</p>\n<h4>Examples</h4>\n<p>Given a file (<code>a.dart</code>) containing:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>a.dart</code> doesn't\ncontain a part-of directive:</p>\n<p>{% prettify dart tag=pre+code %}\npart [!'a.dart'!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the referenced file is intended to be a part of another library, then\nadd a part-of directive to the file:</p>\n<p>{% prettify dart tag=pre+code %}\npart of 'test.dart';</p>\n<p>class A {}\n{% endprettify %}</p>\n<p>If the referenced file is intended to be a library, then replace the part\ndirective with an import directive:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart';\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#part_of_non_part"
    },
    {
        "key": "part_of_unnamed_library",
        "name": "Part of unnamed library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Library is unnamed. Expected a URI not a library name '{0}' in the part-of directive.\n\nTry changing the part-of directive to a URI, or try including a different part."
    },
    {
        "key": "path_does_not_exist",
        "name": "Path does not exist",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The path {0} does not exist.\n\nTry creating the referenced path or using a path that exists."
    },
    {
        "key": "path_pubspec_does_not_exist",
        "name": "Path pubspec does not exist",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The directory {0} does not contain a pubspec.\n\nTry creating a pubspec in the referenced directory or using a path that has a pubspec."
    },
    {
        "key": "prefer_adjacent_string_concatenation",
        "name": "Use adjacent strings to concatenate string literals.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use adjacent strings to concatenate string literals.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">raiseAlarm(\n    'ERROR: Parts of the spaceship are on fire. Other ' +\n    'parts are overrun by martians. Unclear which are which.');\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">raiseAlarm(\n    'ERROR: Parts of the spaceship are on fire. Other '\n    'parts are overrun by martians. Unclear which are which.');\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_adjacent_string_concatenation.html"
    },
    {
        "key": "prefer_asserts_in_initializer_lists",
        "name": "Prefer putting asserts in initializer list.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> put asserts in initializer list for constructors with only asserts in\ntheir body.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  A(int a) : assert(a != null);\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  A(int a) {\n    assert(a != null);\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_asserts_in_initializer_lists.html"
    },
    {
        "key": "prefer_asserts_with_message",
        "name": "Prefer asserts with message.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>When assertions fail it's not always simple to understand why. Adding a message\nto the <code>assert</code> helps the developer to understand why the AssertionError occurs.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">f(a) {\n  assert(a != null);\n}\n\nclass A {\n  A(a) : assert(a != null);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">f(a) {\n  assert(a != null, 'a must not be null');\n}\n\nclass A {\n  A(a) : assert(a != null, 'a must not be null');\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_asserts_with_message.html"
    },
    {
        "key": "prefer_bool_in_asserts",
        "name": "Prefer using a boolean as the assert condition.",
        "type": "CODE_SMELL",
        "status": "DEPRECATED",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use a boolean for assert conditions.</p>\n<p>Not using booleans in assert conditions can lead to code where it isn't clear\nwhat the intention of the assert statement is.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">assert(() {\n  f();\n  return true;\n});\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">assert(() {\n  f();\n  return true;\n}());\n</code></pre>\n<p><strong>DEPRECATED:</strong> In Dart 2, <code>assert</code>s no longer accept  non-<code>bool</code> values so this\nrule is made redundant by the Dart analyzer's basic checks and is no longer\nnecessary.</p>\n<p>The rule will be removed in a future Linter release.</p>\n\n@see https://dart-lang.github.io/linter/lints/prefer_bool_in_asserts.html"
    },
    {
        "key": "prefer_collection_literals",
        "name": "Use collection literals when possible.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use collection literals when possible.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var points = List();\nvar addresses = Map();\nvar uniqueNames = Set();\nvar ids = LinkedHashSet();\nvar coordinates = LinkedHashMap();\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var points = [];\nvar addresses = &lt;String,String&gt;{};\nvar uniqueNames = &lt;String&gt;{};\nvar ids = &lt;int&gt;{};\nvar coordinates = &lt;int,int&gt;{};\n</code></pre>\n<p><strong>EXCEPTIONS:</strong></p>\n<p>There are cases with <code>LinkedHashSet</code> or <code>LinkedHashMap</code> where a literal constructor\nwill trigger a type error so those will be excluded from the lint.</p>\n<pre><code class=\"language-dart\">void main() {\n  LinkedHashSet&lt;int&gt; linkedHashSet =  LinkedHashSet.from([1, 2, 3]); // OK\n  LinkedHashMap linkedHashMap = LinkedHashMap(); // OK\n  \n  printSet(LinkedHashSet&lt;int&gt;()); // LINT\n  printHashSet(LinkedHashSet&lt;int&gt;()); // OK\n\n  printMap(LinkedHashMap&lt;int, int&gt;()); // LINT\n  printHashMap(LinkedHashMap&lt;int, int&gt;()); // OK\n}\n\nvoid printSet(Set&lt;int&gt; ids) =&gt; print('$ids!');\nvoid printHashSet(LinkedHashSet&lt;int&gt; ids) =&gt; printSet(ids);\nvoid printMap(Map map) =&gt; print('$map!');\nvoid printHashMap(LinkedHashMap map) =&gt; printMap(map);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_collection_literals.html"
    },
    {
        "key": "prefer_conditional_assignment",
        "name": "Prefer using `??=` over testing for null.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> using <code>??=</code> over testing for null.</p>\n<p>As Dart has the <code>??=</code> operator, it is advisable to use it where applicable to\nimprove the brevity of your code.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">String get fullName {\n  if (_fullName == null) {\n    _fullName = getFullUserName(this);\n  }\n  return _fullName;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">String get fullName {\n  return _fullName ??= getFullUserName(this);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_conditional_assignment.html"
    },
    {
        "key": "prefer_const_constructors",
        "name": "Prefer const with constant constructors.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> using <code>const</code> for instantiating constant constructors.</p>\n<p>If a const constructor is available, it is preferable to use it.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  const A();\n}\n\nvoid accessA() {\n  A a = const A();\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  final int x;\n\n  const A(this.x);\n}\n\nA foo(int x) =&gt; new A(x);\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  const A();\n}\n\nvoid accessA() {\n  A a = new A();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_const_constructors.html"
    },
    {
        "key": "prefer_const_constructors_in_immutables",
        "name": "Prefer declaring const constructors on `@immutable` classes.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> declaring const constructors on <code>@immutable</code> classes.</p>\n<p>If a class is immutable, it is usually a good idea to make its constructor a\nconst constructor.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">@immutable\nclass A {\n  final a;\n  const A(this.a);\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">@immutable\nclass A {\n  final a;\n  A(this.a);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_const_constructors_in_immutables.html"
    },
    {
        "key": "prefer_const_declarations",
        "name": "Prefer const over final for declarations.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> using <code>const</code> for const declarations.</p>\n<p>Const declarations are more hot-reload friendly and allow to use const\nconstructors if an instantiation references this declaration.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">const o = &lt;int&gt;[];\n\nclass A {\n  static const o = &lt;int&gt;[];\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">final o = const &lt;int&gt;[];\n\nclass A {\n  static final o = const &lt;int&gt;[];\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_const_declarations.html"
    },
    {
        "key": "prefer_const_literals_to_create_immutables",
        "name": "Prefer const literals as parameters of constructors on @immutable classes.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> using <code>const</code> for instantiating list, map and set literals used as\nparameters in immutable class instantiations.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">@immutable\nclass A {\n  A(this.v);\n  final v;\n}\n\nA a1 = new A([1]);\nA a2 = new A({});\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">A a1 = new A(const [1]);\nA a2 = new A(const {});\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_const_literals_to_create_immutables.html"
    },
    {
        "key": "prefer_constructors_over_static_methods",
        "name": "Prefer defining constructors instead of static methods to create instances.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> defining constructors instead of static methods to create instances.</p>\n<p>In most cases, it makes more sense to use a named constructor rather than a\nstatic method because it makes instantiation clearer.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  num x, y;\n  Point(this.x, this.y);\n  static Point polar(num theta, num radius) {\n    return Point(radius * math.cos(theta),\n        radius * math.sin(theta));\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  num x, y;\n  Point(this.x, this.y);\n  Point.polar(num theta, num radius)\n      : x = radius * math.cos(theta),\n        y = radius * math.sin(theta);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_constructors_over_static_methods.html"
    },
    {
        "key": "prefer_contains",
        "name": "Use contains for `List` and `String` instances.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> use <code>indexOf</code> to see if a collection contains an element.</p>\n<p>Calling <code>indexOf</code> to see if a collection contains something is difficult to read\nand may have poor performance.</p>\n<p>Instead, prefer <code>contains</code>.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (!lunchBox.contains('sandwich')) return 'so hungry...';\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">if (lunchBox.indexOf('sandwich')) == -1 return 'so hungry...';\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_contains.html"
    },
    {
        "key": "prefer_double_quotes",
        "name": "Prefer double quotes where they won't require escape sequences.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use double quotes where they wouldn't require additional escapes.</p>\n<p>That means strings with a double quote may use apostrophes so that the double\nquote isn't escaped (note: we don't lint the other way around, ie, a double\nquoted string with an escaped double quote is not flagged).</p>\n<p>It's also rare, but possible, to have strings within string interpolations.  In\nthis case, its much more readable to use a single quote somewhere.  So single\nquotes are allowed either within, or containing, an interpolated string literal.\nArguably strings within string interpolations should be its own type of lint.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">useStrings(\n    'should be double quote',\n    r'should be double quote',\n    r'''should be double quotes''')\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">useStrings(\n    \"should be double quote\",\n    r\"should be double quote\",\n    r\"\"\"should be double quotes\"\"\",\n    'ok with \" inside',\n    'nested ${a ? \"strings\" : \"can\"} be wrapped by a double quote',\n    \"and nested ${a ? 'strings' : 'can be double quoted themselves'}\");\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_double_quotes.html"
    },
    {
        "key": "prefer_equal_for_default_values",
        "name": "Use `=` to separate a named parameter from its default value.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/usage\">style guide</a>:</p>\n<p><strong>DO</strong> Use <code>=</code> to separate a named parameter from its default value.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">m({a: 1})\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">m({a = 1})\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_equal_for_default_values.html"
    },
    {
        "key": "prefer_expression_function_bodies",
        "name": "Use => for short members whose body is a single return statement.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>CONSIDER</strong> using =&gt; for short members whose body is a single return statement.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">get width {\n  return right - left;\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">bool ready(num time) {\n  return minTime == null || minTime &lt;= time;\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">containsValue(String value) {\n  return getValues().contains(value);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">get width =&gt; right - left;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">bool ready(num time) =&gt; minTime == null || minTime &lt;= time;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">containsValue(String value) =&gt; getValues().contains(value);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_expression_function_bodies.html"
    },
    {
        "key": "prefer_final_fields",
        "name": "Private field could be final.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> prefer declaring private fields as final if they are not reassigned later\nin the library.</p>\n<p>Declaring fields as final when possible is a good practice because it helps\navoid accidental reassignments and allows the compiler to do optimizations.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class BadImmutable {\n  var _label = 'hola mundo! BadImmutable'; // LINT\n  var label = 'hola mundo! BadImmutable'; // OK\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class MultipleMutable {\n  var _label = 'hola mundo! GoodMutable', _offender = 'mumble mumble!'; // LINT\n  var _someOther; // LINT\n\n  MultipleMutable() : _someOther = 5;\n\n  MultipleMutable(this._someOther);\n\n  void changeLabel() {\n    _label= 'hello world! GoodMutable';\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class GoodImmutable {\n  final label = 'hola mundo! BadImmutable', bla = 5; // OK\n  final _label = 'hola mundo! BadImmutable', _bla = 5; // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class GoodMutable {\n  var _label = 'hola mundo! GoodMutable';\n\n  void changeLabel() {\n    _label = 'hello world! GoodMutable';\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class AssignedInAllConstructors {\n  var _label; // LINT\n  AssignedInAllConstructors(this._label);\n  AssignedInAllConstructors.withDefault() : _label = 'Hello';\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class NotAssignedInAllConstructors {\n  var _label; // OK\n  NotAssignedInAllConstructors();\n  NotAssignedInAllConstructors.withDefault() : _label = 'Hello';\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_final_fields.html"
    },
    {
        "key": "prefer_final_in_for_each",
        "name": "Prefer final in for-each loop variable if reference is not reassigned.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> prefer declaring for-each loop variables as final if they are not\nreassigned later in the code.</p>\n<p>Declaring for-each loop variables as final when possible is a good practice\nbecause it helps avoid accidental reassignments and allows the compiler to do\noptimizations.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">for (var element in elements) { // LINT\n  print('Element: $element');\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">for (final element in elements) {\n  print('Element: $element');\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">for (var element in elements) {\n  element = element + element;\n  print('Element: $element');\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_final_in_for_each.html"
    },
    {
        "key": "prefer_final_locals",
        "name": "Prefer final for variable declarations if they are not reassigned.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> prefer declaring variables as final if they are not reassigned later in\nthe code.</p>\n<p>Declaring variables as final when possible is a good practice because it helps\navoid accidental reassignments and allows the compiler to do optimizations.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void badMethod() {\n  var label = 'hola mundo! badMethod'; // LINT\n  print(label);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void goodMethod() {\n  final label = 'hola mundo! goodMethod';\n  print(label);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void mutableCase() {\n  var label = 'hola mundo! mutableCase';\n  print(label);\n  label = 'hello world';\n  print(label);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_final_locals.html"
    },
    {
        "key": "prefer_for_elements_to_map_fromIterable",
        "name": "Prefer for elements when building maps from iterables.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>When building maps from iterables, it is preferable to use for elements.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Map&lt;String, WidgetBuilder&gt;.fromIterable(\n  kAllGalleryDemos,\n  key: (demo) =&gt; '${demo.routeName}',\n  value: (demo) =&gt; demo.buildRoute,\n);\n\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">return {\n  for (var demo in kAllGalleryDemos)\n    '${demo.routeName}': demo.buildRoute,\n};\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_for_elements_to_map_fromIterable.html"
    },
    {
        "key": "prefer_foreach",
        "name": "Use `forEach` to only apply a function to all the elements.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use <code>forEach</code> if you are only going to apply a function or a method\nto all the elements of an iterable.</p>\n<p>Using <code>forEach</code> when you are only going to apply a function or method to all\nelements of an iterable is a good practice because it makes your code more\nterse.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">for (final key in map.keys.toList()) {\n  map.remove(key);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">map.keys.toList().forEach(map.remove);\n</code></pre>\n<p><strong>NOTE:</strong> Replacing a for each statement with a forEach call may change the \nbehavior in the case where there are side-effects on the iterable itself.</p>\n<pre><code class=\"language-dart\">for (final v in myList) {\n  foo().f(v); // This code invokes foo() many times.\n}\n\nmyList.forEach(foo().f); // But this one invokes foo() just once.\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_foreach.html"
    },
    {
        "key": "prefer_function_declarations_over_variables",
        "name": "Use a function declaration to bind a function to a name.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use a function declaration to bind a function to a name.</p>\n<p>As Dart allows local function declarations, it is a good practice to use them in\nthe place of function literals.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void main() {\n  var localFunction = () {\n    ...\n  };\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void main() {\n  localFunction() {\n    ...\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_function_declarations_over_variables.html"
    },
    {
        "key": "prefer_generic_function_type_aliases",
        "name": "Prefer generic function type aliases.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> generic function type aliases.</p>\n<p>With the introduction of generic functions, function type aliases\n(<code>typedef void F()</code>) couldn't express all of the possible kinds of\nparameterization that users might want to express. Generic function type aliases\n(<code>typedef F = void Function()</code>) fixed that issue.</p>\n<p>For consistency and readability reasons, it's better to only use one syntax and\nthus prefer generic function type aliases.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">typedef void F();\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">typedef F = void Function();\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_generic_function_type_aliases.html"
    },
    {
        "key": "prefer_if_elements_to_conditional_expressions",
        "name": "Prefer if elements to conditional expressions where possible.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>When building collections, it is preferable to use <code>if</code> elements rather than\nconditionals.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Widget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      Expanded(child: title),\n      isAndroid ? IconButton(icon: Icon(Icons.search)) : null,\n    ].where((child) =&gt; child != null).toList(),\n  );\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Widget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      Expanded(child: title),\n      if (isAndroid) IconButton(icon: Icon(Icons.search)),\n    ]\n  );\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_if_elements_to_conditional_expressions.html"
    },
    {
        "key": "prefer_if_null_operators",
        "name": "Prefer using if null operators.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Prefer using if null operators instead of null checks in conditional\nexpressions.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">v = a == null ? b : a;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">v = a ?? b;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_if_null_operators.html"
    },
    {
        "key": "prefer_initializing_formals",
        "name": "Use initializing formals when possible.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use initializing formals when possible.</p>\n<p>Using initializing formals when possible makes your code more terse.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  num x, y;\n  Point(num x, num y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  num x, y;\n  Point(this.x, this.y);\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  num x, y;\n  Point({num x, num y}) {\n    this.x = x;\n    this.y = y;\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  num x, y;\n  Point({this.x, this.y});\n}\n</code></pre>\n<p><strong>NOTE</strong>\nThis rule will not generate a lint for named parameters unless the parameter\nname and the field name are the same. The reason for this is that resolving\nsuch a lint would require either renaming the field or renaming the parameter,\nand both of those actions would potentially be a breaking change. For example,\nthe following will not generate a lint:</p>\n<pre><code class=\"language-darts\">class Point {\n  bool isEnabled;\n  Point({bool enabled}) {\n    this.isEnabled = enable; // OK\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_initializing_formals.html"
    },
    {
        "key": "prefer_inlined_adds",
        "name": "Inline list item declarations where possible.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Declare elements in list literals inline, rather than using <code>add</code> and \n<code>addAll</code> methods where possible.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var l = ['a']..add('b')..add('c');\nvar l2 = ['a']..addAll(['b', 'c'])\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var l = ['a', 'b', 'c'];\nvar 2 = ['a', 'b', 'c'];\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_inlined_adds.html"
    },
    {
        "key": "prefer_int_literals",
        "name": "Prefer int literals over double literals.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use int literals rather than the corresponding double literal.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">const double myDouble = 8.0;\nfinal anotherDouble = myDouble + 7.0e2;\nmain() {\n  someMethod(6.0);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">const double myDouble = 8;\nfinal anotherDouble = myDouble + 700;\nmain() {\n  someMethod(6);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_int_literals.html"
    },
    {
        "key": "prefer_interpolation_to_compose_strings",
        "name": "Use interpolation to compose strings and values.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> using interpolation to compose strings and values.</p>\n<p>Using interpolation when composing strings and values is usually easier to write\nand read than concatenation.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">'Hello, ' + name + '! You are ' + (year - birth) + ' years old.';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">'Hello, $name! You are ${year - birth} years old.';\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_interpolation_to_compose_strings.html"
    },
    {
        "key": "prefer_is_empty",
        "name": "Use `isEmpty` for Iterables and Maps.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> use <code>length</code> to see if a collection is empty.</p>\n<p>The <code>Iterable</code> contract does not require that a collection know its length or be\nable to provide it in constant time.  Calling <code>length</code> just to see if the\ncollection contains anything can be painfully slow.</p>\n<p>Instead, there are faster and more readable getters: <code>isEmpty</code> and\n<code>isNotEmpty</code>.  Use the one that doesn't require you to negate the result.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (lunchBox.isEmpty) return 'so hungry...';\nif (words.isNotEmpty) return words.join(' ');\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">if (lunchBox.length == 0) return 'so hungry...';\nif (words.length != 0) return words.join(' ');\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_is_empty.html"
    },
    {
        "key": "prefer_is_not_empty",
        "name": "Use `isNotEmpty` for Iterables and Maps.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> <code>x.isNotEmpty</code> to <code>!x.isEmpty</code> for <code>Iterable</code> and <code>Map</code> instances.</p>\n<p>When testing whether an iterable or map is empty, prefer <code>isNotEmpty</code> over\n<code>!isEmpty</code> to improve code readability.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (todo.isNotEmpty) {\n  sendResults(request, todo.isEmpty);\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">if (!sources.isEmpty) {\n  process(sources);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_is_not_empty.html"
    },
    {
        "key": "prefer_is_not_operator",
        "name": "Prefer is! operator.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>When checking if an object is not of a specified type, it is preferable to use the 'is!' operator.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">if (!(foo is Foo)) {\n  ...\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (foo is! Foo) {\n  ...\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_is_not_operator.html"
    },
    {
        "key": "prefer_iterable_whereType",
        "name": "Prefer to use whereType on iterable.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> <code>iterable.whereType&lt;T&gt;()</code> over <code>iterable.where((e) =&gt; e is T)</code>.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">iterable.where((e) =&gt; e is MyClass)\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">iterable.whereType&lt;MyClass&gt;()\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_iterable_whereType.html"
    },
    {
        "key": "prefer_mixin",
        "name": "Prefer using mixins.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Dart 2.1 introduced a new syntax for mixins that provides a safe way for a mixin\nto invoke inherited members using <code>super</code>. The new style of mixins should always\nbe used for types that are to be mixed in. As a result, this lint will flag any\nuses of a class in a <code>with</code> clause.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {}\nclass B extends Object with A {}\n</code></pre>\n<p><strong>OK:</strong></p>\n<pre><code class=\"language-dart\">mixin M {}\nclass C with M {}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_mixin.html"
    },
    {
        "key": "prefer_null_aware_method_calls",
        "name": "Prefer null aware method calls.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Instead of checking nullability of a function/method <code>f</code> before calling it you\ncan use <code>f?.call()</code>.</p>\n<p><strong>BAD:</strong></p>\n<pre><code>if (f != null) f!();\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code>f?.call();\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_null_aware_method_calls.html"
    },
    {
        "key": "prefer_null_aware_operators",
        "name": "Prefer using null aware operators.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Prefer using null aware operators instead of null checks in conditional\nexpressions.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">v = a == null ? null : a.b;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">v = a?.b;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_null_aware_operators.html"
    },
    {
        "key": "prefer_relative_imports",
        "name": "Prefer relative imports for files in `lib/`.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p>Prefer relative imports for files in <code>lib/</code>.</p>\n<p>When mixing relative and absolute imports it's possible to create confusion\nwhere the same member gets imported in two different ways. One way to avoid\nthat is to ensure you consistently use relative imports for files withing the\n<code>lib/</code> directory.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">import 'bar.dart';\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">import 'package:my_package/bar.dart';\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_relative_imports.html"
    },
    {
        "key": "prefer_single_quotes",
        "name": "Only use double quotes for strings containing single quotes.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use single quotes where they wouldn't require additional escapes.</p>\n<p>That means strings with an apostrophe may use double quotes so that the\napostrophe isn't escaped (note: we don't lint the other way around, ie, a single\nquoted string with an escaped apostrophe is not flagged).</p>\n<p>It's also rare, but possible, to have strings within string interpolations.  In\nthis case, its much more readable to use a double quote somewhere.  So double\nquotes are allowed either within, or containing, an interpolated string literal.\nArguably strings within string interpolations should be its own type of lint.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">useStrings(\n    \"should be single quote\",\n    r\"should be single quote\",\n    r\"\"\"should be single quotes\"\"\")\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">useStrings(\n    'should be single quote',\n    r'should be single quote',\n    r'''should be single quotes''',\n    \"here's ok\",\n    \"nested ${a ? 'strings' : 'can'} be wrapped by a double quote\",\n    'and nested ${a ? \"strings\" : \"can be double quoted themselves\"}');\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_single_quotes.html"
    },
    {
        "key": "prefer_spread_collections",
        "name": "Use spread collections when possible.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Use spread collections when possible.</p>\n<p>Collection literals are excellent when you want to create a new collection out \nof individual items. But, when existing items are already stored in another \ncollection, spread collection syntax leads to simpler code.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Widget build(BuildContext context) {\n  return CupertinoPageScaffold(\n    child: ListView(\n      children: [\n        Tab2Header(),\n      ]..addAll(buildTab2Conversation()),\n    ),\n  );\n}\n</code></pre>\n<pre><code class=\"language-dart\">var ints = [1, 2, 3];\nprint(['a']..addAll(ints.map((i) =&gt; i.toString()))..addAll(['c']));\n</code></pre>\n<pre><code class=\"language-dart\">var things;\nvar l = ['a']..addAll(things ?? const []);\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Widget build(BuildContext context) {\n  return CupertinoPageScaffold(\n    child: ListView(\n      children: [\n        Tab2Header(),\n        ...buildTab2Conversation(),\n      ],\n    ),\n  );\n}\n</code></pre>\n<pre><code class=\"language-dart\">var ints = [1, 2, 3];\nprint(['a', ...ints.map((i) =&gt; i.toString()), 'c');\n</code></pre>\n<pre><code class=\"language-dart\">var things;\nvar l = ['a', ...?things];\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_spread_collections.html"
    },
    {
        "key": "prefer_typing_uninitialized_variables",
        "name": "Prefer typing uninitialized variables and fields.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> specifying a type annotation for uninitialized variables and fields.</p>\n<p>Forgoing type annotations for uninitialized variables is a bad practice because\nyou may accidentally assign them to a type that you didn't originally intend to.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class BadClass {\n  static var bar; // LINT\n  var foo; // LINT\n\n  void method() {\n    var bar; // LINT\n    bar = 5;\n    print(bar);\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void aFunction() {\n  var bar; // LINT\n  bar = 5;\n  ...\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class GoodClass {\n  static var bar = 7;\n  var foo = 42;\n  int baz; // OK\n\n  void method() {\n    int baz;\n    var bar = 5;\n    ...\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_typing_uninitialized_variables.html"
    },
    {
        "key": "prefer_void_to_null",
        "name": "Don't use the Null type, unless you are positive that you don't want void.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DO NOT</strong> use the type Null where void would work.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Null f() {}\nFuture&lt;Null&gt; f() {}\nStream&lt;Null&gt; f() {}\nf(Null x) {}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void f() {}\nFuture&lt;void&gt; f() {}\nStream&lt;void&gt; f() {}\nf(void x) {}\n</code></pre>\n<p>Some exceptions include formulating special function types:</p>\n<pre><code class=\"language-dart\">Null Function(Null, Null);\n</code></pre>\n<p>and for making empty literals which are safe to pass into read-only locations\nfor any type of map or list:</p>\n<pre><code class=\"language-dart\">&lt;Null&gt;[];\n&lt;int, Null&gt;{};\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/prefer_void_to_null.html"
    },
    {
        "key": "prefix_collides_with_top_level_member",
        "name": "Prefix collides with top level member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' is already used as an import prefix and can't be used to name a\ntop-level element.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a name is used as both an import\nprefix and the name of a top-level declaration in the same library.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>f</code> is used as both an\nimport prefix and the name of a function:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' as f;</p>\n<p>int <a href=\"\">!f!</a> =&gt; f.min(0, 1);\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you want to use the name for the import prefix, then rename the\ntop-level declaration:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' as f;</p>\n<p>int g() =&gt; f.min(0, 1);\n{% endprettify %}</p>\n<p>If you want to use the name for the top-level declaration, then rename the\nimport prefix:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' as math;</p>\n<p>int f() =&gt; math.min(0, 1);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#prefix_collides_with_top_level_member"
    },
    {
        "key": "prefix_identifier_not_followed_by_dot",
        "name": "Prefix identifier not followed by dot",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' refers to an import prefix, so it must be followed by '.'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an import prefix is used by\nitself, without accessing any of the names declared in the libraries\nassociated with the prefix. Prefixes aren't variables, and therefore can't\nbe used as a value.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the prefix <code>math</code> is\nbeing used as if it were a variable:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' as math;</p>\n<p>void f() {\nprint([!math!]);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the code is incomplete, then reference something in one of the libraries\nassociated with the prefix:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' as math;</p>\n<p>void f() {\nprint(math.pi);\n}\n{% endprettify %}</p>\n<p>If the name is wrong, then correct the name.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#prefix_identifier_not_followed_by_dot"
    },
    {
        "key": "prefix_shadowed_by_local_declaration",
        "name": "Prefix shadowed by local declaration",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The prefix '{0}' can't be used here because it is shadowed by a local declaration.\n\nTry renaming either the prefix or the local declaration."
    },
    {
        "key": "private_collision_in_mixin_application",
        "name": "Private collision in mixin application",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The private name '{0}', defined by '{1}', conflicts with the same name defined by '{2}'.\n\nTry removing '{1}' from the 'with' clause."
    },
    {
        "key": "private_optional_parameter",
        "name": "Private optional parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Named parameters can't start with an underscore.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the name of a named parameter\nstarts with an underscore.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the named parameter\n<code>_x</code> starts with an underscore:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nvoid m({int [!_x!] = 0}) {}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Rename the parameter so that it doesn't start with an underscore:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nvoid m({int x = 0}) {}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#private_optional_parameter"
    },
    {
        "key": "private_setter",
        "name": "Private setter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The setter '{0}' is private and can't be accessed outside of the library that declares it.\n\nTry making it public."
    },
    {
        "key": "provide_deprecation_message",
        "name": "Provide a deprecation message, via @Deprecated(\"message\").",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> specify a deprecation message (with migration instructions and/or a\nremoval schedule) in the Deprecation constructor.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">@deprecated\nvoid oldFunction(arg1, arg2) {}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">@Deprecated(\"\"\"\n[oldFunction] is being deprecated in favor of [newFunction] (with slightly\ndifferent parameters; see [newFunction] for more information). [oldFunction]\nwill be removed on or after the 4.0.0 release.\n\"\"\")\nvoid oldFunction(arg1, arg2) {}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/provide_deprecation_message.html"
    },
    {
        "key": "public_member_api_docs",
        "name": "Document all public members.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> document all public members.</p>\n<p>All non-overriding public members should be documented with <code>///</code> doc-style\ncomments.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">/// A good thing.\nabstract class Good {\n  /// Start doing your thing.\n  void start() =&gt; _start();\n\n  _start();\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Bad {\n  void meh() { }\n}\n</code></pre>\n<p>In case a public member overrides a member it is up to the declaring member\nto provide documentation.  For example, in the following, <code>Sub</code> needn't\ndocument <code>init</code> (though it certainly may, if there's need).</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">/// Base of all things.\nabstract class Base {\n  /// Initialize the base.\n  void init();\n}\n\n/// A sub base.\nclass Sub extends Base {\n  @override\n  void init() { ... }\n}\n</code></pre>\n<p>Note that consistent with <code>dartdoc</code>, an exception to the rule is made when\ndocumented getters have corresponding undocumented setters.  In this case the\nsetters inherit the docs from the getters.</p>\n\n@see https://dart-lang.github.io/linter/lints/public_member_api_docs.html"
    },
    {
        "key": "read_potentially_unassigned_final",
        "name": "Read potentially unassigned final",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The final variable '{0}' can't be read because it is potentially unassigned at this point.\n\nEnsure that it is assigned on necessary execution paths."
    },
    {
        "key": "receiver_of_type_never",
        "name": "Receiver of type never",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The receiver is of type 'Never', and will never complete with a value.\n\nTry checking for throw expressions or type errors in the receiver"
    },
    {
        "key": "recursive_compile_time_constant",
        "name": "Recursive compile time constant",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The compile-time constant expression depends on itself.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the value of a compile-time\nconstant is defined in terms of itself, either directly or indirectly,\ncreating an infinite loop.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic twice because both of the\nconstants are defined in terms of the other:</p>\n<p>{% prettify dart tag=pre+code %}\nconst [!secondsPerHour!] = minutesPerHour * 60;\nconst [!minutesPerHour!] = secondsPerHour / 60;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Break the cycle by finding an alternative way of defining at least one of\nthe constants:</p>\n<p>{% prettify dart tag=pre+code %}\nconst secondsPerHour = minutesPerHour * 60;\nconst minutesPerHour = 60;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#recursive_compile_time_constant"
    },
    {
        "key": "recursive_constructor_redirect",
        "name": "Recursive constructor redirect",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Constructors can't redirect to themselves either directly or indirectly.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constructor redirects to\nitself, either directly or indirectly, creating an infinite loop.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the generative\nconstructors <code>C.a</code> and <code>C.b</code> each redirect to the other:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a() : [!this.b()!];\nC.b() : [!this.a()!];\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the factory\nconstructors <code>A</code> and <code>B</code> each redirect to the other:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nfactory A() = [!B!];\n}\nclass B implements A {\nfactory B() = [!A!];\nB.named();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>In the case of generative constructors, break the cycle by finding defining\nat least one of the constructors to not redirect to another constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a() : this.b();\nC.b();\n}\n{% endprettify %}</p>\n<p>In the case of factory constructors, break the cycle by defining at least\none of the factory constructors to do one of the following:</p>\n<ul>\n<li>Redirect to a generative constructor:</li>\n</ul>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nfactory A() = B;\n}\nclass B implements A {\nfactory B() = B.named;\nB.named();\n}\n{% endprettify %}</p>\n<ul>\n<li>Not redirect to another constructor:</li>\n</ul>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nfactory A() = B;\n}\nclass B implements A {\nfactory B() {\nreturn B.named();\n}</p>\n<p>B.named();\n}\n{% endprettify %}</p>\n<ul>\n<li>Not be a factory constructor:</li>\n</ul>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nfactory A() = B;\n}\nclass B implements A {\nB();\nB.named();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#recursive_constructor_redirect"
    },
    {
        "key": "recursive_getters",
        "name": "Property getter recursively returns itself.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> create recursive getters.</p>\n<p>Recursive getters are getters which return themselves as a value.  This is\nusually a typo.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">int get field =&gt; field; // LINT\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">int get otherField {\n  return otherField; // LINT\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">int get field =&gt; _field;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/recursive_getters.html"
    },
    {
        "key": "recursive_interface_inheritance",
        "name": "Recursive interface inheritance",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't be a superinterface of itself: {1}.\n\nnull"
    },
    {
        "key": "recursive_interface_inheritance_extends",
        "name": "Recursive interface inheritance extends",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't extend itself.\n\nnull"
    },
    {
        "key": "recursive_interface_inheritance_implements",
        "name": "Recursive interface inheritance implements",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't implement itself.\n\nnull"
    },
    {
        "key": "recursive_interface_inheritance_on",
        "name": "Recursive interface inheritance on",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't use itself as a superclass constraint.\n\nnull"
    },
    {
        "key": "recursive_interface_inheritance_with",
        "name": "Recursive interface inheritance with",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't use itself as a mixin.\n\nnull"
    },
    {
        "key": "redirect_generative_to_missing_constructor",
        "name": "Redirect generative to missing constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The constructor '{0}' couldn't be found in '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a generative constructor\nredirects to a constructor that isn't defined.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the constructor <code>C.a</code>\nredirects to the constructor <code>C.b</code>, but <code>C.b</code> isn't defined:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a() : [!this.b()!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the missing constructor must be called, then define it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a() : this.b();\nC.b();\n}\n{% endprettify %}</p>\n<p>If the missing constructor doesn't need to be called, then remove the\nredirect:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#redirect_generative_to_missing_constructor"
    },
    {
        "key": "redirect_generative_to_non_generative_constructor",
        "name": "Redirect generative to non generative constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Generative constructors can't redirect to a factory constructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a generative constructor\nredirects to a factory constructor.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the generative\nconstructor <code>C.a</code> redirects to the factory constructor <code>C.b</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a() : [!this.b()!];\nfactory C.b() =&gt; C.a();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the generative constructor doesn't need to redirect to another\nconstructor, then remove the redirect.</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a();\nfactory C.b() =&gt; C.a();\n}\n{% endprettify %}</p>\n<p>If the generative constructor must redirect to another constructor, then\nmake the other constructor be a generative (non-factory) constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a() : this.b();\nC.b();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#redirect_generative_to_non_generative_constructor"
    },
    {
        "key": "redirect_to_abstract_class_constructor",
        "name": "Redirect to abstract class constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The redirecting constructor '{0}' can't redirect to a constructor of the abstract class '{1}'.\n\nTry redirecting to a constructor of a different class."
    },
    {
        "key": "redirect_to_invalid_function_type",
        "name": "Redirect to invalid function type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The redirected constructor '{0}' has incompatible parameters with '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a factory constructor attempts\nto redirect to another constructor, but the two have incompatible\nparameters. The parameters are compatible if all of the parameters of the\nredirecting constructor can be passed to the other constructor and if the\nother constructor doesn't require any parameters that aren't declared by\nthe redirecting constructor.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the constructor for <code>A</code>\ndoesn't declare a parameter that the constructor for <code>B</code> requires:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nfactory A() = [!B!];\n}</p>\n<p>class B implements A {\nB(int x);\nB.zero();\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the constructor for <code>A</code>\ndeclares a named parameter (<code>y</code>) that the constructor for <code>B</code> doesn't\nallow:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nfactory A(int x, {int y}) = [!B!];\n}</p>\n<p>class B implements A {\nB(int x);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If there's a different constructor that is compatible with the redirecting\nconstructor, then redirect to that constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nfactory A() = B.zero;\n}</p>\n<p>class B implements A {\nB(int x);\nB.zero();\n}\n{% endprettify %}</p>\n<p>Otherwise, update the redirecting constructor to be compatible:</p>\n<p>{% prettify dart tag=pre+code %}\nabstract class A {\nfactory A(int x) = B;\n}</p>\n<p>class B implements A {\nB(int x);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#redirect_to_invalid_function_type"
    },
    {
        "key": "redirect_to_invalid_return_type",
        "name": "Redirect to invalid return type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The return type '{0}' of the redirected constructor isn't a subtype of '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a factory constructor redirects\nto a constructor whose return type isn't a subtype of the type that the\nfactory constructor is declared to produce.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>A</code> isn't a subclass\nof <code>C</code>, which means that the value returned by the constructor <code>A()</code>\ncouldn't be returned from the constructor <code>C()</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}</p>\n<p>class B implements C {}</p>\n<p>class C {\nfactory C() = [!A!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the factory constructor is redirecting to a constructor in the wrong\nclass, then update the factory constructor to redirect to the correct\nconstructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}</p>\n<p>class B implements C {}</p>\n<p>class C {\nfactory C() = B;\n}\n{% endprettify %}</p>\n<p>If the class defining the constructor being redirected to is the class that\nshould be returned, then make it a subtype of the factory's return type:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A implements C {}</p>\n<p>class B implements C {}</p>\n<p>class C {\nfactory C() = A;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#redirect_to_invalid_return_type"
    },
    {
        "key": "redirect_to_missing_constructor",
        "name": "Redirect to missing constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The constructor '{0}' couldn't be found in '{1}'.\n\nTry redirecting to a different constructor, or define the constructor named '{0}'."
    },
    {
        "key": "redirect_to_non_class",
        "name": "Redirect to non class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' isn't a type and can't be used in a redirected constructor.</em></p>\n<h4>Description</h4>\n<p>One way to implement a factory constructor is to redirect to another\nconstructor by referencing the name of the constructor. The analyzer\nproduces this diagnostic when the redirect is to something other than a\nconstructor.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> is a function:</p>\n<p>{% prettify dart tag=pre+code %}\nC f() =&gt; throw 0;</p>\n<p>class C {\nfactory C() = [!f!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the constructor isn't defined, then either define it or replace it with\na constructor that is defined.</p>\n<p>If the constructor is defined but the class that defines it isn't visible,\nthen you probably need to add an import.</p>\n<p>If you're trying to return the value returned by a function, then rewrite\nthe constructor to return the value from the constructor's body:</p>\n<p>{% prettify dart tag=pre+code %}\nC f() =&gt; throw 0;</p>\n<p>class C {\nfactory C() =&gt; f();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#redirect_to_non_class"
    },
    {
        "key": "redirect_to_non_const_constructor",
        "name": "Redirect to non const constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A constant redirecting constructor can't redirect to a non-constant\nconstructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constructor marked as <code>const</code>\nredirects to a constructor that isn't marked as <code>const</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the constructor <code>C.a</code>\nis marked as <code>const</code> but redirects to the constructor <code>C.b</code>, which isn't:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nconst C.a() : this.<a href=\"\">!b!</a>;\n  C.b();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the non-constant constructor can be marked as <code>const</code>, then mark it as\n<code>const</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nconst C.a() : this.b();\nconst C.b();\n}\n{% endprettify %}</p>\n<p>If the non-constant constructor can't be marked as <code>const</code>, then either\nremove the redirect or remove <code>const</code> from the redirecting constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a() : this.b();\nC.b();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#redirect_to_non_const_constructor"
    },
    {
        "key": "redirect_to_type_alias_expands_to_type_parameter",
        "name": "Redirect to type alias expands to type parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Redirecting constructor can't redirect to a type alias that expands to a type parameter.\n\nTry replacing it with a class."
    },
    {
        "key": "referenced_before_declaration",
        "name": "Referenced before declaration",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Local variable '{0}' can't be referenced before it is declared.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a variable is referenced before\nitâ€™s declared. In Dart, variables are visible everywhere in the block in\nwhich they are declared, but can only be referenced after they are\ndeclared.</p>\n<p>The analyzer also produces a context message that indicates where the\ndeclaration is located.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>i</code> is used before it\nis declared:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nprint([!i!]);\nint i = 5;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you intended to reference the local variable, move the declaration\nbefore the first reference:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nint i = 5;\nprint(i);\n}\n{% endprettify %}</p>\n<p>If you intended to reference a name from an outer scope, such as a\nparameter, instance field or top-level variable, then rename the local\ndeclaration so that it doesn't hide the outer variable.</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int i) {\nprint(i);\nint x = 5;\nprint(x);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#referenced_before_declaration"
    },
    {
        "key": "require_trailing_commas",
        "name": "Use trailing commas for all function calls and declarations.",
        "type": "CODE_SMELL",
        "status": "BETA",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use trailing commas for all function calls and declarations unless the\nfunction call or definition, from the start of the function name up to the\nclosing parenthesis, fits in a single line.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void run() {\n  method(\n    'does not fit on one line',\n    'test test test test test test test test test test test',\n  );\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void run() {\n  method('does not fit on one line',\n      'test test test test test test test test test test test');\n}\n</code></pre>\n<p><strong>Exception:</strong> If the final parameter/argument is positional (vs named) and is\neither a function literal implemented using curly braces, a literal map, a\nliteral set or a literal array. This exception only applies if the final\nparameter does not fit entirely on one line.</p>\n<p><strong>Note:</strong> This lint rule assumes <code>dartfmt</code> has been run over the code and may\nproduce false positives until that has happened.</p>\n\n@see https://dart-lang.github.io/linter/lints/require_trailing_commas.html"
    },
    {
        "key": "rethrow_outside_catch",
        "name": "Rethrow outside catch",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A rethrow must be inside of a catch clause.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a <code>rethrow</code> statement is outside\na <code>catch</code> clause. The <code>rethrow</code> statement is used to throw a caught\nexception again, but there's no caught exception outside of a <code>catch</code>\nclause.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the<code>rethrow</code> statement\nis outside of a <code>catch</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\n[!rethrow!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you're trying to rethrow an exception, then wrap the <code>rethrow</code> statement\nin a <code>catch</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n// ...\n} catch (exception) {\nrethrow;\n}\n}\n{% endprettify %}</p>\n<p>If you're trying to throw a new exception, then replace the <code>rethrow</code>\nstatement with a <code>throw</code> expression:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\nthrow UnsupportedError('Not yet implemented');\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#rethrow_outside_catch"
    },
    {
        "key": "return_in_generative_constructor",
        "name": "Return in generative constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Constructors can't return values.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a generative constructor\ncontains a <code>return</code> statement that specifies a value to be returned.\nGenerative constructors always return the object that was created, and\ntherefore can't return a different object.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the <code>return</code> statement\nhas an expression:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC() {\nreturn [!this!];\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the constructor should create a new instance, then remove either the\n<code>return</code> statement or the expression:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC();\n}\n{% endprettify %}</p>\n<p>If the constructor shouldn't create a new instance, then convert it to be a\nfactory constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nfactory C() {\nreturn _instance;\n}</p>\n<p>static C <em>instance = C.</em>();</p>\n<p>C._();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#return_in_generative_constructor"
    },
    {
        "key": "return_in_generator",
        "name": "Return in generator",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Can't return a value from a generator function (using the '{0}' modifier).\n\nTry removing the value, replacing 'return' with 'yield' or changing the method body modifier."
    },
    {
        "key": "return_of_do_not_store",
        "name": "Return of do not store",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "'{0}' is annotated with 'doNotStore' and shouldn't be returned unless '{1}' is also annotated.\n\nAnnotate '{1}' with 'doNotStore'."
    },
    {
        "key": "return_of_invalid_type",
        "name": "Return of invalid type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A value of type '{0}' can't be returned from the constructor '{2}' because it\nhas a return type of '{1}'.</em></p>\n<p><em>A value of type '{0}' can't be returned from the function '{2}' because it has\na return type of '{1}'.</em></p>\n<p><em>A value of type '{0}' can't be returned from the method '{2}' because it has a\nreturn type of '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a method or function returns a\nvalue whose type isn't assignable to the declared return type.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> has a return type\nof <code>String</code> but is returning an <code>int</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nString f() =&gt; [!3!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the return type is correct, then replace the value being returned with a\nvalue of the correct type, possibly by converting the existing value:</p>\n<p>{% prettify dart tag=pre+code %}\nString f() =&gt; 3.toString();\n{% endprettify %}</p>\n<p>If the value is correct, then change the return type to match:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() =&gt; 3;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#return_of_invalid_type"
    },
    {
        "key": "return_of_invalid_type_from_closure",
        "name": "Return of invalid type from closure",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The return type '{0}' isn't a '{1}', as required by the closure's context.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the static type of a returned\nexpression isn't assignable to the return type that the closure is required\nto have.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> is defined to be a\nfunction that returns a <code>String</code>, but the closure assigned to it returns an\n<code>int</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nString Function(String) f = (s) =&gt; [!3!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the return type is correct, then replace the returned value with a value\nof the correct type, possibly by converting the existing value:</p>\n<p>{% prettify dart tag=pre+code %}\nString Function(String) f = (s) =&gt; 3.toString();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#return_of_invalid_type_from_closure"
    },
    {
        "key": "return_without_value",
        "name": "Return without value",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The return value is missing after 'return'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds a <code>return</code> statement\nwithout an expression in a function that declares a return type.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the function <code>f</code> is\nexpected to return an <code>int</code>, but no value is being returned:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() {\n[!return!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add an expression that computes the value to be returned:</p>\n<p>{% prettify dart tag=pre+code %}\nint f() {\nreturn 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#return_without_value"
    },
    {
        "key": "sdk_version_as_expression_in_const_context",
        "name": "Sdk version as expression in const context",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The use of an as expression in a constant expression wasn't supported until\nversion 2.3.2, but this code is required to be able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an <code>as</code> expression inside a\n<a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> is found in code that has an SDK constraint whose\nlower bound is less than 2.3.2. Using an <code>as</code> expression in a\n<a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> wasn't supported in earlier versions, so this code\nwon't be able to run against earlier versions of the SDK.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.1.0 &lt;2.4.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces\nthis diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nconst num n = 3;\nconst int i = [!n as int!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the expression to be used:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.3.2 &lt;2.4.0'\n</code></pre>\n<p>If you need to support older versions of the SDK, then either rewrite the\ncode to not use an <code>as</code> expression, or change the code so that the <code>as</code>\nexpression isn't in a <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a>:</p>\n<p>{% prettify dart tag=pre+code %}\nnum x = 3;\nint y = x as int;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_as_expression_in_const_context"
    },
    {
        "key": "sdk_version_async_exported_from_core",
        "name": "Sdk version async exported from core",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The class '{0}' wasn't exported from 'dart:core' until version 2.1, but this\ncode is required to be able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when either the class <code>Future</code> or\n<code>Stream</code> is referenced in a library that doesn't import <code>dart:async</code> in\ncode that has an SDK constraint whose lower bound is less than 2.1.0. In\nearlier versions, these classes weren't defined in <code>dart:core</code>, so the\nimport was necessary.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.1.0:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.0.0 &lt;2.4.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces this\ndiagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f([!Future!] f) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the classes to be referenced:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.1.0 &lt;2.4.0'\n</code></pre>\n<p>If you need to support older versions of the SDK, then import the\n<code>dart:async</code> library.</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:async';</p>\n<p>void f(Future f) {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_async_exported_from_core"
    },
    {
        "key": "sdk_version_bool_operator_in_const_context",
        "name": "Sdk version bool operator in const context",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The use of the operator '{0}' for 'bool' operands in a constant context wasn't\nsupported until version 2.3.2, but this code is required to be able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when any use of the <code>&amp;</code>, <code>|</code>, or <code>^</code>\noperators on the class <code>bool</code> inside a <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> is found in\ncode that has an SDK constraint whose lower bound is less than 2.3.2. Using\nthese operators in a <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.1.0 &lt;2.4.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces this\ndiagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nconst bool a = true;\nconst bool b = false;\nconst bool c = a [!&amp;!] b;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the operators to be used:</p>\n<pre><code class=\"language-yaml\">environment:\n sdk: '&gt;=2.3.2 &lt;2.4.0'\n</code></pre>\n<p>If you need to support older versions of the SDK, then either rewrite the\ncode to not use these operators, or change the code so that the expression\nisn't in a <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a>:</p>\n<p>{% prettify dart tag=pre+code %}\nconst bool a = true;\nconst bool b = false;\nbool c = a &amp; b;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_bool_operator_in_const_context"
    },
    {
        "key": "sdk_version_eq_eq_operator_in_const_context",
        "name": "Sdk version eq eq operator in const context",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Using the operator '==' for non-primitive types wasn't supported until version\n2.3.2, but this code is required to be able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the operator <code>==</code> is used on a\nnon-primitive type inside a <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> is found in code that has\nan SDK constraint whose lower bound is less than 2.3.2. Using this operator\nin a <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> wasn't supported in earlier versions, so this\ncode won't be able to run against earlier versions of the SDK.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.1.0 &lt;2.4.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces this\ndiagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}\nconst C a = null;\nconst C b = null;\nconst bool same = a [!==!] b;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the operator to be used:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.3.2 &lt;2.4.0'\n</code></pre>\n<p>If you need to support older versions of the SDK, then either rewrite the\ncode to not use the <code>==</code> operator, or change the code so that the\nexpression isn't in a <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}\nconst C a = null;\nconst C b = null;\nbool same = a == b;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_eq_eq_operator_in_const_context"
    },
    {
        "key": "sdk_version_extension_methods",
        "name": "Sdk version extension methods",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Extension methods weren't supported until version 2.6.0, but this code is\nrequired to be able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension declaration or an\nextension override is found in code that has an SDK constraint whose lower\nbound is less than 2.6.0. Using extensions wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.6.0:</p>\n<pre><code class=\"language-yaml\">environment:\n sdk: '&gt;=2.4.0 &lt;2.7.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces\nthis diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\n[!extension!] E on String {\nvoid sayHello() {\nprint('Hello $this');\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.6.0 &lt;2.7.0'\n</code></pre>\n<p>If you need to support older versions of the SDK, then rewrite the code to\nnot make use of extensions. The most common way to do this is to rewrite\nthe members of the extension as top-level functions (or methods) that take\nthe value that would have been bound to <code>this</code> as a parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid sayHello(String s) {\nprint('Hello $s');\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_extension_methods"
    },
    {
        "key": "sdk_version_gt_gt_gt_operator",
        "name": "Sdk version gt gt gt operator",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The operator '>>>' wasn't supported until version 2.3.2, but this code is required to be able to run on earlier versions.\n\nTry updating the SDK constraints."
    },
    {
        "key": "sdk_version_is_expression_in_const_context",
        "name": "Sdk version is expression in const context",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The use of an is expression in a constant context wasn't supported until\nversion 2.3.2, but this code is required to be able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an <code>is</code> expression inside a\n<a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> is found in code that has an SDK constraint whose\nlower bound is less than 2.3.2. Using an <code>is</code> expression in a\n<a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> wasn't supported in earlier versions, so this code\nwon't be able to run against earlier versions of the SDK.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.2:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.1.0 &lt;2.4.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces\nthis diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nconst x = 4;\nconst y = [!x is int!] ? 0 : 1;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the expression to be used:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.3.2 &lt;2.4.0'\n</code></pre>\n<p>If you need to support older versions of the SDK, then either rewrite the\ncode to not use the <code>is</code> operator, or, if that isn't possible, change the\ncode so that the <code>is</code> expression isn't in a\n<a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a>:</p>\n<p>{% prettify dart tag=pre+code %}\nconst x = 4;\nvar y = x is int ? 0 : 1;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_is_expression_in_const_context"
    },
    {
        "key": "sdk_version_never",
        "name": "Sdk version never",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The type 'Never' wasn't supported until version 2.X.0, but this code is\nrequired to be able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a reference to the class <code>Never</code>\nis found in code that has an SDK constraint whose lower bound is less than\n2.12.0. This class wasn't defined in earlier versions, so this code won't\nbe able to run against earlier versions of the SDK.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.12.0:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.5.0 &lt;2.6.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces this\ndiagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\n[!Never!] n;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the type to be used:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.12.0 &lt;2.13.0'\n</code></pre>\n<p>If you need to support older versions of the SDK, then rewrite the code to\nnot reference this class:</p>\n<p>{% prettify dart tag=pre+code %}\ndynamic x;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_never"
    },
    {
        "key": "sdk_version_set_literal",
        "name": "Sdk version set literal",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Set literals weren't supported until version 2.2, but this code is required to\nbe able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a set literal is found in code\nthat has an SDK constraint whose lower bound is less than 2.2.0. Set\nliterals weren't supported in earlier versions, so this code won't be able\nto run against earlier versions of the SDK.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.2.0:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.1.0 &lt;2.4.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces this\ndiagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nvar s = [!<int>{}!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.2.0 &lt;2.4.0'\n</code></pre>\n<p>If you do need to support older versions of the SDK, then replace the set\nliteral with code that creates the set without the use of a literal:</p>\n<p>{% prettify dart tag=pre+code %}\nvar s = new Set<int>();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_set_literal"
    },
    {
        "key": "sdk_version_ui_as_code",
        "name": "Sdk version ui as code",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The for, if, and spread elements weren't supported until version 2.3.0, but\nthis code is required to be able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a for, if, or spread element is\nfound in code that has an SDK constraint whose lower bound is less than\n2.3.0. Using a for, if, or spread element wasn't supported in earlier\nversions, so this code won't be able to run against earlier versions of the\nSDK.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.3.0:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.2.0 &lt;2.4.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces\nthis diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nvar digits = [[!for (int i = 0; i &lt; 10; i++) i!]];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.3.0 &lt;2.4.0'\n</code></pre>\n<p>If you need to support older versions of the SDK, then rewrite the code to\nnot make use of those elements:</p>\n<p>{% prettify dart tag=pre+code %}\nvar digits = _initializeDigits();</p>\n<p>List<int> _initializeDigits() {\nvar digits = <int>[];\nfor (int i = 0; i &lt; 10; i++) {\ndigits.add(i);\n}\nreturn digits;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_ui_as_code"
    },
    {
        "key": "sdk_version_ui_as_code_in_const_context",
        "name": "Sdk version ui as code in const context",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The if and spread elements weren't supported in constant expressions until\nversion 2.5.0, but this code is required to be able to run on earlier versions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an if or spread element inside\na <a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> is found in code that has an SDK constraint whose\nlower bound is less than 2.5.0. Using an if or spread element inside a\n<a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a> wasn't supported in earlier versions, so this code\nwon't be able to run against earlier versions of the SDK.</p>\n<h4>Examples</h4>\n<p>Here's an example of a pubspec that defines an SDK constraint with a lower\nbound of less than 2.5.0:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.4.0 &lt;2.6.0'\n</code></pre>\n<p>In the package that has that pubspec, code like the following produces\nthis diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = [1, 2];\nconst b = [[!...a!]];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you don't need to support older versions of the SDK, then you can\nincrease the SDK constraint to allow the syntax to be used:</p>\n<pre><code class=\"language-yaml\">environment:\n  sdk: '&gt;=2.5.0 &lt;2.6.0'\n</code></pre>\n<p>If you need to support older versions of the SDK, then rewrite the code to\nnot make use of those elements:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = [1, 2];\nconst b = [1, 2];\n{% endprettify %}</p>\n<p>If that isn't possible, change the code so that the element isn't in a\n<a href=\"https://dart.dev/tools/diagnostic-messages#constant-context\">constant context</a>:</p>\n<p>{% prettify dart tag=pre+code %}\nconst a = [1, 2];\nvar b = [...a];\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#sdk_version_ui_as_code_in_const_context"
    },
    {
        "key": "set_element_type_not_assignable",
        "name": "Set element type not assignable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The element type '{0}' can't be assigned to the set type '{1}'.\n\nnull"
    },
    {
        "key": "shared_deferred_prefix",
        "name": "Shared deferred prefix",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The prefix of a deferred import can't be used in other import directives.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a prefix in a deferred import is\nalso used as a prefix in other imports (whether deferred or not). The\nprefix in a deferred import can't be shared with other imports because the\nprefix is used to load the imported library.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the prefix <code>x</code> is used\nas the prefix for a deferred import and is also used for one other import:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' [!deferred!] as x;\nimport 'dart:convert' as x;</p>\n<p>var y = x.json.encode(x.min(0, 1));\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you can use a different name for the deferred import, then do so:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' deferred as math;\nimport 'dart:convert' as x;</p>\n<p>var y = x.json.encode(math.min(0, 1));\n{% endprettify %}</p>\n<p>If you can use a different name for the other imports, then do so:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' deferred as x;\nimport 'dart:convert' as convert;</p>\n<p>var y = convert.json.encode(x.min(0, 1));\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#shared_deferred_prefix"
    },
    {
        "key": "sized_box_for_whitespace",
        "name": "SizedBox for whitespace.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Use SizedBox to add whitespace to a layout.</p>\n<p>A <code>Container</code> is a heavier Widget than a <code>SizedBox</code>, and as bonus, <code>SizedBox</code>\nhas a <code>const</code> constructor.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Widget buildRow() {\n  return Row(\n    children: &lt;Widget&gt;[\n      const MyLogo(),\n      Container(width: 4),\n      const Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Widget buildRow() {\n  return Row(\n    children: const &lt;Widget&gt;[\n      MyLogo(),\n      SizedBox(width: 4),\n      Expanded(\n        child: Text('...'),\n      ),\n    ],\n  );\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/sized_box_for_whitespace.html"
    },
    {
        "key": "slash_for_doc_comments",
        "name": "Prefer using /// for doc comments.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/style\">style guide</a>:</p>\n<p><strong>PREFER</strong> using <code>///</code> for doc comments.</p>\n<p>Although Dart supports two syntaxes of doc comments (<code>///</code> and <code>/**</code>), we\nprefer using <code>///</code> for doc comments.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">/// Parses a set of option strings. For each option:\n///\n/// * If it is `null`, then it is ignored.\n/// * If it is a string, then [validate] is called on it.\n/// * If it is any other type, it is *not* validated.\nvoid parse(List options) {\n  // ...\n}\n</code></pre>\n<p>Within a doc comment, you can use markdown for formatting.</p>\n\n@see https://dart-lang.github.io/linter/lints/slash_for_doc_comments.html"
    },
    {
        "key": "sort_child_properties_last",
        "name": "Sort child properties last in widget instance creations.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Sort child properties last in widget instance creations.  This improves\nreadability and plays nicest with UI as Code visualization in IDEs with UI as\nCode Guides in editors (such as IntelliJ) where Properties in the correct order \nappear clearly associated with the constructor call and separated from the \nchildren.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">return Scaffold(\n  appBar: AppBar(\n    title: Text(widget.title),\n  ),\n  body: Center(\n    child: Column(\n      children: &lt;Widget&gt;[\n        Text(\n          'You have pushed the button this many times:',\n         ),\n        Text(\n          '$_counter',\n          style: Theme.of(context).textTheme.display1,\n         ),\n      ],\n      mainAxisAlignment: MainAxisAlignment.center,\n    ),\n    widthFactor: 0.5,\n  ),\n  floatingActionButton: FloatingActionButton(\n    child: Icon(Icons.add),\n    onPressed: _incrementCounter,\n    tooltip: 'Increment',\n  ),\n);\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">return Scaffold(\n  appBar: AppBar(\n    title: Text(widget.title),\n  ),\n  body: Center(\n    widthFactor: 0.5,\n    child: Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: &lt;Widget&gt;[\n        Text(\n          'You have pushed the button this many times:',\n         ),\n        Text(\n          '$_counter',\n          style: Theme.of(context).textTheme.display1,\n         ),\n      ],\n    ),\n  ),\n  floatingActionButton: FloatingActionButton(\n    onPressed: _incrementCounter,\n    tooltip: 'Increment',\n    child: Icon(Icons.add),\n  ),\n);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/sort_child_properties_last.html"
    },
    {
        "key": "sort_constructors_first",
        "name": "Sort constructor declarations before other members.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> sort constructor declarations before other members.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">abstract class Animation&lt;T&gt; {\n  const Animation(this.value);\n  double value;\n  void addListener(VoidCallback listener);\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">abstract class Visitor {\n  double value;\n  visitSomething(Something s);\n  Visitor();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/sort_constructors_first.html"
    },
    {
        "key": "sort_pub_dependencies",
        "name": "Sort pub dependencies.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> sort pub dependencies in <code>pubspec.yaml</code>.</p>\n<p>Sorting list of pub dependencies makes maintenance easier.</p>\n\n@see https://dart-lang.github.io/linter/lints/sort_pub_dependencies.html"
    },
    {
        "key": "sort_unnamed_constructors_first",
        "name": "Sort unnamed constructor declarations first.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> sort unnamed constructor declarations first, before named ones.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">abstract class CancelableFuture&lt;T&gt; implements Future&lt;T&gt;  {\n  factory CancelableFuture(computation()) =&gt; ...\n  factory CancelableFuture.delayed(Duration duration, [computation()]) =&gt; ...\n  ...\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class _PriorityItem {\n  factory _PriorityItem.forName(bool isStatic, String name, _MemberKind kind) =&gt; ...\n  _PriorityItem(this.isStatic, this.kind, this.isPrivate);\n  ...\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/sort_unnamed_constructors_first.html"
    },
    {
        "key": "spread_expression_from_deferred_library",
        "name": "Spread expression from deferred library",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Constant values from a deferred library can't be spread into a const literal.\n\nTry making the deferred import non-deferred."
    },
    {
        "key": "static_access_to_instance_member",
        "name": "Static access to instance member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Instance member '{0}' can't be accessed using static access.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a class name is used to access\nan instance field. Instance fields don't exist on a class; they exist only\non an instance of the class.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>x</code> is an instance\nfield:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic int a;</p>\n<p>int b;\n}</p>\n<p>int f() =&gt; C.[!b!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you intend to access a static field, then change the name of the field\nto an existing static field:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic int a;</p>\n<p>int b;\n}</p>\n<p>int f() =&gt; C.a;\n{% endprettify %}</p>\n<p>If you intend to access the instance field, then use an instance of the\nclass to access the field:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic int a;</p>\n<p>int b;\n}</p>\n<p>int f(C c) =&gt; c.b;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#static_access_to_instance_member"
    },
    {
        "key": "strict_raw_type",
        "name": "Strict raw type",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The generic type '{0}' should have explicit type arguments but doesn't.\n\nUse explicit type arguments for '{0}'."
    },
    {
        "key": "subtype_of_deferred_class",
        "name": "Subtype of deferred class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Classes and mixins can't implement deferred classes.</em></p>\n<p><em>Classes can't extend deferred classes.</em></p>\n<p><em>Classes can't mixin deferred classes.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a type (class or mixin) is a\nsubtype of a class from a library being imported using a deferred import.\nThe supertypes of a type must be compiled at the same time as the type, and\nclasses from deferred libraries aren't compiled until the library is\nloaded.</p>\n<p>For more information, see the language tour's coverage of\n<a href=\"https://dart.dev/guides/language/language-tour#lazily-loading-a-library\">deferred loading</a>.</p>\n<h4>Example</h4>\n<p>Given a file (<code>a.dart</code>) that defines the class <code>A</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the superclass of <code>B</code>\nis declared in a deferred library:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' deferred as a;</p>\n<p>class B extends [!a.A!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to create a subtype of a type from the deferred library, then\nremove the <code>deferred</code> keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'a.dart' as a;</p>\n<p>class B extends a.A {}\n{% endprettify %}</p>"
    },
    {
        "key": "subtype_of_disallowed_type",
        "name": "Subtype of disallowed type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>''{0}' can't be used as a superclass constraint.</em></p>\n<p><em>Classes and mixins can't implement '{0}'.</em></p>\n<p><em>Classes can't extend '{0}'.</em></p>\n<p><em>Classes can't mixin '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when one of the restricted classes is\nused in either an <code>extends</code>, <code>implements</code>, <code>with</code>, or <code>on</code> clause. The\nclasses <code>bool</code>, <code>double</code>, <code>FutureOr</code>, <code>int</code>, <code>Null</code>, <code>num</code>, and <code>String</code>\nare all restricted in this way, to allow for more efficient\nimplementations.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>String</code> is used in an\n<code>extends</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A extends [!String!] {}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>String</code> is used in an\n<code>implements</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nclass B implements [!String!] {}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>String</code> is used in a\n<code>with</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C with [!String!] {}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>String</code> is used in an\n<code>on</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nmixin M on [!String!] {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If a different type should be specified, then replace the type:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A extends Object {}\n{% endprettify %}</p>\n<p>If there isn't a different type that would be appropriate, then remove the\ntype, and possibly the whole clause:</p>\n<p>{% prettify dart tag=pre+code %}\nclass B {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#subtype_of_disallowed_type"
    },
    {
        "key": "subtype_of_sealed_class",
        "name": "Subtype of sealed class",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The class '{0}' shouldn't be extended, mixed in, or implemented because it is sealed.\n\nTry composing instead of inheriting, or refer to its documentation for more information."
    },
    {
        "key": "super_goes_last",
        "name": "Place the `super` call last in a constructor initialization list.",
        "type": "CODE_SMELL",
        "status": "DEPRECATED",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</a>:</p>\n<p><strong>DO</strong> place the <code>super</code> call last in a constructor initialization list.</p>\n<p>Field initializers are evaluated in the order that they appear in the\nconstructor initialization list.  If you place a <code>super()</code> call in the middle of\nan initializer list, the superclass's initializers will be evaluated right then\nbefore evaluating the rest of the subclass's initializers.</p>\n<p>What it doesn't mean is that the superclass's constructor body will be executed\nthen.  That always happens after all initializers are run regardless of where\n<code>super</code> appears.  It's vanishingly rare that the order of initializers matters,\nso the placement of <code>super</code> in the list almost never matters either.</p>\n<p>Getting in the habit of placing it last improves consistency, visually\nreinforces when the superclass's constructor body is run, and may help\nperformance.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">View(Style style, List children)\n    : _children = children,\n      super(style) {\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">View(Style style, List children)\n    : super(style),\n      _children = children {\n</code></pre>\n<p><strong>DEPRECATED:</strong> In Dart 2, it is a compile-time error if a superinitializer\nappears in an initializer list at any other position than at the end so this\nrule is made redundant by the Dart analyzer's basic checks and is no longer\nnecessary.</p>\n<p>The rule will be removed in a future Linter release.</p>\n\n@see https://dart-lang.github.io/linter/lints/super_goes_last.html"
    },
    {
        "key": "super_in_extension",
        "name": "Super in extension",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The 'super' keyword can't be used in an extension because an extension doesn't\nhave a superclass.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a member declared inside an\nextension uses the <code>super</code> keyword . Extensions aren't classes and don't\nhave superclasses, so the <code>super</code> keyword serves no purpose.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>super</code> can't be used\nin an extension:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on Object {\nString get displayString =&gt; [!super!].toString();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the <code>super</code> keyword :</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on Object {\nString get displayString =&gt; toString();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#super_in_extension"
    },
    {
        "key": "super_in_invalid_context",
        "name": "Super in invalid context",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Invalid context for 'super' invocation.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the keyword <code>super</code> is used\noutside of a instance method.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>super</code> is used in a\ntop-level function:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\n[!super!].f();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Rewrite the code to not use <code>super</code>.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#super_in_invalid_context"
    },
    {
        "key": "super_in_redirecting_constructor",
        "name": "Super in redirecting constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The redirecting constructor can't have a 'super' initializer.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a constructor that redirects to\nanother constructor also attempts to invoke a constructor from the\nsuperclass. The superclass constructor will be invoked when the constructor\nthat the redirecting constructor is redirected to is invoked.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the constructor <code>C.a</code>\nboth redirects to <code>C.b</code> and invokes a constructor from the superclass:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a() : this.b(), [!super()!];\nC.b();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the invocation of the <code>super</code> constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC.a() : this.b();\nC.b();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#super_in_redirecting_constructor"
    },
    {
        "key": "super_initializer_in_object",
        "name": "Super initializer in object",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The class 'Object' can't invoke a constructor from a superclass.\n\nnull"
    },
    {
        "key": "switch_case_completes_normally",
        "name": "Switch case completes normally",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The 'case' should not complete normally.\n\nTry adding 'break', or 'return', etc."
    },
    {
        "key": "switch_expression_not_assignable",
        "name": "Switch expression not assignable",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Type '{0}' of the switch expression isn't assignable to the type '{1}' of case\nexpressions.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the type of the expression in a\n<code>switch</code> statement isn't assignable to the type of the expressions in the\n<code>case</code> clauses.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the type of <code>s</code>\n(<code>String</code>) isn't assignable to the type of <code>0</code> (<code>int</code>):</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String s) {\nswitch ([!s!]) {\ncase 0:\nbreak;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type of the <code>case</code> expressions is correct, then change the\nexpression in the <code>switch</code> statement to have the correct type:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String s) {\nswitch (int.parse(s)) {\ncase 0:\nbreak;\n}\n}\n{% endprettify %}</p>\n<p>If the type of the <code>switch</code> expression is correct, then change the <code>case</code>\nexpressions to have the correct type:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String s) {\nswitch (s) {\ncase '0':\nbreak;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#switch_expression_not_assignable"
    },
    {
        "key": "test_types_in_equals",
        "name": "Test type arguments in operator ==(Object other).",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DO</strong> test type arguments in operator ==(Object other).</p>\n<p>Not testing types might result in null pointer exceptions which will be\nunexpected for consumers of your class.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Field {\n}\n\nclass Good {\n  final Field someField;\n\n  Good(this.someField);\n\n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) {\n      return true;\n    }\n    return other is Good &amp;&amp;\n        this.someField == other.someField;\n  }\n\n  @override\n  int get hashCode {\n    return someField.hashCode;\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Field {\n}\n\nclass Bad {\n  final Field someField;\n\n  Bad(this.someField);\n\n  @override\n  bool operator ==(Object other) {\n    Bad otherBad = other as Bad; // LINT\n    bool areEqual = otherBad != null &amp;&amp; otherBad.someField == someField;\n    return areEqual;\n  }\n\n  @override\n  int get hashCode {\n    return someField.hashCode;\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/test_types_in_equals.html"
    },
    {
        "key": "throw_in_finally",
        "name": "Avoid `throw` in finally block.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>AVOID</strong> throwing exceptions in finally blocks.</p>\n<p>Throwing exceptions in finally blocks will inevitably cause unexpected behavior\nthat is hard to debug.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Ok {\n  double compliantMethod() {\n    var i = 5;\n    try {\n      i = 1 / 0;\n    } catch (e) {\n      print(e); // OK\n    }\n    return i;\n  }\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class BadThrow {\n  double nonCompliantMethod() {\n    try {\n      print('hello world! ${1 / 0}');\n    } catch (e) {\n      print(e);\n    } finally {\n      throw 'Find the hidden error :P'; // LINT\n    }\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/throw_in_finally.html"
    },
    {
        "key": "throw_of_invalid_type",
        "name": "Throw of invalid type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The type '{0}' of the thrown expression must be assignable to 'Object'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the type of the expression in a\nthrow expression isn't assignable to <code>Object</code>. It isn't valid to throw\n<code>null</code>, so it isn't valid to use an expression that might evaluate to\n<code>null</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>s</code> might be <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String? s) {\nthrow [!s!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add an explicit null check to the expression:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String? s) {\nthrow s!;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#throw_of_invalid_type"
    },
    {
        "key": "tighten_type_of_initializing_formals",
        "name": "Tighten type of initializing formal.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Tighten type of initializing formal if a non-null assert exists. This allows the\ntype system to catch problems rather than have them only be caught at run-time.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  A.c1(this.p) : assert(p != null);\n  A.c2(this.p);\n  final String? p;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A {\n  A.c1(String this.p) : assert(p != null);\n  A.c2(this.p);\n  final String? p;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/tighten_type_of_initializing_formals.html"
    },
    {
        "key": "todo",
        "name": "Todo",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "{0}\n\nnull"
    },
    {
        "key": "top_level_cycle",
        "name": "Top level cycle",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The type of '{0}' can't be inferred because it depends on itself through the cycle: {1}.\n\nTry adding an explicit type to one or more of the variables in the cycle in order to break the cycle."
    },
    {
        "key": "type_alias_cannot_reference_itself",
        "name": "Type alias cannot reference itself",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Typedefs can't reference themselves directly or recursively via another typedef.\n\nnull"
    },
    {
        "key": "type_annotate_public_apis",
        "name": "Type annotate public APIs.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From <a href=\"https://dart.dev/guides/language/effective-dart/design#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious\">effective dart</a>:</p>\n<p><strong>PREFER</strong> type annotating public APIs.</p>\n<p>Type annotations are important documentation for how a library should be used.\nAnnotating the parameter and return types of public methods and functions helps\nusers understand what the API expects and what it provides.</p>\n<p>Note that if a public API accepts a range of values that Dart's type system\ncannot express, then it is acceptable to leave that untyped.  In that case, the\nimplicit <code>dynamic</code> is the correct type for the API.</p>\n<p>For code internal to a library (either private, or things like nested functions)\nannotate where you feel it helps, but don't feel that you <em>must</em> provide them.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">install(id, destination) {\n  // ...\n}\n</code></pre>\n<p>Here, it's unclear what <code>id</code> is.  A string? And what is <code>destination</code>? A string\nor a <code>File</code> object? Is this method synchronous or asynchronous?</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Future&lt;bool&gt; install(PackageId id, String destination) {\n  // ...\n}\n</code></pre>\n<p>With types, all of this is clarified.</p>\n\n@see https://dart-lang.github.io/linter/lints/type_annotate_public_apis.html"
    },
    {
        "key": "type_annotation_deferred_class",
        "name": "Type annotation deferred class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The deferred type '{0}' can't be used in a declaration, cast, or type test.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the type annotation is in a\nvariable declaration, or the type used in a cast (<code>as</code>) or type test (<code>is</code>)\nis a type declared in a library that is imported using a deferred import.\nThese types are required to be available at compile time, but aren't.</p>\n<p>For more information, see the language tour's coverage of\n<a href=\"https://dart.dev/guides/language/language-tour#lazily-loading-a-library\">deferred loading</a>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the type of the\nparameter <code>f</code> is imported from a deferred library:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:io' deferred as io;</p>\n<p>void f([!io.File!] f) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to reference the imported type, then remove the <code>deferred</code>\nkeyword:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:io' as io;</p>\n<p>void f(io.File f) {}\n{% endprettify %}</p>\n<p>If the import is required to be deferred and there's another type that is\nappropriate, then use that type in place of the type from the deferred\nlibrary.</p>"
    },
    {
        "key": "type_argument_not_matching_bounds",
        "name": "Type argument not matching bounds",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>'{0}' doesn't conform to the bound '{2}' of the type parameter '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a type argument isn't the same\nas or a subclass of the bounds of the corresponding type parameter.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>String</code> isn't a\nsubclass of <code>num</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A<E extends num> {}</p>\n<p>var a = A&lt;[!String!]&gt;();\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the type argument to be a subclass of the bounds:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A<E extends num> {}</p>\n<p>var a = A<int>();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#type_argument_not_matching_bounds"
    },
    {
        "key": "type_check_is_not_null",
        "name": "Type check is not null",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Tests for non-null should be done with '!= null'.\n\nTry replacing the 'is! Null' check with '!= null'."
    },
    {
        "key": "type_check_is_null",
        "name": "Type check is null",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Tests for null should be done with '== null'.\n\nTry replacing the 'is Null' check with '== null'."
    },
    {
        "key": "type_init_formals",
        "name": "Don't type annotate initializing formals.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</a>:</p>\n<p><strong>DON'T</strong> type annotate initializing formals.</p>\n<p>If a constructor parameter is using <code>this.x</code> to initialize a field, then the\ntype of the parameter is understood to be the same type as the field.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  int x, y;\n  Point(this.x, this.y);\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Point {\n  int x, y;\n  Point(int this.x, int this.y);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/type_init_formals.html"
    },
    {
        "key": "type_parameter_referenced_by_static",
        "name": "Type parameter referenced by static",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Static members can't reference type parameters of the class.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a static member references a\ntype parameter that is declared for the class. Type parameters only have\nmeaning for instances of the class.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the static method\n<code>hasType</code> has a reference to the type parameter <code>T</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nstatic bool hasType(Object o) =&gt; o is [!T!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the member can be an instance member, then remove the keyword <code>static</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nbool hasType(Object o) =&gt; o is T;\n}\n{% endprettify %}</p>\n<p>If the member must be a static member, then make the member be generic:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<T> {\nstatic bool hasType<S>(Object o) =&gt; o is S;\n}\n{% endprettify %}</p>\n<p>Note, however, that there isnâ€™t a relationship between <code>T</code> and <code>S</code>, so this\nsecond option changes the semantics from what was likely to be intended.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#type_parameter_referenced_by_static"
    },
    {
        "key": "type_parameter_supertype_of_its_bound",
        "name": "Type parameter supertype of its bound",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't be a supertype of its upper bound.\n\nTry using a type that is or is a subclass of '{1}'."
    },
    {
        "key": "type_test_with_non_type",
        "name": "Type test with non type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The name '{0}' isn't a type and can't be used in an 'is' expression.\n\nTry correcting the name to match an existing type."
    },
    {
        "key": "type_test_with_undefined_name",
        "name": "Type test with undefined name",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' isn't defined, so it can't be used in an 'is' expression.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the name following the <code>is</code> in a\ntype test expression isn't defined.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the name <code>Srting</code> isn't\ndefined:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Object o) {\nif (o is [!Srting!]) {\n// ...\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Replace the name with the name of a type:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(Object o) {\nif (o is String) {\n// ...\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#type_test_with_undefined_name"
    },
    {
        "key": "unawaited_futures",
        "name": "`Future` results in `async` function bodies must be `await`ed or marked `unawaited` using `package:pedantic`.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> await functions that return a <code>Future</code> inside of an async function body.</p>\n<p>It's easy to forget await in async methods as naming conventions usually don't\ntell us if a method is sync or async (except for some in <code>dart:io</code>).</p>\n<p>When you really <em>do</em> want to start a fire-and-forget <code>Future</code>, the recommended\nway is to use <code>unawaited</code> from <code>package:pedantic</code>. The <code>// ignore</code> and\n<code>// ignore_for_file</code> comments also work.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Future doSomething() =&gt; ...;\n\nvoid main() async {\n  await doSomething();\n\n  unawaited(doSomething()); // Explicitly-ignored fire-and-forget.\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void main() async {\n  doSomething(); // Likely a bug.\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unawaited_futures.html"
    },
    {
        "key": "unchecked_use_of_nullable_value",
        "name": "Unchecked use of nullable value",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A nullable expression can't be used as a condition.</em></p>\n<p><em>A nullable expression can't be used as an iterator in a for-in loop.</em></p>\n<p><em>A nullable expression can't be used in a spread.</em></p>\n<p><em>A nullable expression can't be used in a yield-each statement.</em></p>\n<p><em>An expression whose value can be 'null' must be null-checked before it can be\ndereferenced.</em></p>\n<p><em>The function can't be unconditionally invoked because it can be 'null'.</em></p>\n<p><em>The method '{0}' can't be unconditionally invoked because the receiver can be\n'null'.</em></p>\n<p><em>The operator '{0}' can't be unconditionally invoked because the receiver can be\n'null'.</em></p>\n<p><em>The property '{0}' can't be unconditionally accessed because the receiver can\nbe 'null'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an expression whose type is\n<a href=\"https://dart.dev/tools/diagnostic-messages#potentially-non-nullable\">potentially non-nullable</a> is dereferenced without first verifying that\nthe value isn't <code>null</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>s</code> can be <code>null</code> at\nthe point where it's referenced:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String? s) {\nif (s.[!length!] &gt; 3) {\n// ...\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the value really can be <code>null</code>, then add a test to ensure that members\nare only accessed when the value isn't <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String? s) {\nif (s != null &amp;&amp; s.length &gt; 3) {\n// ...\n}\n}\n{% endprettify %}</p>\n<p>If the expression is a variable and the value should never be <code>null</code>, then\nchange the type of the variable to be non-nullable:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String s) {\nif (s.length &gt; 3) {\n// ...\n}\n}\n{% endprettify %}</p>\n<p>If you believe that the value of the expression should never be <code>null</code>, but\nyou can't change the type of the variable, and you're willing to risk\nhaving an exception thrown at runtime if you're wrong, then you can assert\nthat the value isn't null:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(String? s) {\nif (s!.length &gt; 3) {\n// ...\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unchecked_use_of_nullable_value"
    },
    {
        "key": "undefined_annotation",
        "name": "Undefined annotation",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Undefined name '{0}' used as an annotation.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a name that isn't defined is\nused as an annotation.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the name <code>undefined</code>\nisn't defined:</p>\n<p>{% prettify dart tag=pre+code %}\n[!@undefined!]\nvoid f() {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the name is correct, but it isnâ€™t declared yet, then declare the name as\na constant value:</p>\n<p>{% prettify dart tag=pre+code %}\nconst undefined = 'undefined';</p>\n<p>@undefined\nvoid f() {}\n{% endprettify %}</p>\n<p>If the name is wrong, replace the name with the name of a valid constant:</p>\n<p>{% prettify dart tag=pre+code %}\n@deprecated\nvoid f() {}\n{% endprettify %}</p>\n<p>Otherwise, remove the annotation.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_annotation"
    },
    {
        "key": "undefined_class",
        "name": "Undefined class",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Undefined class '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a class but either isn't defined or isn't visible\nin the scope in which it's being referenced.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>Piont</code> isn't defined:</p>\n<p>{% prettify dart tag=pre+code %}\nclass Point {}</p>\n<p>void f([!Piont!] p) {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the identifier isn't defined, then either define it or replace it with\nthe name of a class that is defined. The example above can be corrected by\nfixing the spelling of the class:</p>\n<p>{% prettify dart tag=pre+code %}\nclass Point {}</p>\n<p>void f(Point p) {}\n{% endprettify %}</p>\n<p>If the class is defined but isn't visible, then you probably need to add an\nimport.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_class"
    },
    {
        "key": "undefined_constructor_in_initializer",
        "name": "Undefined constructor in initializer",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The class '{0}' doesn't have a constructor named '{1}'.</em></p>\n<p><em>The class '{0}' doesn't have an unnamed constructor.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a superclass constructor is\ninvoked in the initializer list of a constructor, but the superclass\ndoesn't define the constructor being invoked.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>A</code> doesn't have an\nunnamed constructor:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA.n();\n}\nclass B extends A {\nB() : [!super()!];\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>A</code> doesn't have a\nconstructor named <code>m</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA.n();\n}\nclass B extends A {\nB() : [!super.m()!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the superclass defines a constructor that should be invoked, then change\nthe constructor being invoked:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA.n();\n}\nclass B extends A {\nB() : super.n();\n}\n{% endprettify %}</p>\n<p>If the superclass doesn't define an appropriate constructor, then define\nthe constructor being invoked:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nA.m();\nA.n();\n}\nclass B extends A {\nB() : super.m();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_constructor_in_initializer"
    },
    {
        "key": "undefined_enum_constant",
        "name": "Undefined enum constant",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>There's no constant named '{0}' in '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of an enum constant, and the name either isn't\ndefined or isn't visible in the scope in which it's being referenced.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>E</code> doesn't define a\nconstant named <code>c</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nenum E {a, b}</p>\n<p>var e = E.[!c!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the constant should be defined, then add it to the declaration of the\nenum:</p>\n<p>{% prettify dart tag=pre+code %}\nenum E {a, b, c}</p>\n<p>var e = E.c;\n{% endprettify %}</p>\n<p>If the constant shouldn't be defined, then change the name to the name of\nan existing constant:</p>\n<p>{% prettify dart tag=pre+code %}\nenum E {a, b}</p>\n<p>var e = E.b;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_enum_constant"
    },
    {
        "key": "undefined_extension_getter",
        "name": "Undefined extension getter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The getter '{0}' isn't defined for the extension '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension override is used to\ninvoke a getter, but the getter isn't defined by the specified extension.\nThe analyzer also produces this diagnostic when a static getter is\nreferenced but isn't defined by the specified extension.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the extension <code>E</code>\ndoesn't declare an instance getter named <code>b</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString get a =&gt; 'a';\n}</p>\n<p>extension F on String {\nString get b =&gt; 'b';\n}</p>\n<p>void f() {\nE('c').[!b!];\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the extension <code>E</code>\ndoesn't declare a static getter named <code>a</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {}</p>\n<p>var x = E.[!a!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the name of the getter is incorrect, then change it to the name of an\nexisting getter:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString get a =&gt; 'a';\n}</p>\n<p>extension F on String {\nString get b =&gt; 'b';\n}</p>\n<p>void f() {\nE('c').a;\n}\n{% endprettify %}</p>\n<p>If the name of the getter is correct but the name of the extension is\nwrong, then change the name of the extension to the correct name:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString get a =&gt; 'a';\n}</p>\n<p>extension F on String {\nString get b =&gt; 'b';\n}</p>\n<p>void f() {\nF('c').b;\n}\n{% endprettify %}</p>\n<p>If the name of the getter and extension are both correct, but the getter\nisn't defined, then define the getter:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString get a =&gt; 'a';\nString get b =&gt; 'z';\n}</p>\n<p>extension F on String {\nString get b =&gt; 'b';\n}</p>\n<p>void f() {\nE('c').b;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_extension_getter"
    },
    {
        "key": "undefined_extension_method",
        "name": "Undefined extension method",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The method '{0}' isn't defined for the extension '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension override is used to\ninvoke a method, but the method isn't defined by the specified extension.\nThe analyzer also produces this diagnostic when a static method is\nreferenced but isn't defined by the specified extension.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the extension <code>E</code>\ndoesn't declare an instance method named <code>b</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString a() =&gt; 'a';\n}</p>\n<p>extension F on String {\nString b() =&gt; 'b';\n}</p>\n<p>void f() {\nE('c').<a href=\"\">!b!</a>;\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the extension <code>E</code>\ndoesn't declare a static method named <code>a</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {}</p>\n<p>var x = E.<a href=\"\">!a!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the name of the method is incorrect, then change it to the name of an\nexisting method:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString a() =&gt; 'a';\n}</p>\n<p>extension F on String {\nString b() =&gt; 'b';\n}</p>\n<p>void f() {\nE('c').a();\n}\n{% endprettify %}</p>\n<p>If the name of the method is correct, but the name of the extension is\nwrong, then change the name of the extension to the correct name:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString a() =&gt; 'a';\n}</p>\n<p>extension F on String {\nString b() =&gt; 'b';\n}</p>\n<p>void f() {\nF('c').b();\n}\n{% endprettify %}</p>\n<p>If the name of the method and extension are both correct, but the method\nisn't defined, then define the method:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nString a() =&gt; 'a';\nString b() =&gt; 'z';\n}</p>\n<p>extension F on String {\nString b() =&gt; 'b';\n}</p>\n<p>void f() {\nE('c').b();\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_extension_method"
    },
    {
        "key": "undefined_extension_operator",
        "name": "Undefined extension operator",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The operator '{0}' isn't defined for the extension '{1}'.\n\nTry defining the operator '{0}'."
    },
    {
        "key": "undefined_extension_setter",
        "name": "Undefined extension setter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The setter '{0}' isn't defined for the extension '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an extension override is used to\ninvoke a setter, but the setter isn't defined by the specified extension.\nThe analyzer also produces this diagnostic when a static setter is\nreferenced but isn't defined by the specified extension.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the extension <code>E</code>\ndoesn't declare an instance setter named <code>b</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nset a(String v) {}\n}</p>\n<p>extension F on String {\nset b(String v) {}\n}</p>\n<p>void f() {\nE('c').[!b!] = 'd';\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the extension <code>E</code>\ndoesn't declare a static setter named <code>a</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {}</p>\n<p>void f() {\nE.[!a!] = 3;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the name of the setter is incorrect, then change it to the name of an\nexisting setter:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nset a(String v) {}\n}</p>\n<p>extension F on String {\nset b(String v) {}\n}</p>\n<p>void f() {\nE('c').a = 'd';\n}\n{% endprettify %}</p>\n<p>If the name of the setter is correct, but the name of the extension is\nwrong, then change the name of the extension to the correct name:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nset a(String v) {}\n}</p>\n<p>extension F on String {\nset b(String v) {}\n}</p>\n<p>void f() {\nF('c').b = 'd';\n}\n{% endprettify %}</p>\n<p>If the name of the setter and extension are both correct, but the setter\nisn't defined, then define the setter:</p>\n<p>{% prettify dart tag=pre+code %}\nextension E on String {\nset a(String v) {}\nset b(String v) {}\n}</p>\n<p>extension F on String {\nset b(String v) {}\n}</p>\n<p>void f() {\nE('c').b = 'd';\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_extension_setter"
    },
    {
        "key": "undefined_function",
        "name": "Undefined function",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The function '{0}' isn't defined.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a function but either isn't defined or isn't\nvisible in the scope in which it's being referenced.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the name <code>emty</code> isn't\ndefined:</p>\n<p>{% prettify dart tag=pre+code %}\nList<int> empty() =&gt; [];</p>\n<p>void main() {\nprint(<a href=\"\">!emty!</a>);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the identifier isn't defined, then either define it or replace it with\nthe name of a function that is defined. The example above can be corrected\nby fixing the spelling of the function:</p>\n<p>{% prettify dart tag=pre+code %}\nList<int> empty() =&gt; [];</p>\n<p>void main() {\nprint(empty());\n}\n{% endprettify %}</p>\n<p>If the function is defined but isn't visible, then you probably need to add\nan import or re-arrange your code to make the function visible.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_function"
    },
    {
        "key": "undefined_getter",
        "name": "Undefined getter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The getter '{0}' isn't defined for the type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a getter but either isn't defined or isn't\nvisible in the scope in which it's being referenced.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>String</code> has no member\nnamed <code>len</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint f(String s) =&gt; s.[!len!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the identifier isn't defined, then either define it or replace it with\nthe name of a getter that is defined. The example above can be corrected by\nfixing the spelling of the getter:</p>\n<p>{% prettify dart tag=pre+code %}\nint f(String s) =&gt; s.length;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_getter"
    },
    {
        "key": "undefined_hidden_name",
        "name": "Undefined hidden name",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The library '{0}' doesn't export a member with the hidden name '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a hide combinator includes a\nname that isn't defined by the library being imported.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>dart:math</code> doesn't\ndefine the name <code>String</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' hide [!String!], max;</p>\n<p>var x = min(0, 1);\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If a different name should be hidden, then correct the name. Otherwise,\nremove the name from the list:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' hide max;</p>\n<p>var x = min(0, 1);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_hidden_name"
    },
    {
        "key": "undefined_identifier",
        "name": "Undefined identifier",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Undefined name '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it encounters an identifier that\neither isn't defined or isn't visible in the scope in which it's being\nreferenced.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the name <code>rihgt</code> isn't\ndefined:</p>\n<p>{% prettify dart tag=pre+code %}\nint min(int left, int right) =&gt; left &lt;= [!rihgt!] ? left : right;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the identifier isn't defined, then either define it or replace it with\nan identifier that is defined. The example above can be corrected by\nfixing the spelling of the variable:</p>\n<p>{% prettify dart tag=pre+code %}\nint min(int left, int right) =&gt; left &lt;= right ? left : right;\n{% endprettify %}</p>\n<p>If the identifier is defined but isn't visible, then you probably need to\nadd an import or re-arrange your code to make the identifier visible.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_identifier"
    },
    {
        "key": "undefined_identifier_await",
        "name": "Undefined identifier await",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Undefined name 'await' in function body not marked with 'async'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the name <code>await</code> is used in a\nmethod or function body without being declared, and the body isn't marked\nwith the <code>async</code> keyword. The name <code>await</code> only introduces an await\nexpression in an asynchronous function.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the name <code>await</code> is\nused in the body of <code>f</code> even though the body of <code>f</code> isn't marked with the\n<code>async</code> keyword:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(p) { [!await!] p; }\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add the keyword <code>async</code> to the function body:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(p) async { await p; }\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_identifier_await"
    },
    {
        "key": "undefined_method",
        "name": "Undefined method",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The method '{0}' isn't defined for the type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a method but either isn't defined or isn't\nvisible in the scope in which it's being referenced.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the identifier\n<code>removeMiddle</code> isn't defined:</p>\n<p>{% prettify dart tag=pre+code %}\nint f(List<int> l) =&gt; l.<a href=\"\">!removeMiddle!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the identifier isn't defined, then either define it or replace it with\nthe name of a method that is defined. The example above can be corrected by\nfixing the spelling of the method:</p>\n<p>{% prettify dart tag=pre+code %}\nint f(List<int> l) =&gt; l.removeLast();\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_method"
    },
    {
        "key": "undefined_named_parameter",
        "name": "Undefined named parameter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The named parameter '{0}' isn't defined.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a method or function invocation\nhas a named argument, but the method or function being invoked doesn't\ndefine a parameter with the same name.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>m</code> doesn't declare a\nnamed parameter named <code>a</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nm({int b}) {}\n}</p>\n<p>void f(C c) {\nc.m([!a!]: 1);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the argument name is mistyped, then replace it with the correct name.\nThe example above can be fixed by changing <code>a</code> to <code>b</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nm({int b}) {}\n}</p>\n<p>void f(C c) {\nc.m(b: 1);\n}\n{% endprettify %}</p>\n<p>If a subclass adds a parameter with the name in question, then cast the\nreceiver to the subclass:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nm({int b}) {}\n}</p>\n<p>class D extends C {\nm({int a, int b}) {}\n}</p>\n<p>void f(C c) {\n(c as D).m(a: 1);\n}\n{% endprettify %}</p>\n<p>If the parameter should be added to the function, then add it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nm({int a, int b}) {}\n}</p>\n<p>void f(C c) {\nc.m(a: 1);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_named_parameter"
    },
    {
        "key": "undefined_operator",
        "name": "Undefined operator",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The operator '{0}' isn't defined for the type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a user-definable operator is\ninvoked on an object for which the operator isn't defined.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the class <code>C</code> doesn't\ndefine the operator <code>+</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {}</p>\n<p>C f(C c) =&gt; c [!+!] 2;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the operator should be defined for the class, then define it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nC operator +(int i) =&gt; this;\n}</p>\n<p>C f(C c) =&gt; c + 2;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_operator"
    },
    {
        "key": "undefined_prefixed_name",
        "name": "Undefined prefixed name",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The name '{0}' is being referenced through the prefix '{1}', but it isn't\ndefined in any of the libraries imported using that prefix.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a prefixed identifier is found\nwhere the prefix is valid, but the identifier isn't declared in any of the\nlibraries imported using that prefix.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>dart:core</code> doesn't\ndefine anything named <code>a</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:core' as p;</p>\n<p>void f() {\np.[!a!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the library in which the name is declared isn't imported yet, add an\nimport for the library.</p>\n<p>If the name is wrong, then change it to one of the names that's declared in\nthe imported libraries.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_prefixed_name"
    },
    {
        "key": "undefined_setter",
        "name": "Undefined setter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The setter '{0}' isn't defined for the type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it encounters an identifier that\nappears to be the name of a setter but either isn't defined or isn't\nvisible in the scope in which the identifier is being referenced.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because there isn't a setter\nnamed <code>z</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x = 0;\nvoid m(int y) {\nthis.[!z!] = y;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the identifier isn't defined, then either define it or replace it with\nthe name of a setter that is defined. The example above can be corrected by\nfixing the spelling of the setter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint x = 0;\nvoid m(int y) {\nthis.x = y;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_setter"
    },
    {
        "key": "undefined_shown_name",
        "name": "Undefined shown name",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The library '{0}' doesn't export a member with the shown name '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a show combinator includes a\nname that isn't defined by the library being imported.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>dart:math</code> doesn't\ndefine the name <code>String</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' show min, [!String!];</p>\n<p>var x = min(0, 1);\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If a different name should be shown, then correct the name. Otherwise,\nremove the name from the list:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' show min;</p>\n<p>var x = min(0, 1);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_shown_name"
    },
    {
        "key": "undefined_super_member",
        "name": "Undefined super member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The getter '{0}' isn't defined in a superclass of '{1}'.</em></p>\n<p><em>The method '{0}' isn't defined in a superclass of '{1}'.</em></p>\n<p><em>The operator '{0}' isn't defined in a superclass of '{1}'.</em></p>\n<p><em>The setter '{0}' isn't defined in a superclass of '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an inherited member (method,\ngetter, setter, or operator) is referenced using <code>super</code>, but thereâ€™s no\nmember with that name in the superclass chain.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>Object</code> doesn't define\na method named <code>n</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nvoid m() {\nsuper.<a href=\"\">!n!</a>;\n  }\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>Object</code> doesn't define\na getter named <code>g</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nvoid m() {\nsuper.[!g!];\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the inherited member you intend to invoke has a different name, then\nmake the name of the invoked member match the inherited member.</p>\n<p>If the member you intend to invoke is defined in the same class, then\nremove the <code>super.</code>.</p>\n<p>If the member isnâ€™t defined, then either add the member to one of the\nsuperclasses or remove the invocation.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#undefined_super_member"
    },
    {
        "key": "unignorable_ignore",
        "name": "Unignorable ignore",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The diagnostic '{0}' can't be ignored.\n\nTry removing the name from the list, or removing the whole comment if this is the only name in the list."
    },
    {
        "key": "unnecessary_await_in_return",
        "name": "Unnecessary await keyword in return.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Avoid returning an awaited expression when the expression type is assignable to\nthe function's return type.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Future&lt;int&gt; future;\nFuture&lt;int&gt; f1() async =&gt; await future;\nFuture&lt;int&gt; f2() async {\n  return await future;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Future&lt;int&gt; future;\nFuture&lt;int&gt; f1() =&gt; future;\nFuture&lt;int&gt; f2() {\n  return future;\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_await_in_return.html"
    },
    {
        "key": "unnecessary_brace_in_string_interps",
        "name": "Avoid using braces in interpolation when not needed.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> using braces in interpolation when not needed.</p>\n<p>If you're just interpolating a simple identifier, and it's not immediately\nfollowed by more alphanumeric text, the <code>{}</code> can and should be omitted.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">print(\"Hi, $name!\");\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">print(\"Hi, ${name}!\");\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_brace_in_string_interps.html"
    },
    {
        "key": "unnecessary_cast",
        "name": "Unnecessary cast",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Unnecessary cast.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the value being cast is already\nknown to be of the type that it's being cast to.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>n</code> is already known to\nbe an <code>int</code> as a result of the <code>is</code> test:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(num n) {\nif (n is int) {\n([!n as int!]).isEven;\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the unnecessary cast:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(num n) {\nif (n is int) {\nn.isEven;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unnecessary_cast"
    },
    {
        "key": "unnecessary_const",
        "name": "Avoid const keyword.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> repeating const keyword in a const context.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A { const A(); }\nm(){\n  const a = const A();\n  final b = const [const A()];\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A { const A(); }\nm(){\n  const a = A();\n  final b = const [A()];\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_const.html"
    },
    {
        "key": "unnecessary_final",
        "name": "Don't use `final` for local variables.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> use <code>final</code> for local variables.</p>\n<p><code>var</code> is shorter, and <code>final</code> does not change the meaning of the code.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void badMethod() {\n  final label = 'Final or var?';\n  for (final char in ['v', 'a', 'r']) {\n    print(char);\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void goodMethod() {\n  var label = 'Final or var?';\n  for (var char in ['v', 'a', 'r']) {\n    print(char);\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_final.html"
    },
    {
        "key": "unnecessary_getters_setters",
        "name": "Avoid wrapping fields in getters and setters just to be \"safe\".",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</a>:</p>\n<p><strong>AVOID</strong> wrapping fields in getters and setters just to be \"safe\".</p>\n<p>In Java and C#, it's common to hide all fields behind getters and setters (or\nproperties in C#), even if the implementation just forwards to the field.  That\nway, if you ever need to do more work in those members, you can do it without needing\nto touch the callsites.  This is because calling a getter method is different\nthan accessing a field in Java, and accessing a property isn't binary-compatible\nwith accessing a raw field in C#.</p>\n<p>Dart doesn't have this limitation.  Fields and getters/setters are completely\nindistinguishable.  You can expose a field in a class and later wrap it in a\ngetter and setter without having to touch any code that uses that field.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Box {\n  var contents;\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Box {\n  var _contents;\n  get contents =&gt; _contents;\n  set contents(value) {\n    _contents = value;\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_getters_setters.html"
    },
    {
        "key": "unnecessary_ignore",
        "name": "Unnecessary ignore",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The diagnostic '{0}' isn't produced at this location so it doesn't need to be ignored.\n\nTry removing the name from the list, or removing the whole comment if this is the only name in the list."
    },
    {
        "key": "unnecessary_lambdas",
        "name": "Don't create a lambda when a tear-off will do.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> create a lambda when a tear-off will do.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">names.forEach((name) {\n  print(name);\n});\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">names.forEach(print);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_lambdas.html"
    },
    {
        "key": "unnecessary_new",
        "name": "Unnecessary new keyword.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> new keyword to create instances.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A { A(); }\nm(){\n  final a = new A();\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A { A(); }\nm(){\n  final a = A();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_new.html"
    },
    {
        "key": "unnecessary_no_such_method",
        "name": "Unnecessary no such method",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "Unnecessary 'noSuchMethod' declaration.\n\nTry removing the declaration of 'noSuchMethod'."
    },
    {
        "key": "unnecessary_non_null_assertion",
        "name": "Unnecessary non null assertion",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The '!' will have no effect because the receiver can't be null.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the operand of the <code>!</code> operator\ncan't be <code>null</code>.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>x</code> can't be <code>null</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nint f(int x) {\nreturn x[!!!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the null check operator (<code>!</code>):</p>\n<p>{% prettify dart tag=pre+code %}\nint f(int x) {\nreturn x;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unnecessary_non_null_assertion"
    },
    {
        "key": "unnecessary_null_aware_assignments",
        "name": "Avoid null in null-aware assignment.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> <code>null</code> in null-aware assignment.</p>\n<p>Using <code>null</code> on the right-hand side of a null-aware assignment effectively makes\nthe assignment redundant.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var x;\nx ??= 1;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var x;\nx ??= null;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_null_aware_assignments.html"
    },
    {
        "key": "unnecessary_null_checks",
        "name": "Unnecessary null checks.",
        "type": "CODE_SMELL",
        "status": "BETA",
        "severity": "MINOR",
        "description": "<p>Don't apply a null check when a nullable value is accepted.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">f(int? i);\nm() {\n  int? j;\n  f(j!);\n}\n\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">f(int? i);\nm() {\n  int? j;\n  f(j);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_null_checks.html"
    },
    {
        "key": "unnecessary_null_comparison",
        "name": "Unnecessary null comparison",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The operand can't be null, so the condition is always false.</em></p>\n<p><em>The operand can't be null, so the condition is always true.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds an equality comparison\n(either <code>==</code> or <code>!=</code>) with one operand of <code>null</code> and the other operand\ncan't be <code>null</code>. Such comparisons are always either <code>true</code> or <code>false</code>, so\nthey serve no purpose.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because <code>x</code> can never be\n<code>null</code>, so the comparison always evaluates to <code>true</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int x) {\nif (x [!!= null!]) {\nprint(x);\n}\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>x</code> can never be\n<code>null</code>, so the comparison always evaluates to <code>false</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int x) {\nif (x [!== null!]) {\nthrow ArgumentError(\"x can't be null\");\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the other operand should be able to be <code>null</code>, then change the type of\nthe operand:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int? x) {\nif (x != null) {\nprint(x);\n}\n}\n{% endprettify %}</p>\n<p>If the other operand really can't be <code>null</code>, then remove the condition:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int x) {\nprint(x);\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unnecessary_null_comparison"
    },
    {
        "key": "unnecessary_null_in_if_null_operators",
        "name": "Avoid using `null` in `if null` operators.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> using <code>null</code> as an operand in <code>if null</code> operators.</p>\n<p>Using <code>null</code> in an <code>if null</code> operator is redundant, regardless of which side\n<code>null</code> is used on.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var x = a ?? 1;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var x = a ?? null;\nvar y = null ?? 1;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_null_in_if_null_operators.html"
    },
    {
        "key": "unnecessary_nullable_for_final_variable_declarations",
        "name": "Use a non-nullable type for a final variable initialized with a non-nullable value.",
        "type": "CODE_SMELL",
        "status": "BETA",
        "severity": "MINOR",
        "description": "<p>Use a non-nullable type for a final variable initialized with a non-nullable\nvalue.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">final int? i = 1;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">final int i = 1;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_nullable_for_final_variable_declarations.html"
    },
    {
        "key": "unnecessary_overrides",
        "name": "Don't override a method to do a super method invocation with the same parameters.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DON'T</strong> override a method to do a super method invocation with same parameters.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A extends B {\n  @override\n  void foo() {\n    super.foo();\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class A extends B {\n  @override\n  void foo() {\n    doSomethingElse();\n  }\n}\n</code></pre>\n<p>It's valid to override a member in the following cases:</p>\n<ul>\n<li>if a type (return type or a parameter type) is not the exactly the same as the\nsuper method,</li>\n<li>if the <code>covariant</code> keyword is added to one of the parameters,</li>\n<li>if documentation comments are present on the member,</li>\n<li>if the member has annotations other than <code>@override</code>.</li>\n</ul>\n<p><code>noSuchMethod</code> is a special method and is not checked by this rule.</p>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_overrides.html"
    },
    {
        "key": "unnecessary_parenthesis",
        "name": "Unnecessary parenthesis can be removed.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>AVOID</strong> using parenthesis when not needed.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">a = b;\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">a = (b);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_parenthesis.html"
    },
    {
        "key": "unnecessary_question_mark",
        "name": "Unnecessary question mark",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "The '?' is unnecessary because '{0}' is nullable without it.\n\nnull"
    },
    {
        "key": "unnecessary_raw_strings",
        "name": "Unnecessary raw string.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Use raw string only when needed.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var s1 = r'a';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var s1 = 'a';\nvar s2 = r'$a';\nvar s3 = r'\\a';\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_raw_strings.html"
    },
    {
        "key": "unnecessary_statements",
        "name": "Avoid using unnecessary statements.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>AVOID</strong> using unnecessary statements.</p>\n<p>Statements which have no clear effect are usually unnecessary, or should be\nbroken up.</p>\n<p>For example,</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">myvar;\nlist.clear;\n1 + 2;\nmethodOne() + methodTwo();\nfoo ? bar : baz;\n</code></pre>\n<p>Though the added methods have a clear effect, the addition itself does not\nunless there is some magical overload of the + operator.</p>\n<p>Usually code like this indicates an incomplete thought, and is a bug.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">some.method();\nconst SomeClass();\nmethodOne();\nmethodTwo();\nfoo ? bar() : baz();\nreturn myvar;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_statements.html"
    },
    {
        "key": "unnecessary_string_escapes",
        "name": "Remove unnecessary backslashes in strings.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Remove unnecessary backslashes in strings.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">'this string contains 2 \\\"double quotes\\\" ';\n\"this string contains 2 \\'single quotes\\' \";\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">'this string contains 2 \"double quotes\" ';\n\"this string contains 2 'single quotes' \";\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_string_escapes.html"
    },
    {
        "key": "unnecessary_string_interpolations",
        "name": "Unnecessary string interpolation.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Don't use string interpolation if there's only a string expression in it.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">String message;\nString o = '$message';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">String message;\nString o = message;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_string_interpolations.html"
    },
    {
        "key": "unnecessary_this",
        "name": "Don't access members with `this` unless avoiding shadowing.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/style/\">style guide</a>:</p>\n<p><strong>DON'T</strong> use <code>this</code> when not needed to avoid shadowing.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Box {\n  var value;\n  void update(new_value) {\n    this.value = new_value;\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Box {\n  var value;\n  void update(new_value) {\n    value = new_value;\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Box {\n  var value;\n  void update(value) {\n    this.value = value;\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unnecessary_this.html"
    },
    {
        "key": "unnecessary_type_check",
        "name": "Unnecessary type check",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Unnecessary type check; the result is always 'false'.</em></p>\n<p><em>Unnecessary type check; the result is always 'true'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the value of a type check (using\neither <code>is</code> or <code>is!</code>) is known at compile time.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the test <code>a is Object?</code>\nis always <code>true</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nbool f<T>(T a) =&gt; [!a is Object?!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type check doesn't check what you intended to check, then change the\ntest:</p>\n<p>{% prettify dart tag=pre+code %}\nbool f<T>(T a) =&gt; a is Object;\n{% endprettify %}</p>\n<p>If the type check does check what you intended to check, then replace the\ntype check with its known value or completely remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nbool f<T>(T a) =&gt; true;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unnecessary_type_check"
    },
    {
        "key": "unqualified_reference_to_non_local_static_member",
        "name": "Unqualified reference to non local static member",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Static members from supertypes must be qualified by the name of the defining\ntype.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when code in one class references a\nstatic member in a superclass without prefixing the member's name with the\nname of the superclass. Static members can only be referenced without a\nprefix in the class in which they're declared.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the static field <code>x</code> is\nreferenced in the getter <code>g</code> without prefixing it with the name of the\ndefining class:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nstatic int x = 3;\n}</p>\n<p>class B extends A {\nint get g =&gt; [!x!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Prefix the name of the static member with the name of the declaring class:</p>\n<p>{% prettify dart tag=pre+code %}\nclass A {\nstatic int x = 3;\n}</p>\n<p>class B extends A {\nint get g =&gt; A.x;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unqualified_reference_to_non_local_static_member"
    },
    {
        "key": "unqualified_reference_to_static_member_of_extended_type",
        "name": "Unqualified reference to static member of extended type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Static members from the extended type or one of its superclasses must be\nqualified by the name of the defining type.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an undefined name is found, and\nthe name is the same as a static member of the extended type or one of its\nsuperclasses.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>m</code> is a static member\nof the extended type <code>C</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic void m() {}\n}</p>\n<p>extension E on C {\nvoid f() {\n<a href=\"\">!m!</a>;\n  }\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you're trying to reference a static member that's declared outside the\nextension, then add the name of the class or extension before the reference\nto the member:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic void m() {}\n}</p>\n<p>extension E on C {\nvoid f() {\nC.m();\n}\n}\n{% endprettify %}</p>\n<p>If you're referencing a member that isn't declared yet, add a declaration:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nstatic void m() {}\n}</p>\n<p>extension E on C {\nvoid f() {\nm();\n}</p>\n<p>void m() {}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unqualified_reference_to_static_member_of_extended_type"
    },
    {
        "key": "unrelated_type_equality_checks",
        "name": "Equality operator `==` invocation with references of unrelated types.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DON'T</strong> Compare references of unrelated types for equality.</p>\n<p>Comparing references of a type where neither is a subtype of the other most\nlikely will return <code>false</code> and might not reflect programmer's intent.</p>\n<p><code>Int64</code> and <code>Int32</code> from <code>package:fixnum</code> allow comparing to <code>int</code> provided\nthe <code>int</code> is on the right hand side. The lint allows this as a special case.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction() {\n  var x = '1';\n  if (x == 1) print('someFunction'); // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction1() {\n  String x = '1';\n  if (x == 1) print('someFunction1'); // LINT\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction13(DerivedClass2 instance) {\n  var other = DerivedClass3();\n\n  if (other == instance) print('someFunction13'); // LINT\n}\n\nclass ClassBase {}\n\nclass DerivedClass1 extends ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n\nclass DerivedClass3 extends ClassBase implements Mixin {}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction2() {\n  var x = '1';\n  var y = '2';\n  if (x == y) print(someFunction2); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction3() {\n  for (var i = 0; i &lt; 10; i++) {\n    if (i == 0) print(someFunction3); // OK\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction4() {\n  var x = '1';\n  if (x == null) print(someFunction4); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction7() {\n  List someList;\n\n  if (someList.length == 0) print('someFunction7'); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction8(ClassBase instance) {\n  DerivedClass1 other;\n\n  if (other == instance) print('someFunction8'); // OK\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction10(unknown) {\n  var what = unknown - 1;\n  for (var index = 0; index &lt; unknown; index++) {\n    if (what == index) print('someFunction10'); // OK\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void someFunction11(Mixin instance) {\n  var other = DerivedClass2();\n\n  if (other == instance) print('someFunction11'); // OK\n  if (other != instance) print('!someFunction11'); // OK\n}\n\nclass ClassBase {}\n\nabstract class Mixin {}\n\nclass DerivedClass2 extends ClassBase with Mixin {}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unrelated_type_equality_checks.html"
    },
    {
        "key": "unsafe_html",
        "name": "Avoid unsafe HTML APIs.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>AVOID</strong></p>\n<ul>\n<li>assigning directly to the <code>href</code> field of an AnchorElement</li>\n<li>assigning directly to the <code>src</code> field of an EmbedElement, IFrameElement,\nImageElement, or ScriptElement</li>\n<li>assigning directly to the <code>srcdoc</code> field of an IFrameElement</li>\n<li>calling the <code>createFragment</code> method of Element</li>\n<li>calling the <code>open</code> method of Window</li>\n<li>calling the <code>setInnerHtml</code> method of Element</li>\n<li>calling the <code>Element.html</code> constructor</li>\n<li>calling the <code>DocumentFragment.html</code> constructor</li>\n</ul>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var script = ScriptElement()..src = 'foo.js';\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/unsafe_html.html"
    },
    {
        "key": "unused_catch_clause",
        "name": "Unused catch clause",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The exception variable '{0}' isn't used, so the 'catch' clause can be removed.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a <code>catch</code> clause is found, and\nneither the exception parameter nor the optional stack trace parameter are\nused in the <code>catch</code> block.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>e</code> isn't referenced:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\nint.parse(';');\n} on FormatException catch ([!e!]) {\n// ignored\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the unused <code>catch</code> clause:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\nint.parse(';');\n} on FormatException {\n// ignored\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unused_catch_clause"
    },
    {
        "key": "unused_catch_stack",
        "name": "Unused catch stack",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The stack trace variable '{0}' isn't used and can be removed.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the stack trace parameter in a\n<code>catch</code> clause isn't referenced within the body of the <code>catch</code> block.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>stackTrace</code> isn't\nreferenced:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n// ...\n} catch (exception, [!stackTrace!]) {\n// ...\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If you need to reference the stack trace parameter, then add a reference to\nit. Otherwise, remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {\ntry {\n// ...\n} catch (exception) {\n// ...\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unused_catch_stack"
    },
    {
        "key": "unused_element",
        "name": "Unused element",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>A value for optional parameter '{0}' isn't ever given.</em></p>\n<p><em>The declaration '{0}' isn't referenced.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a private declaration isn't\nreferenced in the library that contains the declaration. The following\nkinds of declarations are analyzed:</p>\n<ul>\n<li>Private top-level declarations, such as classes, enums, mixins, typedefs,\ntop-level variables, and top-level functions</li>\n<li>Private static and instance methods</li>\n<li>Optional parameters of private functions for which a value is never\npassed, even when the parameter doesn't have a private name</li>\n</ul>\n<h4>Examples</h4>\n<p>Assuming that no code in the library references <code>_C</code>, the following code\nproduces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nclass [!_C!] {}\n{% endprettify %}</p>\n<p>Assuming that no code in the library passes a value for <code>y</code> in any\ninvocation of <code>_m</code>, the following code produces this diagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nvoid _m(int x, [int [!y!]]) {}</p>\n<p>void n() =&gt; _m(0);\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the declaration isn't needed, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nvoid _m(int x) {}</p>\n<p>void n() =&gt; _m(0);\n}\n{% endprettify %}</p>\n<p>If the declaration is intended to be used, then add the code to use it.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unused_element"
    },
    {
        "key": "unused_field",
        "name": "Unused field",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The value of the field '{0}' isn't used.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a private field is declared but\nnever read, even if it's written in one or more places.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>_x</code> isn't referenced\nanywhere in the library:</p>\n<p>{% prettify dart tag=pre+code %}\nclass Point {\nint [!_x!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the field isn't needed, then remove it.</p>\n<p>If the field was intended to be used, then add the missing code.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unused_field"
    },
    {
        "key": "unused_import",
        "name": "Unused import",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>Unused import: '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an import isn't needed because\nnone of the names that are imported are referenced within the importing\nlibrary.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because nothing defined in\n<code>dart:async</code> is referenced in the library:</p>\n<p>{% prettify dart tag=pre+code %}\nimport [!'dart:async'!];</p>\n<p>void main() {}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the import isn't needed, then remove it.</p>\n<p>If some of the imported names are intended to be used, then add the missing\ncode.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unused_import"
    },
    {
        "key": "unused_label",
        "name": "Unused label",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The label '{0}' isn't used.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a label that isn't used is\nfound.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the label <code>loop</code> isn't\nreferenced anywhere in the method:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int limit) {\n[!loop:!] for (int i = 0; i &lt; limit; i++) {\nprint(i);\n}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the label isn't needed, then remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int limit) {\nfor (int i = 0; i &lt; limit; i++) {\nprint(i);\n}\n}\n{% endprettify %}</p>\n<p>If the label is needed, then use it:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f(int limit) {\nloop: for (int i = 0; i &lt; limit; i++) {\nprint(i);\nbreak loop;\n}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unused_label"
    },
    {
        "key": "unused_local_variable",
        "name": "Unused local variable",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The value of the local variable '{0}' isn't used.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a local variable is declared but\nnever read, even if it's written in one or more places.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the value of <code>count</code> is\nnever read:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid main() {\nint [!count!] = 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the variable isn't needed, then remove it.</p>\n<p>If the variable was intended to be used, then add the missing code.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unused_local_variable"
    },
    {
        "key": "unused_shown_name",
        "name": "Unused shown name",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><em>The name {0} is shown, but isnâ€™t used.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a show combinator includes a\nname that isn't used within the library. Because it isn't referenced, the\nname can be removed.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the function <code>max</code>\nisn't used:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' show min, [!max!];</p>\n<p>var x = min(0, 1);\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Either use the name or remove it:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math' show min;</p>\n<p>var x = min(0, 1);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#unused_shown_name"
    },
    {
        "key": "uri_does_not_exist",
        "name": "Uri does not exist",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Target of URI doesn't exist: '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an import, export, or part\ndirective is found where the URI refers to a file that doesn't exist.</p>\n<h4>Examples</h4>\n<p>If the file <code>lib.dart</code> doesn't exist, the following code produces this\ndiagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nimport [!'lib.dart'!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the URI was mistyped or invalid, then correct the URI.</p>\n<p>If the URI is correct, then create the file.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#uri_does_not_exist"
    },
    {
        "key": "uri_has_not_been_generated",
        "name": "Uri has not been generated",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Target of URI hasn't been generated: '{0}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when an import, export, or part\ndirective is found where the URI refers to a file that doesn't exist and\nthe name of the file ends with a pattern that's commonly produced by code\ngenerators, such as one of the following:</p>\n<ul>\n<li><code>.g.dart</code></li>\n<li><code>.pb.dart</code></li>\n<li><code>.pbenum.dart</code></li>\n<li><code>.pbserver.dart</code></li>\n<li><code>.pbjson.dart</code></li>\n<li><code>.template.dart</code></li>\n</ul>\n<h4>Examples</h4>\n<p>If the file <code>lib.g.dart</code> doesn't exist, the following code produces this\ndiagnostic:</p>\n<p>{% prettify dart tag=pre+code %}\nimport [!'lib.g.dart'!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the file is a generated file, then run the generator that generates the\nfile.</p>\n<p>If the file isn't a generated file, then check the spelling of the URI or\ncreate the file.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#uri_has_not_been_generated"
    },
    {
        "key": "uri_with_interpolation",
        "name": "Uri with interpolation",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>URIs can't use string interpolation.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the string literal in an\n<code>import</code>, <code>export</code>, or <code>part</code> directive contains an interpolation. The\nresolution of the URIs in directives must happen before the declarations\nare compiled, so expressions canâ€™t be  evaluated  while determining the\nvalues of the URIs.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the string in the\n<code>import</code> directive contains an interpolation:</p>\n<p>{% prettify dart tag=pre+code %}\nimport [!'dart:$m'!];</p>\n<p>const m = 'math';\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Remove the interpolation from the URI:</p>\n<p>{% prettify dart tag=pre+code %}\nimport 'dart:math';</p>\n<p>var zero = min(0, 0);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#uri_with_interpolation"
    },
    {
        "key": "use_build_context_synchronously",
        "name": "Do not use BuildContexts across async gaps.",
        "type": "BUG",
        "status": "BETA",
        "severity": "CRITICAL",
        "description": "<p><strong>DO NOT</strong> use BuildContext across asynchronous gaps.</p>\n<p>Storing <code>BuildContext</code> for later usage can easily lead to difficult to diagnose\ncrashes. Asynchronous gaps are implicitly storing <code>BuildContext</code> and are some of\nthe easiest to overlook when writing code.</p>\n<p>When a <code>BuildContext</code> is used from a <code>StatefulWidget</code>, the <code>mounted</code> property\nmust be checked after an asynchronous gap.</p>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">void onButtonTapped(BuildContext context) {\n  Navigator.of(context).pop();\n}\n</code></pre>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">void onButtonTapped(BuildContext context) async {\n  await Future.delayed(const Duration(seconds: 1));\n  Navigator.of(context).pop();\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class _MyWidgetState extends State&lt;MyWidget&gt; {\n  ...\n\n  void onButtonTapped() async {\n    await Future.delayed(const Duration(seconds: 1));\n\n    if (!mounted) return;\n    Navigator.of(context).pop();\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_build_context_synchronously.html"
    },
    {
        "key": "use_full_hex_values_for_flutter_colors",
        "name": "Prefer an 8-digit hexadecimal integer(0xFFFFFFFF) to instantiate Color.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Prefer an 8-digit hexadecimal integer(0xFFFFFFFF) to instantiate Color. Colors\nhave four 8-bit channels, which adds up to 32 bits, so Colors are described\nusing a 32 bit integer.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Color(1);\nColor(0x000001);\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Color(0x00000001);\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_full_hex_values_for_flutter_colors.html"
    },
    {
        "key": "use_function_type_syntax_for_parameters",
        "name": "Use generic function type syntax for parameters.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Use generic function type syntax for parameters.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">Iterable&lt;T&gt; where(bool predicate(T element)) {}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Iterable&lt;T&gt; where(bool Function(T) predicate) {}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_function_type_syntax_for_parameters.html"
    },
    {
        "key": "use_if_null_to_convert_nulls_to_bools",
        "name": "Use if-null operators to convert nulls to bools.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Use if-null operators to convert nulls to bools.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">if (nullableBool == true) {\n}\nif (nullableBool != false) {\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">if (nullableBool ?? false) {\n}\nif (nullableBool ?? true) {\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_if_null_to_convert_nulls_to_bools.html"
    },
    {
        "key": "use_is_even_rather_than_modulo",
        "name": "Prefer intValue.isOdd/isEven instead of checking the result of % 2.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>PREFER</strong> the use of intValue.isOdd/isEven to check for evenness.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">bool isEven = 1 % 2 == 0;\nbool isOdd = 13 % 2 == 1;\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">bool isEven = 1.isEven;\nbool isOdd = 13.isOdd;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_is_even_rather_than_modulo.html"
    },
    {
        "key": "use_key_in_widget_constructors",
        "name": "Use key in widget constructors.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DO</strong> use key in widget constructors.</p>\n<p>It's a good practice to expose the ability to provide a key when creating public\nwidgets.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class MyPublicWidget extends StatelessWidget {\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class MyPublicWidget extends StatelessWidget {\n  MyPublicWidget({Key key}) : super(key: key);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_key_in_widget_constructors.html"
    },
    {
        "key": "use_late_for_private_fields_and_variables",
        "name": "Use late for private members with non-nullable type.",
        "type": "CODE_SMELL",
        "status": "BETA",
        "severity": "MINOR",
        "description": "<p>Use late for private members with non-nullable types that are always expected to\nbe non-null. Thus it's clear that the field is not expected to be <code>null</code> and it\navoids null checks.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">int? _i;\nm() {\n  _i!.abs();\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">late int _i;\nm() {\n  _i.abs();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_late_for_private_fields_and_variables.html"
    },
    {
        "key": "use_named_constants",
        "name": "Use predefined named constants.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>Where possible, use already defined const values.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">const Duration(seconds: 0);\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">Duration.zero;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_named_constants.html"
    },
    {
        "key": "use_of_void_result",
        "name": "Use of void result",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>This expression has a type of 'void' so its value can't be used.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when it finds an expression whose\ntype is <code>void</code>, and the expression is used in a place where a value is\nexpected, such as before a member access or on the right-hand side of an\nassignment.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>f</code> doesn't produce an\nobject on which <code>toString</code> can be invoked:</p>\n<p>{% prettify dart tag=pre+code %}\nvoid f() {}</p>\n<p>void g() {\n[!f()!].toString();\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Either rewrite the code so that the expression has a value or rewrite the\ncode so that it doesn't depend on the value.</p>\n\n@see https://dart.dev/tools/diagnostic-messages#use_of_void_result"
    },
    {
        "key": "use_raw_strings",
        "name": "Use raw string to avoid escapes.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>A raw string can be used to avoid escaping only backslashes and dollars.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">var s = 'A string with only \\\\ and \\$';\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">var s = r'A string with only \\ and $';\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_raw_strings.html"
    },
    {
        "key": "use_rethrow_when_possible",
        "name": "Use rethrow to rethrow a caught exception.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use rethrow to rethrow a caught exception.</p>\n<p>As Dart provides rethrow as a feature, it should be used to improve terseness\nand readability.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">try {\n  somethingRisky();\n} catch(e) {\n  if (!canHandle(e)) throw e;\n  handle(e);\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">try {\n  somethingRisky();\n} catch(e) {\n  if (!canHandle(e)) rethrow;\n  handle(e);\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_rethrow_when_possible.html"
    },
    {
        "key": "use_setters_to_change_properties",
        "name": "Use a setter for operations that conceptually change a property.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use a setter for operations that conceptually change a property.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">rectangle.setWidth(3);\nbutton.setVisible(false);\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">rectangle.width = 3;\nbutton.visible = false;\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_setters_to_change_properties.html"
    },
    {
        "key": "use_string_buffers",
        "name": "Use string buffers to compose strings.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO</strong> use string buffers to compose strings.</p>\n<p>In most cases, using a string buffer is preferred for composing strings due to\nits improved performance.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">String foo() {\n  final buffer = '';\n  for (int i = 0; i &lt; 10; i++) {\n    buffer += 'a'; // LINT\n  }\n  return buffer;\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">String foo() {\n  final buffer = StringBuffer();\n  for (int i = 0; i &lt; 10; i++) {\n    buffer.write('a');\n  }\n  return buffer.toString();\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_string_buffers.html"
    },
    {
        "key": "use_to_and_as_if_applicable",
        "name": "Start the name of the method with to/_to or as/_as if applicable.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p>From the <a href=\"https://dart.dev/guides/language/effective-dart/design\">design guide</a>:</p>\n<p><strong>PREFER</strong> naming a method to___() if it copies the object's state to a new object.</p>\n<p><strong>PREFER</strong> naming a method as___() if it returns a different representation backed by the original object.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class Bar {\n  Foo myMethod() {\n    return Foo.from(this);\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Bar {\n  Foo toFoo() {\n    return Foo.from(this);\n  }\n}\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">class Bar {\n  Foo asFoo() {\n    return Foo.from(this);\n  }\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/use_to_and_as_if_applicable.html"
    },
    {
        "key": "valid_regexps",
        "name": "Use valid regular expression syntax.",
        "type": "BUG",
        "status": "READY",
        "severity": "CRITICAL",
        "description": "<p><strong>DO</strong> use valid regular expression syntax when creating regular expression\ninstances.</p>\n<p>Regular expressions created with invalid syntax will throw a <code>FormatException</code>\nat runtime so should be avoided.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">print(RegExp(r'(').hasMatch('foo()'));\n</code></pre>\n<p><strong>GOOD:</strong></p>\n<pre><code class=\"language-dart\">print(RegExp(r'\\(').hasMatch('foo()'));\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/valid_regexps.html"
    },
    {
        "key": "variable_type_mismatch",
        "name": "Variable type mismatch",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>A value of type '{0}' can't be assigned to a const variable of type '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the evaluation of a constant\nexpression would result in a <code>CastException</code>.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the value of <code>x</code> is an\n<code>int</code>, which can't be assigned to <code>y</code> because an <code>int</code> isn't a <code>String</code>:</p>\n<p>{% prettify dart tag=pre+code %}\nconst Object x = 0;\nconst String y = [!x!];\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the declaration of the constant is correct, then change the value being\nassigned to be of the correct type:</p>\n<p>{% prettify dart tag=pre+code %}\nconst Object x = 0;\nconst String y = '$x';\n{% endprettify %}</p>\n<p>If the assigned value is correct, then change the declaration to have the\ncorrect type:</p>\n<p>{% prettify dart tag=pre+code %}\nconst Object x = 0;\nconst int y = x;\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#variable_type_mismatch"
    },
    {
        "key": "void_checks",
        "name": "Don't assign to void.",
        "type": "CODE_SMELL",
        "status": "READY",
        "severity": "MINOR",
        "description": "<p><strong>DO NOT</strong> assign to void.</p>\n<p><strong>BAD:</strong></p>\n<pre><code class=\"language-dart\">class A&lt;T&gt; {\n  T value;\n  void test(T arg) { }\n}\n\nvoid main() {\n  A&lt;void&gt; a = A&lt;void&gt;();\n  a.value = 1; // LINT\n  a.test(1); // LINT\n}\n</code></pre>\n\n@see https://dart-lang.github.io/linter/lints/void_checks.html"
    },
    {
        "key": "wrong_explicit_type_parameter_variance_in_superinterface",
        "name": "Wrong explicit type parameter variance in superinterface",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' is an '{1}' type parameter and can't be used in an '{2}' position in '{3}'.\n\nTry using 'in' type parameters in 'in' positions and 'out' type parameters in 'out' positions in the superinterface."
    },
    {
        "key": "wrong_number_of_parameters_for_operator",
        "name": "Wrong number of parameters for operator",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Operator '-' should declare 0 or 1 parameter, but {0} found.</em></p>\n<p><em>Operator '{0}' should declare exactly {1} parameters, but {2} found.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a declaration of an operator has\nthe wrong number of parameters.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the operator <code>+</code> must\nhave a single parameter corresponding to the right operand:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint operator [!+!](a, b) =&gt; 0;\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add or remove parameters to match the required number:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint operator +(a) =&gt; 0;\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#wrong_number_of_parameters_for_operator"
    },
    {
        "key": "wrong_number_of_parameters_for_setter",
        "name": "Wrong number of parameters for setter",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>Setters must declare exactly one required positional parameter.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a setter is found that doesn't\ndeclare exactly one required positional parameter.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because the setter <code>s</code> declares\ntwo required parameters:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nset [!s!](int x, int y) {}\n}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because the setter <code>s</code> declares\none optional parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nset [!s!]([int x]) {}\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Change the declaration so that there's exactly one required positional\nparameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nset s(int x) {}\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#wrong_number_of_parameters_for_setter"
    },
    {
        "key": "wrong_number_of_type_arguments",
        "name": "Wrong number of type arguments",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The type '{0}' is declared with {1} type parameters, but {2} type arguments\nwere given.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a type that has type parameters\nis used and type arguments are provided, but the number of type arguments\nisn't the same as the number of type parameters.</p>\n<p>The analyzer also produces this diagnostic when a constructor is invoked\nand the number of type arguments doesn't match the number of type\nparameters declared for the class.</p>\n<h4>Examples</h4>\n<p>The following code produces this diagnostic because <code>C</code> has one type\nparameter but two type arguments are provided when it is used as a type\nannotation:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<E> {}</p>\n<p>void f([!C&lt;int, int&gt;!] x) {}\n{% endprettify %}</p>\n<p>The following code produces this diagnostic because <code>C</code> declares one type\nparameter, but two type arguments are provided when creating an instance:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<E> {}</p>\n<p>var c = <a href=\"\">!C&lt;int, int&gt;!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>Add or remove type arguments, as necessary, to match the number of type\nparameters defined for the type:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C<E> {}</p>\n<p>void f(C<int> x) {}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#wrong_number_of_type_arguments"
    },
    {
        "key": "wrong_number_of_type_arguments_constructor",
        "name": "Wrong number of type arguments constructor",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The constructor '{0}.{1}' doesn't have type parameters.\n\nTry moving type arguments to after the type name."
    },
    {
        "key": "wrong_number_of_type_arguments_extension",
        "name": "Wrong number of type arguments extension",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The extension '{0}' is declared with {1} type parameters, but {2} type arguments were given.\n\nTry adjusting the number of type arguments."
    },
    {
        "key": "wrong_number_of_type_arguments_method",
        "name": "Wrong number of type arguments method",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The method '{0}' is declared with {1} type parameters, but {2} type arguments\nare given.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when a method or function is invoked\nwith a different number of type arguments than the number of type\nparameters specified in its declaration. There must either be no type\narguments or the number of arguments must match the number of parameters.</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the invocation of the\nmethod <code>m</code> has two type arguments, but the declaration of <code>m</code> only has one\ntype parameter:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint m<A>(A a) =&gt; 0;\n}</p>\n<p>int f(C c) =&gt; c.m<a href=\"2\">!&lt;int, int&gt;!</a>;\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the type arguments are necessary, then make them match the number of\ntype parameters by either adding or removing type arguments:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint m<A>(A a) =&gt; 0;\n}</p>\n<p>int f(C c) =&gt; c.m<int>(2);\n{% endprettify %}</p>\n<p>If the type arguments aren't necessary, then remove them:</p>\n<p>{% prettify dart tag=pre+code %}\nclass C {\nint m<A>(A a) =&gt; 0;\n}</p>\n<p>int f(C c) =&gt; c.m(2);\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#wrong_number_of_type_arguments_method"
    },
    {
        "key": "wrong_type_parameter_variance_in_superinterface",
        "name": "Wrong type parameter variance in superinterface",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "'{0}' can't be used contravariantly or invariantly in '{1}'.\n\nTry not using class type parameters in types of formal parameters of function types, nor in explicitly contravariant or invariant superinterfaces."
    },
    {
        "key": "wrong_type_parameter_variance_position",
        "name": "Wrong type parameter variance position",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "The '{0}' type parameter '{1}' can't be used in an '{2}' position.\n\nTry removing the type parameter or change the explicit variance modifier declaration for the type parameter to another one of 'in', 'out', or 'inout'."
    },
    {
        "key": "yield_each_in_non_generator",
        "name": "Yield each in non generator",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Yield-each statements must be in a generator function (one marked with either 'async*' or 'sync*').\n\nTry adding 'async*' or 'sync*' to the enclosing function."
    },
    {
        "key": "yield_in_non_generator",
        "name": "Yield in non generator",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "Yield statements must be in a generator function (one marked with either 'async*' or 'sync*').\n\nTry adding 'async*' or 'sync*' to the enclosing function."
    },
    {
        "key": "yield_of_invalid_type",
        "name": "Yield of invalid type",
        "type": "BUG",
        "status": "READY",
        "severity": "MAJOR",
        "description": "<p><em>The type '{0}' implied by the 'yield' expression must be assignable to '{1}'.</em></p>\n<h4>Description</h4>\n<p>The analyzer produces this diagnostic when the type of object produced by a\n<code>yield</code> expression doesn't match the type of objects that are to be\nreturned from the <code>Iterable</code> or <code>Stream</code> types that are returned from a\ngenerator (a function or method marked with either <code>sync*</code> or <code>async*</code>).</p>\n<h4>Example</h4>\n<p>The following code produces this diagnostic because the getter <code>zero</code> is\ndeclared to return an <code>Iterable</code> that returns integers, but the <code>yield</code> is\nreturning a string from the iterable:</p>\n<p>{% prettify dart tag=pre+code %}\nIterable<int> get zero sync* {\nyield [!'0'!];\n}\n{% endprettify %}</p>\n<h4>Common fixes</h4>\n<p>If the return type of the function is correct, then fix the expression\nfollowing the keyword <code>yield</code> to return the correct type:</p>\n<p>{% prettify dart tag=pre+code %}\nIterable<int> get zero sync* {\nyield 0;\n}\n{% endprettify %}</p>\n<p>If the expression following the <code>yield</code> is correct, then change the return\ntype of the function to allow it:</p>\n<p>{% prettify dart tag=pre+code %}\nIterable<String> get zero sync* {\nyield '0';\n}\n{% endprettify %}</p>\n\n@see https://dart.dev/tools/diagnostic-messages#yield_of_invalid_type"
    }
]